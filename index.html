<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="corresponding">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="corresponding">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="corresponding">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>corresponding</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">corresponding</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/20/20171220-Okio-source/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="corresponding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corresponding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/20/20171220-Okio-source/" itemprop="url">Okio源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-20T19:39:26+08:00">
                2017-12-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <img src="/2017/12/20/20171220-Okio-source/1.jpg" title="深秋">
<p>大家一定听说或者使用过鼎鼎大名的OKHttp和Retrofit，它们内部都调用了Okio。<br>它们三个都是Square团队开源的库，主要处理I/O操作和网络请求。<br>今天我们就来读下Okio的源码，看看Okio有什么神奇之处。</p>
<h1 id="Okio是什么"><a href="#Okio是什么" class="headerlink" title="Okio是什么?"></a>Okio是什么?</h1><p>Okio是一个完善java.io和java.nio的库，可以更方便的读、写、处理数据。</p>
<p>看到上面的官方介绍，我们可以发现两个重点：<br>1.完善java.io和java.nio；<br>2.Okio的主要功能是，读、写、处理数据。</p>
<p>再深入思考下，java.io和java.nio有哪些尚未完善的地方？Okio有做了哪些优化？</p>
<p>java.io能处理所有的IO信息，但是还是有些不完美之处：<br>1.需要自己去管理byte数组；<br>2.java.io类和继承关系过于复杂，使用起来更加不便；<br>3.java.io操作可能会某些原因读取速度特别慢，甚至一直等待无法返回；<br>4.操作字符流和字节流方法不同，需要区别对待；<br>5.涉及到多个流之间的数据传递，需要反复拷贝，效率不高。</p>
<p>被Android官方青睐的IO库，Okio一一解决了这些问题：<br>1.使用ByteString去封装byte数组；<br>2.简化类关系，主要使用Buffer、Sink、Source等类，相互关系简单；<br>3.使用Timeout去控制超时；<br>4.可用相同方法去操作字符流和字节流；<br>5.提高多个流之间的数据传递速度。</p>
<p>带着这些问题，我们继续前进。</p>
<h1 id="ByteString"><a href="#ByteString" class="headerlink" title="ByteString"></a>ByteString</h1><p>记得我最开始编程时，C语言中没有字符串类型，只能使用char*的方式存储字符串，而且经常涉及数组和指针的转换，<br>需要使用memcpy和memset等等函数，容易出错，而且还需要加入大量的检测。<br>后面使用面向对象语言后，发现用String对象直接管理字符串，良好的封装char数组的常用方法，使用起来各种清爽。</p>
<p>同样使用过java.io的开发者，肯定会想起被byte数组笼罩的恐惧。<br>需要不厌其烦的处理一串串byte数组，完成encode和decode函数，还要特别关注编码问题。<br>这个时候就希望，能有一个对象来管理byte数组，并且帮我们封装好各种函数，使用时直接调用下即可。</p>
<p>Okio就满足开发者这个愿望，提供了ByteString类，把对字节数组的常用方法都封装好了。<br>使用Okio库后，开发者可以以ByteString作为最小粒度进行操作。</p>
<p>先来看下ByteString的组成<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.实现了Serializable和Comparable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteString</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">ByteString</span>&gt; &#123;</span></span><br><span class="line">  <span class="comment">// 1.byte数组，所以为ByteString</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">byte</span>[] data;</span><br><span class="line">  <span class="comment">// 2.hashCode，在需要时才计算出。不会被序列化</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> hashCode;</span><br><span class="line">  <span class="comment">// 3.data utf8化后生成的String，在需要时才计算出。不会被序列化</span></span><br><span class="line">  <span class="keyword">transient</span> String utf8; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ByteString的内部也不复杂，主要就是byte数组。<br>这里要看下String的结构，其实String可以命名为CharString。<br>因为一般开发中，字符串用的比较多，所以java官方直接命名为String。<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.同样实现了Serializable和Comparable接口，额外实现了CharSequence处理常规char数组数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.char数组，所以String等于CharString</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">	<span class="comment">// 2.hashCode</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下去看下，ByteString的读和写<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteString <span class="keyword">read</span>(InputStream in, <span class="keyword">int</span> byteCount) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.检查合法性</span></span><br><span class="line">    <span class="keyword">if</span> (in == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"in == null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (byteCount &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"byteCount &lt; 0: "</span> + byteCount);</span><br><span class="line">    <span class="comment">// 2.分配空间</span></span><br><span class="line">    <span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span class="keyword">byte</span>[byteCount];</span><br><span class="line">    <span class="comment">// 3.循环读取inputStream中的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> offset = <span class="number">0</span>, <span class="keyword">read</span>; offset &lt; byteCount; offset += <span class="keyword">read</span>) &#123;</span><br><span class="line">      <span class="comment">// 3.1.每次尽可能多的读取inputStream数据，放入result中</span></span><br><span class="line">      <span class="keyword">read</span> = in.<span class="keyword">read</span>(result, offset, byteCount - offset);</span><br><span class="line">      <span class="comment">// 3.2.读取inputStream异常</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">read</span> == -<span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.生成ByteString</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ByteString(result);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span>(<span class="params">OutputStream <span class="keyword">out</span></span>) throws IOException </span>&#123;</span><br><span class="line">	<span class="comment">// 1.检查合法性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">out</span> == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"out == null"</span>);</span><br><span class="line">	<span class="comment">// 2.直接写入byte数组</span></span><br><span class="line">    <span class="keyword">out</span>.write(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h1><p>IO操作的最重要部分就是对流的处理，所以定义好一个流非常关键。<br>Okio中，就是用Buffer去表示流。</p>
<img src="/2017/12/20/20171220-Okio-source/2.png" title="Buffer类关系图">
<p>先看下翻译<br>source：来源；水源；<br>sink：水槽；洗涤槽；<br>一下子就明白了Source表示输入源，Sink表示输出源。<br>对应java.io中的inputStream和outputStream。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> <span class="keyword">implements</span> <span class="title">BufferedSource</span>, <span class="title">BufferedSink</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">  Segment head;</span><br><span class="line">  <span class="keyword">long</span> size;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>size表示Buffer中的字节数量。<br>主要成员变量也非常简单，就是segment。<br>源码上注释非常简洁清晰：A segment of a buffer，翻译过来就是Buffer的片段。<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span> </span>&#123;</span><br><span class="line">  Segment prev;			<span class="comment">// 指向双向链表上一节点</span></span><br><span class="line">  Segment next;			<span class="comment">// 指向双向链表下一节点</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">byte</span>[] data;    <span class="comment">// data表示本segment存储的数据</span></span><br><span class="line">  <span class="keyword">int</span> pos;              <span class="comment">// pos表示data中下一个读取字节的index</span></span><br><span class="line">  <span class="keyword">int</span> limit;            <span class="comment">// limit表示data中下一个写入字节的index。为什么用limit命名呢，因为这个index也是读取字节的上限</span></span><br><span class="line">  <span class="keyword">boolean</span> shared;       <span class="comment">// 是否共享。Okio为了提高效率，在某些时候不拷贝整个segment，而是采用弱引用方式指向segment</span></span><br><span class="line">  <span class="keyword">boolean</span> owner;        <span class="comment">// 因为加入共享功能后，就需要确定持有者，只有持有者才能往这个segment中写数据</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从prev和next就可以发现这是双向链表。在Buffer中就持有head，通过head去访问整个链表。<br>通过后续的代码阅读，发现这是一个双向循环链表。</p>
<img src="/2017/12/20/20171220-Okio-source/3.png" title="segment双向链表">
<p>我们分析下Okio中是如何写入和读取byte数据的。</p>
<h2 id="Buffer-writeByte"><a href="#Buffer-writeByte" class="headerlink" title="Buffer.writeByte"></a>Buffer.writeByte</h2><p>先来看看Buffer怎么样写入一个byte<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.注意入参是int格式，不过其中有效数据的只有8 bit</span></span><br><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="function">Buffer <span class="title">writeByte</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1.寻找可供写入的segment</span></span><br><span class="line">    Segment tail = writableSegment(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 2.在segment中写入字节byte。limit的含义在上文提及，表示下一个写入字节的index</span></span><br><span class="line">    tail.data[tail.limit++] = (<span class="keyword">byte</span>) b;</span><br><span class="line">    <span class="comment">// 3.buffer中size变化</span></span><br><span class="line">	size += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>writeByte函数的代码都很简单，我们继续看看如何寻找可供写入的segment。</p>
<h2 id="Buffer-writableSegment"><a href="#Buffer-writableSegment" class="headerlink" title="Buffer.writableSegment"></a>Buffer.writableSegment</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.入参minimumCapacity表示允许写的最小空间</span></span><br><span class="line">Segment writableSegment(<span class="keyword">int</span> minimumCapacity) &#123;</span><br><span class="line">    <span class="comment">// 1.检查合法性</span></span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity &lt; <span class="number">1</span> || minimumCapacity &gt; Segment.<span class="keyword">SIZE</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 2.当前head为空时，先新建一个</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 2.1.从SegmentPool中取出一个segment</span></span><br><span class="line">      head = SegmentPool.take();</span><br><span class="line">      <span class="comment">// 2.2.设置为双向循环链表</span></span><br><span class="line">      <span class="keyword">return</span> head.<span class="keyword">next</span> = head.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.选择链表最尾部的segment</span></span><br><span class="line">    Segment tail = head.prev;</span><br><span class="line">    <span class="comment">// 4.如果尾部segment中没有足够的可写空间，或者当前Buffer不是尾部segment的持有者，重新从SegmentPool取出segment插入链表</span></span><br><span class="line">    <span class="keyword">if</span> (tail.limit + minimumCapacity &gt; Segment.<span class="keyword">SIZE</span> || !tail.owner) &#123;</span><br><span class="line">      tail = tail.<span class="keyword">push</span>(SegmentPool.take());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里引入了SegmentPool这个类，主要用来管理Segment对象，回收旧segment，分配segment。<br>SegmentPool减少了segment的新建和释放次数，缓解java GC的压力。</p>
<p>注：类似于Handler中message.obtain()，其背后也有一个pool去管理所有的message对象。</p>
<h2 id="SegmentPool"><a href="#SegmentPool" class="headerlink" title="SegmentPool"></a>SegmentPool</h2><p>这个类代码很短，全部贴出来<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> SegmentPool &#123;</span><br><span class="line">  <span class="comment">// pool 容量上限，最大为64KiB</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MAX_SIZE = <span class="number">64</span> * <span class="number">1024</span>;</span><br><span class="line">  <span class="comment">// 单向链表</span></span><br><span class="line">  <span class="keyword">static</span> Segment <span class="keyword">next</span>;</span><br><span class="line">  <span class="comment">// pool中总字节数</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">long</span> byteCount;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> SegmentPool() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Segment take() &#123;</span><br><span class="line">    <span class="comment">// take和recycle中next都被synchronize包含，所以是线程安全的</span></span><br><span class="line">    <span class="keyword">synchronized</span> (SegmentPool.<span class="keyword">class</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果当前pool不为空，链表还有数据，从链表头取出segment</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">next</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Segment result = <span class="keyword">next</span>;</span><br><span class="line">        <span class="keyword">next</span> = result.<span class="keyword">next</span>;</span><br><span class="line">        result.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">        byteCount -= Segment.<span class="keyword">SIZE</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前pool部为空，链表中没有数据，新建一个segment</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Segment();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> recycle(Segment segment) &#123;</span><br><span class="line">    <span class="keyword">if</span> (segment.<span class="keyword">next</span> != <span class="keyword">null</span> || segment.prev != <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 如果当前segment被共享，则放弃回收</span></span><br><span class="line">    <span class="keyword">if</span> (segment.shared) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// take和recycle中next都被synchronize包含，所以是线程安全的</span></span><br><span class="line">    <span class="keyword">synchronized</span> (SegmentPool.<span class="keyword">class</span>) &#123;</span><br><span class="line">      <span class="comment">// pool达到上限的，放弃回收</span></span><br><span class="line">      <span class="keyword">if</span> (byteCount + Segment.<span class="keyword">SIZE</span> &gt; MAX_SIZE) <span class="keyword">return</span>;</span><br><span class="line">      byteCount += Segment.<span class="keyword">SIZE</span>;</span><br><span class="line">      segment.<span class="keyword">next</span> = <span class="keyword">next</span>;</span><br><span class="line">      <span class="keyword">next</span> = segment;</span><br><span class="line">      <span class="comment">// 重新设置segment的pos和limit</span></span><br><span class="line">      segment.pos = segment.limit = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>segmentPool这个类非常简单，内部维护一个单向列表。<br>take()会从头部取出segment，recycler()将待回收的segment放回到链表头部。</p>
<h2 id="Buffer-readByte"><a href="#Buffer-readByte" class="headerlink" title="Buffer.readByte"></a>Buffer.readByte</h2><p>我们来看下readByte，其方法和writeByte完全对称。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span> readByte() &#123;</span><br><span class="line">    <span class="comment">// 1.检查合法性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">size</span> == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"size == 0"</span>);</span><br><span class="line">    <span class="comment">// 2.取出segment中数据</span></span><br><span class="line">    Segment segment = head;</span><br><span class="line">    <span class="keyword">int</span> pos = segment.pos;</span><br><span class="line">    <span class="keyword">int</span> limit = segment.limit;</span><br><span class="line">    <span class="keyword">byte</span>[] data = segment.data;</span><br><span class="line">    <span class="keyword">byte</span> b = data[pos++];</span><br><span class="line">    <span class="keyword">size</span> -= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 3.如果当前segment中数据被读取完毕</span></span><br><span class="line">    <span class="keyword">if</span> (pos == limit) &#123;</span><br><span class="line">      <span class="comment">// 3.1.从双向链表中pop出来</span></span><br><span class="line">      head = segment.<span class="keyword">pop</span>();</span><br><span class="line">      <span class="comment">// 3.2.回收这个segment，放入到segmentPool中</span></span><br><span class="line">      SegmentPool.recycle(segment);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 4.如果当前segment中数据未被读取完毕，只更新pos信息</span></span><br><span class="line">      segment.pos = pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h1><p>IO最重要的就是对流的处理，Okio中对应的数据结构是Source和Sink</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.Closeable接口中方法为close()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Source</span> <span class="keyword">extends</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.读取Buffer中byteCount长度的数据，返回值为本次读取的字节长度</span></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">read</span><span class="params">(Buffer sink, <span class="keyword">long</span> byteCount)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">  <span class="comment">// 2.超时控制</span></span><br><span class="line">  <span class="function">Timeout <span class="title">timeout</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 3.关闭source并且释放资源，允许调用多次</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个接口，后续都是使用其实现类作为输入流。</p>
<h2 id="Okio-Source"><a href="#Okio-Source" class="headerlink" title="Okio.Source"></a>Okio.Source</h2><p>我们看下Okio.Source，开发者一般都使用这个函数生成Source。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function">Source <span class="title">source</span><span class="params">(<span class="keyword">final</span> InputStream in, <span class="keyword">final</span> Timeout timeout)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.检查合法性</span></span><br><span class="line">    <span class="keyword">if</span> (in == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"in == null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout == null"</span>);</span><br><span class="line">    <span class="comment">// 2.新建了一个匿名类，实现Source接口</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Source() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">long</span> <span class="title">read</span><span class="params">(Buffer sink, <span class="keyword">long</span> byteCount)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 2.1.检查合法性</span></span><br><span class="line">        <span class="keyword">if</span> (byteCount &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"byteCount &lt; 0: "</span> + byteCount);</span><br><span class="line">        <span class="keyword">if</span> (byteCount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 2.2.检查是否超时</span></span><br><span class="line">          timeout.throwIfReached();</span><br><span class="line">          <span class="comment">// 2.3.寻找可供写入的segment，在之前详细解释过</span></span><br><span class="line">          Segment tail = sink.writableSegment(<span class="number">1</span>);</span><br><span class="line">          <span class="comment">// 3.3.当前segment剩余可以写入大小，和byteCount两者间选择较小的值，设置为maxToCopy</span></span><br><span class="line">          <span class="keyword">int</span> maxToCopy = (<span class="keyword">int</span>) Math.min(byteCount, Segment.SIZE - tail.limit);</span><br><span class="line">          <span class="comment">// 3.4.从InputStream中尽可能的提取maxToCopy长度，写入到segment中</span></span><br><span class="line">          <span class="keyword">int</span> bytesRead = in.read(tail.data, tail.limit, maxToCopy);</span><br><span class="line">          <span class="comment">// 3.5.读取异常</span></span><br><span class="line">          <span class="keyword">if</span> (bytesRead == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          <span class="comment">// 3.6.调整segment和buffer中的参数</span></span><br><span class="line">          tail.limit += bytesRead;</span><br><span class="line">          sink.size += bytesRead;</span><br><span class="line">          <span class="keyword">return</span> bytesRead;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AssertionError e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (isAndroidGetsocknameError(e)) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(e);</span><br><span class="line">          <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        in.close();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function">Timeout <span class="title">timeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timeout;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function">String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"source("</span> + in + <span class="string">")"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码逻辑非常清晰，流水型执行下去即可。<br>这里出现了一个新的对象timeout，用来管理超时，我们看看其内部结构。</p>
<h2 id="Timeout"><a href="#Timeout" class="headerlink" title="Timeout"></a>Timeout</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Timeout</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.判断deadlineNanoTime是否被定义。如果缺少该变量的话，deadlineNanoTime或者timeoutNanos为0时，无法判断是未设置还是设置为0</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> hasDeadline;</span><br><span class="line">  <span class="comment">// 2.截止时间，单位为纳秒</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> deadlineNanoTime;</span><br><span class="line">  <span class="comment">// 3.设定的超时时间间隔，单位为纳秒</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> timeoutNanos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Timeout主要用来设置超时时间，对Stream的读取超过指定时间后，认定为失败，开发者需要选择close或者重新操作这个Stream。</p>
<p>注：读取网络Socket流时，有时会陷入无限等待中，需要使用AsyncTimeout。其新开线程监听超时。</p>
<p>继续看下上面被调用的throwIfReached()<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">throwIfReached</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.判断当前线程是否被中断</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedIOException(<span class="string">"thread interrupted"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.判断当前是否超时</span></span><br><span class="line">    <span class="keyword">if</span> (hasDeadline &amp;&amp; deadlineNanoTime - System.nanoTime() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedIOException(<span class="string">"deadline reached"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Okio-buffer"><a href="#Okio-buffer" class="headerlink" title="Okio.buffer"></a>Okio.buffer</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.这里传入上面通过Okio.source生成的Source</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BufferedSource buffer(<span class="keyword">Source</span> <span class="keyword">source</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.生成BufferSource，真正处理输入流，你看命名中都写着real</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RealBufferedSource(<span class="keyword">source</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="RealBufferedSource"><a href="#RealBufferedSource" class="headerlink" title="RealBufferedSource"></a>RealBufferedSource</h1><p>终于找到开发者最后操作的Source类，先来看下它的成员吧。<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.实现BufferedSource接口</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealBufferedSource</span> <span class="keyword">implements</span> <span class="title">BufferedSource</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.初始化时自动生成</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Buffer buffer = <span class="keyword">new</span> Buffer();</span><br><span class="line">  <span class="comment">// 2.Okio.Buffer中传入的source对象</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Source source;</span><br><span class="line">  <span class="comment">// 3.判断source是否关闭</span></span><br><span class="line">  <span class="keyword">boolean</span> closed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="RealBufferedSource-read"><a href="#RealBufferedSource-read" class="headerlink" title="RealBufferedSource.read"></a>RealBufferedSource.read</h2><p>对于输入流来说，我们需要紧紧抓住read方法。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override <span class="keyword">public</span> <span class="keyword">int</span> <span class="built_in">read</span>(<span class="keyword">byte</span>[] sink, <span class="keyword">int</span> offset, <span class="keyword">int</span> byteCount) throws IOException &#123;</span><br><span class="line">    <span class="comment">// 1.检查合法性</span></span><br><span class="line">    checkOffsetAndCount(sink.length, offset, byteCount);</span><br><span class="line">    <span class="comment">// 2.当前buffer为空时</span></span><br><span class="line">    <span class="built_in">if</span> (<span class="built_in">buffer</span>.<span class="built_in">size</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 2.1.尽可能读取一个segment放入到buffer中</span></span><br><span class="line">      <span class="keyword">long</span> <span class="built_in">read</span> = source.<span class="built_in">read</span>(<span class="built_in">buffer</span>, Segment.SIZE);</span><br><span class="line">      <span class="comment">// 2.2.读取异常</span></span><br><span class="line">      <span class="built_in">if</span> (<span class="built_in">read</span> == <span class="number">-1</span>) <span class="built_in">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.选择buffer中数据和byteCount中较小值</span></span><br><span class="line">    <span class="keyword">int</span> toRead = (<span class="keyword">int</span>) Math.<span class="built_in">min</span>(byteCount, <span class="built_in">buffer</span>.<span class="built_in">size</span>);</span><br><span class="line">    <span class="comment">// 4.将buffer中数据输出到byte数组</span></span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">buffer</span>.<span class="built_in">read</span>(sink, offset, toRead);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>主要流程就是，现将source数据读取到buffer中，再将buffer提取到byte数组中。buffer.read()这个函数这里就不展开讨论了，其原理和buffer.readByte非常相近。</p>
<h1 id="Sink"><a href="#Sink" class="headerlink" title="Sink"></a>Sink</h1><p>同理，完全对应的，也可以按照Okio.sink-&gt; Okio.buffer(Sink)-&gt; RealBufferedSink-&gt; RealBufferedSink.write()流程走完一遍Okio中关于写的操作。</p>
<p>总结，Okio这个库本身并不复杂，将常用的流和字节数据进行良好的封装，加之源码中相近的注释，阅读起来非常流畅，想必使用起来的体验也会非常棒。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/14/20171214-shrinking-apks-growing-installs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="corresponding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corresponding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/14/20171214-shrinking-apks-growing-installs/" itemprop="url">缩小APK，增加下载量</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-14T17:10:12+08:00">
                2017-12-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<ul>
<li>原文地址：<a href="https://medium.com/googleplaydev/shrinking-apks-growing-installs-5d3fcba23ce2" target="_blank" rel="noopener">Shrinking APKs, growing installs: How your app’s APK size impacts install conversion rates</a></li>
<li>原文作者：<a href="https://medium.com/@samueltolomei?source=post_header_lockup" target="_blank" rel="noopener">Sam Tolomei</a></li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li>
<li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO/shrinking-apks-growing-installs.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO/shrinking-apks-growing-installs.md</a></li>
<li>译者：<a href="https://github.com/tanglie1993" target="_blank" rel="noopener">tanglie1993</a></li>
<li>校对者：<a href="http://www.swants.cn" target="_blank" rel="noopener">swants</a>, <a href="https://github.com/corresponding" target="_blank" rel="noopener">corresponding</a></li>
</ul>
</blockquote>
<h1 id="缩小APK，增加下载量"><a href="#缩小APK，增加下载量" class="headerlink" title="缩小APK，增加下载量"></a>缩小APK，增加下载量</h1><h2 id="你的APK大小是如何影响下载转化率的"><a href="#你的APK大小是如何影响下载转化率的" class="headerlink" title="你的APK大小是如何影响下载转化率的"></a>你的APK大小是如何影响下载转化率的</h2><img src="/2017/12/14/20171214-shrinking-apks-growing-installs/0.png">
<p>自从 Android Marketplace （Google Play 的前身）在 2012 年 3 月上线以来，<strong>app 的平均大小增长了四倍</strong>。随着移动 app 的不断成熟，开发者们不断增加新的特性来服务和吸引用户，这使不少人从中受益。然而，随着 app 的特性越来越多——更多 SDK、更高分辨率的图片、更好的图形—— APK 也变得越来越大。在本文中，我讨论了 APK 大小的重要性，并且分析了 Google 在过去 2 年中所做的用户体验研究的结果。<br><img src="/2017/12/14/20171214-shrinking-apks-growing-installs/1.png"></p>
<p>下载的 APK 的平均大小随时间的变化（Google 内部数据）</p>
<p>发现 APK 在变大之后，我们分析了 APK 大小对下载转化率的影响。我们发现，<strong>更小的 APK 对应着更高的下载转化率</strong>，对于新兴市场中的用户而言尤其如此。在许多开发者把注意力投入到向新市场（特别是新兴市场）扩张中去的情况下，关注 app 的大小就显得很重要。</p>
<h3 id="APK-大小是否会影响下载转化率？"><a href="#APK-大小是否会影响下载转化率？" class="headerlink" title="APK 大小是否会影响下载转化率？"></a><strong>APK 大小是否会影响下载转化率？</strong></h3><p>为了研究 APK 大小对用户的选择是否有显著影响，我们分析了<strong>用户在浏览了 Play store 中的一个项目之后成功下载这个 app 的百分比</strong>。</p>
<img src="/2017/12/14/20171214-shrinking-apks-growing-installs/2.png">
<p>在 App store  的相应页面中，你可以通过点击“Read More”看到一个 app 的大小。</p>
<p>这看起来还是有些意义的！总的来说，我们发现在小于 100 MB 的情况下，APK 大小和下载转化率之间存在负相关。<strong>一个 APK 的大小每增长 6 MB，下载转化率就有 1% 的降低</strong>。在市场团队使用 A/B 测试来优化下载转化率的情况下，APK 大小会有重大影响。</p>
<p>这个下降中的一个重要部分不是因为用户选择了不下载，而是下载由于种种原因没有成功。我们发现，一个 10MB 的 app 的下载完成率将比 100MB 的 app 高<strong>大约 30%</strong>。</p>
<p>这可能是因为：</p>
<ol>
<li>用户考虑了需要下载的数据量（以及数据的<strong>价格</strong>）。</li>
<li>在他们的移动网络或 wifi 中的 <strong>下载所需时间</strong> （人们经常陷入“我现在就要这个 app！”的思维模式）。</li>
<li>下载过程中的 <strong>网络连接性问题</strong>。</li>
</ol>
<h3 id="人们对-APK-大小的偏好和下载转化率是否会因地域而异？"><a href="#人们对-APK-大小的偏好和下载转化率是否会因地域而异？" class="headerlink" title="人们对 APK 大小的偏好和下载转化率是否会因地域而异？"></a><strong>人们对 APK 大小的偏好和下载转化率是否会因地域而异？</strong></h3><p>这是一个好问题，答案是肯定的。在新兴市场中，有许多没能使用到稳定 wifi 的用户，他们需要支付流量的费用。</p>
<p><strong>超过 50% 的印度和印尼安卓智能手机用户完全没有 wifi</strong>。所以如果一个用户需要下载一个 app，他很可能要为 APK 的每一 MB 付费（Google 内部数据，2017年）。</p>
<img src="/2017/12/14/20171214-shrinking-apks-growing-installs/3.png">
<p>印度 wifi 普及率调查 (Google 内部安卓用户调查)</p>
<p>与之相似, 出于流量价格和存储空间的考虑，<strong>新兴市场中大约 70% 的用户会在下载前考虑 app 的大小</strong>。</p>
<img src="/2017/12/14/20171214-shrinking-apks-growing-installs/4.png">
<p>被调查的印尼用户中会在安装时考虑 app 大小的人所占百分比 (Google 内部安卓用户调查)</p>
<img src="/2017/12/14/20171214-shrinking-apks-growing-installs/5.png">
<p>安装时会考虑 app 大小的用户这样做的原因 (Google 内部安卓用户调查)</p>
<p>我们可以看到，这些市场偏好非常显著。比如，新兴市场（如中东、非洲和东南亚）用户下载的 APK 的平均大小，<strong>是发达市场（如美国和西欧）的四分之一</strong>。</p>
<img src="/2017/12/14/20171214-shrinking-apks-growing-installs/6.png">
<p>APK 大小中位数，根据下载量加权，按市场分类。绿色 = 更大的中位数 APK 大小，红色 = 更小的 中位数 APK 大小（Google 内部数据）。</p>
<p>研究下载转化率数据，就可以发现新兴市场（如印度和巴西）和发达市场（如日本、美国和德国）相比，在面对越来越大的 APK 时会有不同的反应。</p>
<img src="/2017/12/14/20171214-shrinking-apks-growing-installs/7.png">
<p>APK 每缩小 10MB 对应下载转化率的增加，按市场分类（Google 内部数据）。</p>
<p>从上图中，我们可以看到 APK 缩小 10MB，在印度和巴西造成的影响会比德国、美国和日本更大。从 APK 中移除 10MB 内容，在新兴市场中对应着 <strong>下载转化率 2.5% 的增长</strong>。</p>
<p>让我们把实际的数字填入下载转化率的增长中：如果你的 app 在印度每个月有 10000 下载量，转化率 20%，缩小 10MB 可以使得下载量每月增加 1140 左右。</p>
<p>最后，当把非游戏的 app 和游戏比较时，我们可以在下载转化率和 APK 大小之间看到类似的关系。但是，对于超过 500MB 的游戏而言，用户们对于 APK 大小的微小变化更不敏感。对于 500-3000MB 的游戏而言，APK 每缩小 200MB，下载转化率只增加 1%。</p>
<h3 id="那么，我是否应该缩小-APK？如果应该，该怎么做？"><a href="#那么，我是否应该缩小-APK？如果应该，该怎么做？" class="headerlink" title="那么，我是否应该缩小 APK？如果应该，该怎么做？"></a><strong>那么，我是否应该缩小 APK？如果应该，该怎么做？</strong></h3><p>根据以上数据很容易看出，对于全世界人民来说 APK 大小都是很重要的。</p>
<p>“这很重要，” 你说，“但是我具体可以如何缩小 APK 呢？” 我很高兴你这样问了！缩小 APK 有以下几个入门要点：</p>
<ul>
<li><p><a href="https://developer.android.com/topic/performance/reduce-apk-size.html" target="_blank" rel="noopener"><strong>缩小 APK</strong></a>安卓开发者网站上的入门教材，它包含了移除不使用的资源和压缩图片文件。</p>
</li>
<li><p><a href="https://developer.android.com/develop/quality-guidelines/building-for-billions.html" target="_blank" rel="noopener"><strong>Building for Billions 指南</strong></a>, 在安卓开发者网站上，它讨论了缩小 APK，以及其它针对新兴市场的措施。</p>
</li>
<li><a href="https://medium.com/googleplaydev/how-to-optimize-your-android-app-for-emerging-markets-7124c4180fc" target="_blank" rel="noopener"><strong>如何针对新兴市场优化你的应用</strong></a>, 我们团队的另一篇 medium 文章。针对新兴市场，通过三个 app 去分析优化带来的好处。</li>
</ul>
<p>至于其他的针对新兴市场的考虑，可以去 Google Play 的 <a href="https://developer.android.com/topic/billions/index.html" target="_blank" rel="noopener">Building for Billions</a> 网站上寻找指导。</p>
<p>我花很多篇幅讨论了在新兴市场中缩小 APK 的好处。还有一个另外的缩小 APK 的原因，<br>这就是 Android Instant App 要求更小的 APK。Instant App 允许安卓用户不经过安装直接使用，是另一种让你的用户发现你的 app 的方式。关于开始使用 <a href="https://developer.android.com/topic/instant-apps/index.html" target="_blank" rel="noopener">Android Instant App</a>，你可以在这里找到更多信息。你也可以学习更多 <a href="https://android-developers.googleblog.com/2017/08/android-instant-apps-best-practices-for.html" target="_blank" rel="noopener">管理下载内容大小的最佳实践</a>。</p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/06/20171206-android-binder-theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="corresponding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corresponding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/06/20171206-android-binder-theory/" itemprop="url">浅谈Binder通信原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-06T19:48:09+08:00">
                2017-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <img src="/2017/12/06/20171206-android-binder-theory/banner.jpg" title="怀念夏日">
<h1 id="主要成员"><a href="#主要成员" class="headerlink" title="主要成员"></a>主要成员</h1><p>我们先来梳理下Binder通信的几个重要的成员：<br>1.Binder驱动<br>2.应用<br>3.系统服务<br>4.Binder<br>其中应用和系统服务处于不同的进程，由靠Binder驱动进行信息交互。</p>
<p>在网购如此发达的现在，人人都清楚淘宝上的聊天流程。<br>在这个过程中，也有对应的部分：<br>1.淘宝<br>2.用户<br>3.店家<br>4.聊天窗口</p>
<p>注：真实的淘宝通信系统肯定有所不同，这里仅提取与Binder通信相近之处。<br>再注：本来想举微信聊天的例子，但是微信聊天中客户端和服务端的属性没那么明显，所以选择淘宝聊天流程。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">应用和系统服务处于不同进程              用户没在商家身边</span><br><span class="line">应用无法直接调用系统服务中函数          用户直接和商家口头对话</span><br><span class="line">应用需要通过<span class="keyword">Binder驱动去与系统服务通信 </span> 用户需要通过淘宝去和店家联系</span><br><span class="line"><span class="keyword">Binder驱动中管理各个Binder </span>             淘宝管理用户和商家的“聊天窗口”对象</span><br><span class="line">应用可以访问到指定地址                  用户可以访问到指定“聊天窗口”</span><br><span class="line">系统服务也可以访问到同一个地址          商家可以访问到同一个“聊天窗口”  </span><br><span class="line">应用和系统服务都监听这个地址中内容变化  用户和商家都关注这个“聊天窗口”，看到对方发信息过来，处理后回复</span><br></pre></td></tr></table></figure>
<h2 id="聊天窗口"><a href="#聊天窗口" class="headerlink" title="聊天窗口"></a>聊天窗口</h2><p>在用户和商家通信过程中，什么东西最重要呢？其实就是“聊天窗口”。<br>假设我们设计一个聊天系统，“聊天窗口”会有哪些重要的属性？<br>1.它是一个对象；<br>2.淘宝系统内部有一个地址k可以访问到它；<br>3.一端是用户，可以通过地址c访问到它；<br>4.另一端是商家，可以通过地址s访问到它。</p>
<p>同时也要需要解决很多问题，比如：<br>1.如何让用户联系到商家；<br>2.一个用户需要同事联系多个商家;<br>2.一个商家需要同时服务多个用户；<br>3.会不会有人把自己伪造成其他人等等。</p>
<h2 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h2><p>与“聊天窗口”类似，Binder也有对应的属性：<br>1.它是一个对象；<br>2.Binder驱动有一个地址k可以访问到它；<br>3.一端是应用，可以通过地址c访问到它；<br>4.另一端是系统服务，可以通过地址s访问到它。</p>
<p>同样也需要解决很多问题，比如：<br>1.如何让应用联系到系统服务；<br>2.一个应用需要同事联系多个系统服务;<br>2.一个系统服务需要同时服务多个应用；<br>3.会不会有应用把自己伪造成其他应用等等。</p>
<h1 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h1><p>让我们看看，用户如何联系到商家：</p>
<img src="/2017/12/06/20171206-android-binder-theory/binder_associate_taobao.png" title="淘宝聊天流程图">
<p>同样在Binder中，也有一套这样的流程：</p>
<img src="/2017/12/06/20171206-android-binder-theory/binder_associate.png" title="建立Binder流程图">
<p>这张图片清晰表述了整个流程<br>1.打开Binder驱动；<br>2.将系统服务中地址s和Binder驱动中地址k指向同一地址；<br>3.将应用地址c和Binder驱动中地址k指向同一地址。<br>整个过程结束后，应用中地址c和系统服务中地址s也指向同一地址。这样两个不同的进程就关联成功了。</p>
<h1 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h1><p>其中有一个重要的问题，应用如何找到Binder驱动中的地址k？<br>在每次Android重启后，Binder驱动中地址k都不相同，应该怎么办？</p>
<p>怎么解决这个问题呢？<br>首先想到的方法，每次都记录下这些服务，下次启动时从备份文件中读取。<br>这个方法看上去很干脆利落，但是有一个风险。<br>如果上次服务发生异常，备份文件中也记录错误的数据，那这个手机就完了，永远无法启动。</p>
<p>需要改变下策略，希望每次Android系统重启时，这些系统服务都是新生成的。<br>这些系统服务启动时没有历史包袱一身轻松，然后愉快的注册到服务管理中心中。<br>应用只需要向服务管理中心查询服务名，就可以获取到地址k。</p>
<p>在Binder通信，这个服务管理中心就是ServiceManager，它管理所有的服务。<br>主要完成这两项任务：<br>1.所有的系统服务启动时，需要把服务名字和服务记录到ServiceManager中；<br>2.所有的应用使用指定系统服务前，先根据服务名称去向ServiceManager索要服务。</p>
<p>注：上面步骤中，按照C/S架构中划分：<br>1.系统服务是客户端，ServiceManager是服务端；<br>2.应用是客户端，ServiceManager是服务端。</p>
<p>我们看下Binder通信流程图：<br><img src="/2017/12/06/20171206-android-binder-theory/binder_simple.png" title="Binder简略流程图"></p>
<p>再加入Binder驱动元素:<br><img src="/2017/12/06/20171206-android-binder-theory/binder_full.png" title="Binder完整流程图"></p>
<p>回到我们的例子，淘宝也有一个ServiceManager的角色，就是店铺黄页。<br>店铺黄页管理所有的店铺，也完成两项任务：<br>1.每个商家上线后都会去淘宝黄页注册，比如Nike店铺注册Nike；<br>2.用户去淘宝黄页询问Nike的商家，获取聊天窗口中店铺的地址。</p>
<p>这时细心的读者会发现一个问题，ServiceManager呢，这些系统服务和应用怎么找到它呢？<br>为了解决这个问题，Android系统不得不做例外处理：<br>1.在Android启动后，ServiceManager第一个初始化；<br>2.将自己编号设为0。<br>之后，无论是应用或者系统服务，都可以通过编码0访问到ServiceManager。</p>
<hr>
<p>后记：在上大学时去图书馆随便翻书看过到多米尼克，感慨这个世界群星璀璨，有各种天才。<br>他发明的多米尼克训练法，告知人们需要用串联、转化、联想等等法则去记忆。<br>在学习Android底层中，有太多的对象和函数，如果能将其中主要流程和真实生活产生对应，会加速学习过程，而且印象深刻。</p>
<img src="/2017/12/06/20171206-android-binder-theory/DominicOBrien.jpg" title="Dominic O" alt="Brien">
<p>多米尼克·奥布莱恩，1957年8月10出生于英国。1991年，他参加了由“世界大脑先生”托尼·布赞发起的第一届世界记忆锦标赛，凭其独创的“多米尼克记忆系统”，38秒记住一副扑克牌的顺序，30分钟记住2385个随机产生的数字，1个小时记住110种元素的原子序数、符号、类别和精确到4位小数的原子量，一时技惊四座，横扫所有对手，获得第一届世界记忆锦标赛的总冠军。此后十余年间，他先后获得8次世界记忆冠军，几乎打破所有记忆领域的世界纪录，成为举世公认的“世界首席记忆大师”。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/28/20171128-android-initiate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="corresponding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corresponding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/28/20171128-android-initiate/" itemprop="url">追溯Android的根源</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-28T19:33:32+08:00">
                2017-11-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <img src="/2017/11/28/20171128-android-initiate/android-initiate_head.jpg" title="创世纪">
<p>某日进去一小区被保安拦住，被问了三个哲学问题：<br>“你是谁？”<br>“你从哪里来？”<br>“你要到哪里去？”<br>于是我陷入了深深的沉思。</p>
<p>同样，学习Android也有三个终极问题：<br>什么是Android？<br>Android世界的起源？<br>Android中APP是怎么运行的？</p>
<p>对于第一个问题，大家都能很快的回答出来。简单来说，Android是一种基于Linux，主要用于移动设备的操作系统。<br>第三个问题这样回答：APP的屏幕显示、输入事件获取、视频、音频等各个功能，在Android底层都有其对应的系统服务。<br>当然其中涉及到ActivityManagerService，WindowManagerService等等，后续有空会展开分析。<br>今天，我们来好好地看下第二个问题，Android系统是如何启动的，探讨下Android系统的起源。</p>
<hr>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><h2 id="main"><a href="#main" class="headerlink" title="main()"></a>main()</h2><p>就像我们编写的第一行代码helloworld一样，main()是helloworld世界的入口。<br>在Android中，main()也是Android世界的第一个入口，这个入口的位置在system\core\init\init.cpp。</p>
<p>main()主要工作：<br>    1.参数校验<br>    2.挂载一些设备，设置权限（与传统Linux程序相同）<br>    3.初始化环境<br>    4.LoadBootScripts()加载待启动项<br>    5.处理待启动项</p>
<h2 id="LoadBootScripts"><a href="#LoadBootScripts" class="headerlink" title="LoadBootScripts()"></a>LoadBootScripts()</h2><p>作用就是，加载引导的脚本init.rc，所有开机需要启动的配置读写在这里面。<br>像Android这样完善而又庞大的系统，在开机时肯定要启动有无数的服务。<br>如果全部都写到函数中，想必会变成硬编码，不方便于配置，所以这里用脚本方式配置启动内容。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadBootScripts</span><span class="params">(ActionManager&amp; action_manager, ServiceList&amp; service_list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成解析器</span></span><br><span class="line">    Parser parser = CreateParser(action_manager, service_list);</span><br><span class="line">    <span class="comment">// 解析文件内容后，放入action_manager和service_list中</span></span><br><span class="line">    parser.ParseConfig(<span class="string">"/init.rc"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="init-rc"><a href="#init-rc" class="headerlink" title="init.rc"></a>init.rc</h2><p>该文件放在system\core\rootdir目录下<br>节选下其中重要的片段<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line">    class main</span><br><span class="line">    priority -20</span><br><span class="line">   <span class="built_in"> user </span>root</span><br><span class="line">   <span class="built_in"> group </span>root readproc</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    onrestart write /sys/android_power/request_state wake</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    onrestart restart wificond</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br></pre></td></tr></table></figure></p>
<p>这段代码表示：启动名为zygote的Service。zygote翻译过来是“受精卵”，可以孕育出新生命。<br>在Android中，zygote也是万物的起源。<br>这段代码清晰的指出了Zygote的代码入口：app_process。</p>
<h2 id="app-process"><a href="#app-process" class="headerlink" title="app_process"></a>app_process</h2><p>上面同样表示app_process是在目录/system/bin/中，不过因为这应该是软链接后的位置，<br>真实的位置在frameworks\base\cmds\app_process\App_main.cpp，而且入口也是main()。<br>这里截取其中的重要代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里有两个变量去控制新进程的诞生</span></span><br><span class="line">    <span class="keyword">bool</span> zygote = <span class="literal">false</span>;                <span class="comment">// 是否为zygote进程</span></span><br><span class="line">    <span class="keyword">bool</span> startSystemServer = <span class="literal">false</span>;     <span class="comment">// 是否启动系统服务，例如ActivityManagerService等</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; argc) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--zygote"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            zygote = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--start-system-server"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            startSystemServer = <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按照之前的入参--zygote --start-system-server分析，发现zygote和startSystemServer都被设置为true</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;   </span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args, zygote);  <span class="comment">// 终于接近zygote真实本体了！</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里看下runtime，是AppRuntime类。我们赶紧去寻找下它的start方法吧。<br>发现AppRuntime继承于AndroidRuntime，AndroidRuntime中提供start()方法</p>
<h2 id="AndroidRuntime"><a href="#AndroidRuntime" class="headerlink" title="AndroidRuntime"></a>AndroidRuntime</h2><p>位于frameworks\base\core\jni\AndroidRuntime.cpp中<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AndroidRuntime::start(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 开启virtual machine，这里env是JNIEnv*类型，指向整个Android的JNI世界</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    startVm(&amp;mJavaVM, &amp;env, zygote);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 给虚拟机注册JNI的函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    startReg(env);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 调用JNI static方法，启动zygote</span></span><br><span class="line"><span class="comment">    * 这里startClass是com.android.internal.os.ZygoteInit类</span></span><br><span class="line"><span class="comment">    * startMeth是startClass中的main()方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="startVm"><a href="#startVm" class="headerlink" title="startVm()"></a>startVm()</h3><p>这个函数有一超级长的check，最关键是最后一句JNI_CreateJavaVM(pJavaVM, pEnv, &amp;initArgs);<br>完成这个函数后，VM正式创建成功，后续可以开始通过JNI对native底层代码进行调用了。</p>
<h3 id="startReg"><a href="#startReg" class="headerlink" title="startReg()"></a>startReg()</h3><p>这个函数中，最重要的是register_jni_procs(gRegJNI, NELEM(gRegJNI), env)<br>其中gRegJNI表示待注册的JNI函数，截取一段给大家看看<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> RegJNIRec gRegJNI[] = &#123;</span><br><span class="line">    REG_JNI(register_android_os_Process),</span><br><span class="line">    REG_JNI(register_android_os_SystemProperties),</span><br><span class="line">    REG_JNI(register_android_os_Binder),</span><br><span class="line">    REG_JNI(register_android_os_Parcel),</span><br></pre></td></tr></table></figure></p>
<p>发现原来Parcel、Binder等等Android独有的特性都在此处被注册，后面就可以通过JNI方式直接调用。</p>
<h3 id="env-gt-CallStaticVoidMethod"><a href="#env-gt-CallStaticVoidMethod" class="headerlink" title="env-&gt;CallStaticVoidMethod"></a>env-&gt;CallStaticVoidMethod</h3><p>根据这个函数的入参，可以得知最后调用com.android.internal.os.ZygoteInit的main()函数。<br>从类名上可以推测出，这负责zygote的生成。</p>
<h2 id="zygoteInit-main"><a href="#zygoteInit-main" class="headerlink" title="zygoteInit.main()"></a>zygoteInit.main()</h2><p>对应的文件为frameworks\base\core\java\com\android\internal\os\ZygoteInit.java<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> argv[]) &#123;</span><br><span class="line">    <span class="comment">// 注册server socket，这里采用socket方式和其他进程通信</span></span><br><span class="line">    zygoteServer.registerServerSocket(socketName);</span><br><span class="line">    <span class="comment">// 加载classes,opengl,textsource等各种资源</span></span><br><span class="line">    preload(bootTimingsTraceLog);</span><br><span class="line">    <span class="comment">// 开启新进程，用以启动system server</span></span><br><span class="line">    <span class="built_in">if</span> (startSystemServer) &#123;</span><br><span class="line">        Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line">        r.<span class="built_in">run</span>();</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化zygote</span></span><br><span class="line">    caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">    caller.<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>说了这么多，大家一定被绕晕了吧，这里整理一张流程图，大家可以对着看。<br><img src="/2017/11/28/20171128-android-initiate/android_initiate.png" title="Android启动流程图"></p>
<p>这里走向两个分支，我们接下去也分开去介绍zygote和System server初始化。</p>
<h1 id="zygote"><a href="#zygote" class="headerlink" title="zygote"></a>zygote</h1><p>zygote，这是一个平凡而又伟大的进程，以后Android的所有进程都由他诞生。<br>我们继续来看下zygoteInit.main()中走向zygote分支的流程，后续调用zygoteServer.runSelectLoop()。</p>
<h2 id="zygoteServer-runSelectLoop"><a href="#zygoteServer-runSelectLoop" class="headerlink" title="zygoteServer.runSelectLoop()"></a>zygoteServer.runSelectLoop()</h2><p>对应的文件为frameworks\base\core\java\com\android\internal\os\zygoteServer.java<br>其主要功能是，不断接受请求并作出响应。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Runnable runSelectLoop(<span class="built_in">String</span> abiList) &#123;</span><br><span class="line">    <span class="comment">// 不断循环，接受并处理新请求</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 监听数据源</span></span><br><span class="line">        Os.poll(pollFds, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="comment">// 解析出数据源的命令</span></span><br><span class="line">            ZygoteConnection connection = peers.<span class="keyword">get</span>(i);</span><br><span class="line">            <span class="keyword">final</span> Runnable command = connection.processOneCommand(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> commond;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>zygote是采用poll的方式去监听数据源。<br>注：poll 是 Linux API 提供的复用方式。IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。<br>至此，zygote会处于runSelectLoop()的循环中，不断监听外部请求并作出响应，fork出进程。</p>
<h1 id="system-server"><a href="#system-server" class="headerlink" title="system server"></a>system server</h1><p>在android的启动过程中，我们也需要启动各种应用服务，我们来找下有他们是怎样诞生的。</p>
<h2 id="forkSystemServer"><a href="#forkSystemServer" class="headerlink" title="forkSystemServer()"></a>forkSystemServer()</h2><p>这个也在zygoteInit.main()中被调用到，上面已经有提及，这里就不重复列出了。<br>在这里发现了zygote的作用，zygote把自己的进程fork一份，用来启动各大系统服务。<br>zygote进程就像受精卵一样，慢慢分裂诞生出整个Android系统，并且在后续中，新进程的诞生也依赖与zygote的fork。<br>截取其中的重要代码<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Runnable forkSystemServer(）&#123;</span><br><span class="line">    pid = Zygote.forkSystemServer(</span><br><span class="line">                    parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                    parsedArgs.gids,</span><br><span class="line">                    parsedArgs.runtimeFlags,</span><br><span class="line">                    <span class="keyword">null</span>,</span><br><span class="line">                    parsedArgs.permittedCapabilities,</span><br><span class="line">                    parsedArgs.effectiveCapabilities);</span><br><span class="line">                    </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">handleSystemServerProcess</span><span class="params">(parsedArgs)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="handleSystemServerProcess"><a href="#handleSystemServerProcess" class="headerlink" title="handleSystemServerProcess()"></a>handleSystemServerProcess()</h2><p>handleSystemServerProcess()这个函数完成了fork后的剩余工作<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function">Runnable <span class="title">handleSystemServerProcess</span><span class="params">(ZygoteConnection.Arguments parsedArgs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加载system server dex的option</span></span><br><span class="line">    performSystemServerDexOpt(systemServerClasspath);</span><br><span class="line">    <span class="comment">// 启动system server </span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> ZygoteInit.<span class="title">zygoteInit</span><span class="params">(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ZygoteInit-zygoteInit"><a href="#ZygoteInit-zygoteInit" class="headerlink" title="ZygoteInit.zygoteInit()"></a>ZygoteInit.zygoteInit()</h2><p>从函数命名来看，这是各大应用服务的初始化地址。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="function">Runnable <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// native层的初始化system server</span></span><br><span class="line">    ZygoteInit.nativeZygoteInit();</span><br><span class="line">    <span class="comment">// 返回java层初始化system server的runnable，后续必然有run()的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> RuntimeInit.<span class="title">applicationInit</span><span class="params">(targetSdkVersion, argv, classLoader)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="RuntimeInit-applicationInit"><a href="#RuntimeInit-applicationInit" class="headerlink" title="RuntimeInit.applicationInit()"></a>RuntimeInit.applicationInit()</h2><p>越来越接近真相了，再坚持一会。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected static Runnable applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) &#123;</span><br><span class="line">    <span class="regexp">//</span> 未来app调用<span class="keyword">exit</span>()会直接退出，不会清理进程</span><br><span class="line">    nativeSetExitWithoutCleanup(true);</span><br><span class="line">    <span class="regexp">//</span> 寻找最终的类以及方法</span><br><span class="line">    return findStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="findStaticMain"><a href="#findStaticMain" class="headerlink" title="findStaticMain()"></a>findStaticMain()</h2><p>从函数命名可以看出，这回找到服务的main()函数并调用。<br>这里说明良好的说明有多重要，可以让其他开发者在阅读纯代码时就能get到函数的含义。<br>这里列下findStaticMain()的重要片段<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Runnable findStaticMain(String className, String[] argv, ClassLoader classLoader) &#123;</span><br><span class="line">    <span class="keyword">Class</span>&lt;?&gt; cl = <span class="keyword">Class</span>.forName(className, <span class="keyword">true</span>, classLoader);          <span class="comment">// 找到对应的类SystemServer</span></span><br><span class="line">    Method m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> <span class="keyword">Class</span>[] &#123; String[].<span class="keyword">class</span> &#125;);    <span class="comment">// 找到其中的main()函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MethodAndArgsCaller(m, argv);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="MethodAndArgsCaller"><a href="#MethodAndArgsCaller" class="headerlink" title="MethodAndArgsCaller"></a>MethodAndArgsCaller</h2><p>这是一个实现runnable的类，里面主要的run()就是去执行之前找到的method<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAndArgsCaller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ZygoteInit-main"><a href="#ZygoteInit-main" class="headerlink" title="ZygoteInit.main()"></a>ZygoteInit.main()</h2><p>我们继续回到ZygoteInit.main()<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> argv[]) &#123;</span><br><span class="line">    <span class="comment">// 回到最开始出发的地方，这里r</span></span><br><span class="line">    Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line">    <span class="comment">// 接下去果然是run，其中运行SystemServer.main()</span></span><br><span class="line">    <span class="built_in">if</span> (r != null) &#123;</span><br><span class="line">        r.<span class="built_in">run</span>();</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="SystemServer-main"><a href="#SystemServer-main" class="headerlink" title="SystemServer.main()"></a>SystemServer.main()</h2><p>这个函数里面就一句话，调用同一个类的run()<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">    <span class="keyword">new</span> SystemServer().<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="SystemServer-run"><a href="#SystemServer-run" class="headerlink" title="SystemServer().run()"></a>SystemServer().run()</h2><p>看来这个是SystemServer的启动地了，看下其中的关键代码<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">private</span> <span class="selector-tag">void</span> <span class="selector-tag">run</span>() &#123;</span><br><span class="line">    <span class="comment">// 准备主线程的Looper</span></span><br><span class="line">    <span class="selector-tag">Looper</span><span class="selector-class">.prepareMainLooper</span>();</span><br><span class="line">    <span class="comment">// 加载native的服务</span></span><br><span class="line">    <span class="selector-tag">System</span><span class="selector-class">.loadLibrary</span>(<span class="string">"android_servers"</span>);</span><br><span class="line">    <span class="comment">// 开启各项系统服务</span></span><br><span class="line">    <span class="selector-tag">startBootstrapServices</span>();</span><br><span class="line">    <span class="selector-tag">startCoreServices</span>();</span><br><span class="line">    <span class="selector-tag">startOtherServices</span>();</span><br><span class="line">    <span class="comment">// 开启Looper循环，不断监听事件</span></span><br><span class="line">    <span class="selector-tag">Looper</span><span class="selector-class">.loop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，system server全部启动成功，并且开启Looper循环，会不断监听外来的请求并响应。</p>
<p>这里也梳理下system server整个启动过程。<br><img src="/2017/11/28/20171128-android-initiate/android_systemserver.png" title="system server 启动流程图"></p>
<hr>
<p>我们已经清晰的梳理出Android的大致的启动流程。<br>可以结合上一篇文章《浅谈Android底层》一起看。上篇文章，在用户角度从表面慢慢推进到底层system server（包括ServiceManager、AMS、WMS等等）。再进一步，就是追溯这些zygote和system server的起源。</p>
<p>作为应用开发者，只需要完成两部：<br>1.配置AndroidManifest.xml的启动项<br>2.实现对应的Activity<br>就能完成最简单的应用。但是我始终会好奇其背后的神秘而又精密的机制。</p>
<p>我们身上始终留着追溯根源的血液。就像在遥远的古代，刀耕火种的人类在漫天星空下去追溯祖先的由来，构想了无数种文明的起源。此时，作为应用开发者，我们也在追溯Android系统的起源。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/22/20171122-touch-android-groundwork/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="corresponding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corresponding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/22/20171122-touch-android-groundwork/" itemprop="url">浅谈Android底层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-22T20:24:35+08:00">
                2017-11-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="学习的原因"><a href="#学习的原因" class="headerlink" title="学习的原因"></a>学习的原因</h1><blockquote>
<p>很多应用开发者对Android底层望而却步，主要有两个原因：<br>1.底层太难，我看不懂<br>2.学习底层知识对目前开发没有帮助</p>
</blockquote>
<h2 id="对于太难的这点"><a href="#对于太难的这点" class="headerlink" title="对于太难的这点"></a>对于太难的这点</h2><p>我觉得是因为一开始直接扑进源码里面，看到那些一长串一长串的函数，很容易看得晕头转向，恶心想吐。如果掌握合适的学习方法，会发现其实并没有这么困难。<br>我建议，在看源码前先理清Android底层的主干逻辑，再拆解出各个模块，各个击破。</p>
<h2 id="对于无帮助这点"><a href="#对于无帮助这点" class="headerlink" title="对于无帮助这点"></a>对于无帮助这点</h2><p>我觉得Android底层知识的即时回报非常小，但是长期回报是巨大的。<br>如果能熟悉Android底层的原理，当在开发中遇到一些奇奇怪怪的问题时，我们可以通过debug和查看log等方式，结合底层原理去发现蛛丝马迹，真正解决一部分烦人的小概率bug。而且熟悉android底层的设计架构，在未来做软件架构设计时，可以参考借鉴，甚至可以在此基础上设计出更棒的架构。<br>这话听上去觉得特别夸张，其实不然，有两点原因：<br>1.Android底层的架构也在不断调整和优化中，这说明目前的不是最优解；<br>2.Android更新迭代了这么多版本，需要兼容旧版本，有些地方不能完全放开去设计，需要在兼容和完全优化中做选择。</p>
<hr>
<p>作者在学习过程中，尝试按照自己的思路总结Android底层主干逻辑。肯定会有许多不足之处，希望大家多多指出。<br>由表到底，分成三层：</p>
<blockquote>
<p>1.应用程序背后：Android的各大系统服务<br>2.如何获取这些系统服务：ServiceManager<br>3.如何通信：Binder体系</p>
</blockquote>
<h1 id="应用程序背后：Android的各大系统服务"><a href="#应用程序背后：Android的各大系统服务" class="headerlink" title="应用程序背后：Android的各大系统服务"></a>应用程序背后：Android的各大系统服务</h1><p>这里首先要说明下，ActivityManagerService等各种应用服务，虽然说以Service结尾，但是这与Android四大组件Service并无关系。四大组件中的Service，主要提供需要在后台长期运行的服务（如复杂计算、下载等等）；这里的Service代表Client/Server架构中的Server。</p>
<p>Client/Server架构简称为C/S架构，也是客户端/服务器端架构。服务器端主要提供数据管理、数据共享、数据及系统维护和并发控制等，客户端程序主要完成用户的具体的业务。<br>在Android系统中，Client就是我们写的各种应用程序，Server实现页面跳转，屏幕展示等功能细节。Client向Server发出命令，Server去实现完整的功能。</p>
<blockquote>
<p>注：Client/Server架构是Server，我们说的Android系统服务是Service。虽然说都是表示“服务”，建议还是注意下拼写，方便更好区分。</p>
</blockquote>
<h2 id="我举一个简单的例子"><a href="#我举一个简单的例子" class="headerlink" title="我举一个简单的例子"></a>我举一个简单的例子</h2><blockquote>
<p>应用开发者常见的工作是，去实现一个Activity并且显示在手机屏幕上。<br>对于最简单的页面，开发者只要做三步：<br>1.AndroidManifest文件加入声明<br>2.Activity中设置setContentView<br>3.调用startActivity()去启动（发出指令，后续系统Service去实现）</p>
</blockquote>
<p>在背后辛勤工作的就是Android的各大系统服务，例如ActivityManagerService（后续简称AMS）主要管理Activity运行状态，WindowManagerService（后续简称WMS）主要负责控制手机屏幕显示内容。</p>
<h1 id="如何获取这些系统服务：ServiceManager"><a href="#如何获取这些系统服务：ServiceManager" class="headerlink" title="如何获取这些系统服务：ServiceManager"></a>如何获取这些系统服务：ServiceManager</h1><p>上一节简单的描述了下应用通过各大系统服务去完成Activity生成和屏幕显示。<br>这里就会有个问题，我们如何去获取这些服务。在应用开发中，如果我们需要使用第三方控件OkHttp，我们需要导入okhttp包，或者在gradle中写入对其的依赖，之后我们才可以调用OkHttp中的对象和方法。</p>
<p>在Android底层也是类似，其中有一个ServiceManager在统筹管理所有的服务。<br>还是采用上节说的C/S架构，应用程序是客户端，向ServiceManager服务端发起请求获取指定name的服务，要求服务端给与AMS的访问引用。<br>应用程序持有AMS的引用后，继续采用C/S架构。应用本身还是客户端，此时AMS充当服务端，处理服务端发起的各种Activitiy请求。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_01.png" title="Activity&AMS&WMS">
<p>这个时候就继续思考一步，AMS、WMS这些系统服务如何和ServiceManager建立联系的呢？<br>这是在Android手机开机时，AMS、WMS会向ServiceManager注册，将自己的name和实体传给ServiceManager，ServiceManager中会有专门的数据结构（红黑树）去记录这些数据。<br>注：这里还是采用C/S架构，不过AMS变成了客户端，ServiceManager变成服务端。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_02.png" title="AMS&ServerManager&APP">
<p>再再深入一步，我们需要通过ServiceManager获取其他服务，那我们怎么获取ServiceManager呢？<br>这里ServiceManager充当大管家的角色，是在开机时最先被创造的服务，并且被赋予0的代号。所有的服务都要先请示ServiceManager。<br>注：匿名服务除外，匿名服务不需要注册在ServiceManager。当前连接的服务直接传递匿名服务给应用。<br>后续启动的服务都可以根据0去找到ServiceManager，并且把自己注册进去。<br>注：这里还是采用C/S架构，不过AMS变成了客户端，ServiceManager变成服务端。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_03.png" title="AMS&system">
<p>至此我们把获取系统服务，从表到里分析了一遍。我们再换一个维度，以时间发展表述下。<br>注：学习的时候要时刻记住，所有的对象都不是直接持有，需要通过各种请求获取后才持有。<br>再注：这里的持有不一定是持有实体，可能是种引用。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_04.png" title="AMS&ServerManager&system">
<h1 id="如何通信：Binder体系"><a href="#如何通信：Binder体系" class="headerlink" title="如何通信：Binder体系"></a>如何通信：Binder体系</h1><p>上面我们了解了系统服务的作用和如何获取系统服务，还有一个更加基础的问题，应用如何和这些系统服务通信。</p>
<blockquote>
<p>在Android中，各个应用和各个服务处于不同的进程。就不能像进程内编程一样直接调用其他类的函数，需要进程间的通信（IPC：Inter-Process Communication）<br>这里Android采用Binder方式。</p>
</blockquote>
<p>这里思考下，Linux IPC常见的有pipe、socket、共享内存等等，为什么最后Android会选择Binder呢？<br>Android之间有大量的跨进程通信，对性能、安全性、易用性要求都很高，综合考虑后选择了Binder方式。</p>
<h2 id="继续问，Binder的性能优势？"><a href="#继续问，Binder的性能优势？" class="headerlink" title="继续问，Binder的性能优势？"></a>继续问，Binder的性能优势？</h2><p>socket主要用于网络通信，以TCP/IP作为基础，需要分包、重组等工作，所以效率递比较底下。<br>注：Android有采用Unix Domain Socket(UDS)，针对进程间通信优化。在Android中也有使用，这里暂不讨论。</p>
<p>pipe采用消息转发机制，需要两次拷贝。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_05.png" title="pipe">
<p>Binder在数据传输过程中，只需要一次拷贝。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_06.png" title="Binder">
<p>经过上述操作后，服务端地址s和客户端地址c指向同一块内存。<br>服务端想与客户端通信时，就将本地内容拷贝到地址s中，客户端在同时监听地址c中的内存变化，及时获取新信息。</p>
<h2 id="Binder的安全性优势？"><a href="#Binder的安全性优势？" class="headerlink" title="Binder的安全性优势？"></a>Binder的安全性优势？</h2><p>一般的Linux IPC在通信时，请求方会发送user id(uid)和process id(pid)，服务方后根据此去检查请求方的权限，判断后续是否给与服务。<br>看上去特别安全，但是根源上出现了问题，uid和pid是请求方添加的。这意味着，请求方A可以修改uid和pid，设置成B一样。服务端是没有办法识别出来，这样安全性就无法保障了。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_07.png" title="传统IPC">
<p>Binder优化了uid和pid机制，不再由请求方自己添加，而是由内核自动添加。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_08.png" title="Binder安全性">
<h2 id="Binder的易用性优势？"><a href="#Binder的易用性优势？" class="headerlink" title="Binder的易用性优势？"></a>Binder的易用性优势？</h2><p>采用C/S架构，应用和服务分离，逻辑清晰。<br>应用持有一个服务的引用，向该引用发起各种请求，引用内部在通过Binder的细节传输给正式的服务，应用开发者不需要管通信的细节。反之，像Linux IPC的共享内存，虽然不需要拷贝，性能特别高。但是使用起来特别复杂，应用开发者需要控制管理服务的内存。</p>
<p>至此，简单的讲述下了《Android的各大系统服务》，《如何获取这些系统服务：ServiceManager》，《如何通信：Binder体系》。当然，本篇只是描述下系统服务的最表层，背后还有许许多多的代码细节和设计者巧妙构思，后续出相关的文章和大家展示。</p>
<blockquote>
<p>里面出现最多的字样就是C/S架构，大家在学习中牢记这个架构，Android底层所有的细节都围绕这个展开。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/20/20171120-defensive-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="corresponding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corresponding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/20/20171120-defensive-code/" itemprop="url">防御式编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-20T18:50:20+08:00">
                2017-11-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/coding/" itemprop="url" rel="index">
                    <span itemprop="name">coding</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在我自己的编码工作中，调bug的时间至少占总时间的50%。<br>有些时候修复一个的bug甚至会占用几天的时间，最后发现问题出在几天没加条件预防的语句，这太让人恼火了。<br><br>我总是在苦恼，为何我的程序有这么多闪退。<br>为什么就不能有一个安全的编程环境给我们，让我们这些菜鸟写的代码不闪退。</p>
<blockquote>
<p>代码世界中危机丛生，程序跑着跑着就要歇菜。</p>
</blockquote>
<p>随着发际线的慢慢后退，我开始认清一个令人感觉残酷的现实：<br>这是你的代码，你需要为其付所有责任，包括最基础的安全性检查。</p>
<blockquote>
<p>慢慢的我们需要变得保守，不能轻易相信所有的数据，需要在使用前对其检查。</p>
</blockquote>
<hr>
<h1 id="防御式编程"><a href="#防御式编程" class="headerlink" title="防御式编程"></a>防御式编程</h1><p>原则：就是对来源数据持怀疑、不信任的态度<br>对调用者含有敌意，他们可能会放入各种奇怪的未经检查的数据。<br>其中最常用的就是null的判断。</p>
<p>在面向对象的编程中，任何一个对象都初始为null（final和 static关键字声明的变量除外）<br>当然，在一般情况下，变量会在使用前被赋值。<br>当调用null对象的方法时，会抛出NullPointerException。<br>如果没有及时对Exception进行捕获，程序就会报错。</p>
<h2 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h2><p>这里有常用的两种处理方法，两者相互合作，相辅相成。</p>
<h3 id="变量的预先检查"><a href="#变量的预先检查" class="headerlink" title="变量的预先检查"></a>变量的预先检查</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span>(<span class="params">Model arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == arg) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// arg的合理性检查</span></span><br><span class="line">        arg.<span class="keyword">do</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果变量不符合要求，后续代码无法继续执行。<br>可以改成如下方式：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Model arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == arg) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arg不符合要求) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异常后处理"><a href="#异常后处理" class="headerlink" title="异常后处理"></a>异常后处理</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="keyword">func</span><span class="params">(Model arg)</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        arg.<span class="keyword">do</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="type">NullPointerException</span> e) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="type">Exception</span> e) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>合理的使用Exception，能帮助我们更好的代码分层。</p>
</blockquote>
<p>Exception它可以报错误上报给调用链的上层。<br>每个函数都有他的职责范围和处理错误的范围，底层函数不需要处理所有的Exception，他可以将自己无法处理的Exception交给上级。</p>
<h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p>有人会有疑问：每个函数进入处都进行合理性检查，会不会特别降低效率。</p>
<p>对于一般的应用代码而言，这里的开销微乎其微，不用特别在意。<br>现有编译器都会帮用户做性能上优化。<br>如果对于底层或SDK的代码来说，还是需要注意下。</p>
<h2 id="每次都检查，烦"><a href="#每次都检查，烦" class="headerlink" title="每次都检查，烦"></a>每次都检查，烦</h2><p>有人表示：我倒是不纠结与性能，但是在一个深度调用链，每个函数都要写一遍参数检查，又繁琐又影响阅读。<br>我之前也一直在纠结这个问题，觉得很难控制这个度。后来在看Android源码，终于有点想明白了，可以靠函数名传递一些有用信息。（源码真是博大精深，里面有各种精巧的函数设计）<br>这是在ActivityManagerService启动Activity过程中，调用各种startActivityXXX函数。<br>下面简单罗列下</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">startActivityAsUser</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">startActivityMayWait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">startActivityLocked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">startActivityCheckedLocked</span><span class="params">()</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里可以发现，函数中名有Checked和Locked。</p>
</blockquote>
<p>checked表示已经检查过了各种权限，Locked表示处于线程安全的情况下。<br>如果我们需要写几个深度调用函数时，某些可以使用checked字样，就不用重复的做参数检查。</p>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>对于某些赋值后内容不会改变的变量（读上去有点拗口），可以加上final关键字。<br>不用每次检查是否为null，直接去检查其构造函数，看看其中没有null检查。</p>
<h2 id="IDE的warning"><a href="#IDE的warning" class="headerlink" title="IDE的warning"></a>IDE的warning</h2><p>发展到如今，IDE已经上warning提醒已经做得非常完善。<br>有时候因为做得过于完善，所以写一上午的代码，IDE啪啪啪列出十几条warning，大家反正懒得去看。就像每个香烟上都写着“吸烟有害健康”，也没见烟民们戒烟不抽。</p>
<blockquote>
<p>warning还是有用的，大家要理解IDE作者的良苦用心。</p>
</blockquote>
<p>最好是写好小一段代码，就去看看新增的warning，能过滤到一些低级的错误。</p>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>有人会说，这些安全性检查和处理，包括一些理论上不应该出现的情况。<br>本来出现这些情况，可以在开发过程中及时的闪退，在上线前修复。</p>
<blockquote>
<p>别担心，语言开发者早就想到了这个问题，祭出了大杀器Assert断言。</p>
</blockquote>
<p>而且现在的编译器，在release环境下会去掉断言，真是贴心。</p>
<h2 id="工具检查"><a href="#工具检查" class="headerlink" title="工具检查"></a>工具检查</h2><p>有时候难免有疏落，这个时候就需要lint去检查下。<br>在C/C++程序中，可以使用PC-lint，并且打开Pointer-parameter-may-be-NULL这个开关（+fpn）。选项假设所有传递到函数中的指针都有可能是NULL。</p>
<h2 id="重大错误"><a href="#重大错误" class="headerlink" title="重大错误"></a>重大错误</h2><p>如果当程序运行时出现重大错误，核心功能出现问题，程序还是会闪退的。<br>不要企图靠以上各种方法去续1s命。<br>这个时候就需要平时好好做好单元测试，以及好好对待测试人员，希望他们发现尽可能多的bug。</p>
<hr>
<p>总结下，这篇文章核心就是</p>
<blockquote>
<p>“对象使用前，要检查下其合理性”。</p>
</blockquote>
<p>当然检查的力度，是一个仁者见仁智者见智的问题。<br>一千个人读者有一千个哈姆雷特，有代码洁癖者，也有收放自如的高手。<br>这里面没有谁的策略更优。</p>
<blockquote>
<p>对自己来说，写的顺手bug少，最关键。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="corresponding" />
            
              <p class="site-author-name" itemprop="name">corresponding</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/corresponding" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-globe"></i>GitHub</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">corresponding</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
