<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="corresponding">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="corresponding">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="corresponding">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>corresponding</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">corresponding</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/02/20180702-learn-io/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="corresponding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corresponding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/02/20180702-learn-io/" itemprop="url">浅析IO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-02T17:16:49+08:00">
                2018-07-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IO/" itemprop="url" rel="index">
                    <span itemprop="name">IO</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <img src="/2018/07/02/20180702-learn-io/20180702_00.jpg">
<h1 id="1-I-O"><a href="#1-I-O" class="headerlink" title="1.I/O"></a>1.I/O</h1><p>因为库文件的良好封装，我们在开发中可能不会直接使用IO读写，不过程序底层还是离不开IO。这里就来简单介绍下IO吧。<br>全称：Input/Output，顾名思义就是输入和输出。<br>场景：涉及到数据交换的地方，通常是磁盘读写、网络数据传输等。<br>磁盘读写场景：我们记录服务器的日志，最终都要写入文件中保存。如果我们想要分析这些日志，也需要重新从磁盘中读取这些文件。<br>网络传输场景：在浏览器中输入google.com这个地址，会向google的服务器发送一个请求，google服务器处理后传回google的首页，浏览器会把其中数据解析出来显示给用户。</p>
<h1 id="2-挑战"><a href="#2-挑战" class="headerlink" title="2.挑战"></a>2.挑战</h1><p>I/O读写的核心逻辑很简单，主要是传输数据。但是在实际IO中还有一些挑战，就是我们需要花很多时间去等待IO传输。例如，我们浏览一个网页，需要花1s才能将服务端数据传到浏览器中，在浏览器中渲染和显示只需要0.01s。如果不做其他处理，从点击地址后一直等待页面显示，那就非常浪费时间。</p>
<p>出现这个现象的原因是：CPU和内存的速度远远高于外设传输数据的速度。<br>短期内这个矛盾没有办法从根源上来解决，但是聪明的程序员想出很多策略去优化I/O场景。</p>
<h1 id="3-同步IO"><a href="#3-同步IO" class="headerlink" title="3.同步IO"></a>3.同步IO</h1><h5 id="3-1-原始场景"><a href="#3-1-原始场景" class="headerlink" title="3.1.原始场景"></a>3.1.原始场景</h5><p>这是最原始的场景：我们只运行一个线程，服务端接收到浏览器请求后，等待IO读取结束再进行操作，中间无法处理任何响应。这样的体验一定是非常糟糕的，因为整个服务器无法处理其他请求。在刚才的例子中，点击网页后1s内都无法响应其他任何请求，这会让用户非常沮丧。</p>
<h5 id="3-2-多线程"><a href="#3-2-多线程" class="headerlink" title="3.2.多线程"></a>3.2.多线程</h5><p>我们再稍微改善下，我们点击一个网页后，服务端新开一个线程去处理IO和其他操作。这时服务端还可以有其他线程去处理其他请求，这比原来好很多。<br><img src="/2018/07/02/20180702-learn-io/20180702_01.png"></p>
<h5 id="3-3-昂贵的线程"><a href="#3-3-昂贵的线程" class="headerlink" title="3.3.昂贵的线程"></a>3.3.昂贵的线程</h5><p>但是线程是一种非常昂贵的资源，有以下四个原因：<br>1.每个空线程就占512k~1M的内存，如果线程增加太多JVM压力会变大；<br>2.在Linux中线程就是进程，无论是新建和销毁都要调用重量级系统函数，非常占用CPU；<br>3.线程切换时，需要更新线程的上下文，原先线程缓存的指令和数据都需要重新加载。这会影响整个程序的运行效率，就像我们看英文文献时发现陌生单词后，打开字典去查，查询完毕后再继续阅读。需要重新回想之前前后文，影响阅读效率；<br>4.有可能会有大量请求同时返回，CPU占有率变得锯齿状，服务器不稳定。</p>
<h5 id="3-4-线程池"><a href="#3-4-线程池" class="headerlink" title="3.4.线程池"></a>3.4.线程池</h5><p>了解到线程的昂贵开销后，我们考虑接入线程池，可以重复利用原有线程。例如实时性要求不高的情况下，服务端同时有100个请求，线程池有20个线程，用着20个线程反复利用处理请求。这样只需要创建和销毁20个线程。而不用线程池的情况下，需要创建和销毁100个线程。这样大大降低的线程的开销，但是还是不能根治问题。因为始终需要线程去解决问题，我们需要换一种新的策略去解决问题。</p>
<h1 id="4-异步IO"><a href="#4-异步IO" class="headerlink" title="4.异步IO"></a>4.异步IO</h1><p>异步IO，Asynchronous Input and Output，简称AIO<br>异步IO从新的角度解决问题，用户只发出IO请求，并不等待IO结果，然后就去执行其他代码了。一段时间后，当IO返回结果后，再通知用户进行处理。<br>举个例子，服务器接受到一个浏览器的请求，发送读取其请求的IO请求，但是并不等待IO结果，而是去处理其他操作。当IO请求返回结果后，服务端再去处理这段IO。</p>
<p>这样操作的好处非常明显：用户不需要新开线程去处理IO。而且用户不用维护数据读不齐时的逻辑，因为操作系统将处理好的数据交给用户。<br>按照上面说的种种好处，大家肯定会觉得现在主流处理的IO肯定是AIO。但是其实不然，因为一个很现实的原因，纯正支持AIO的操作系统比较少。</p>
<h1 id="5-各种IO对比"><a href="#5-各种IO对比" class="headerlink" title="5.各种IO对比"></a>5.各种IO对比</h1><img src="/2018/07/02/20180702-learn-io/20180702_02.png">
<p>上面是一张特别经典的IO对比图，上面将各种IO都列出来了。我们一个个分析：</p>
<h5 id="5-1-阻塞IO"><a href="#5-1-阻塞IO" class="headerlink" title="5.1.阻塞IO"></a>5.1.阻塞IO</h5><p>阻塞IO就是上面所说的同步IO，这里不继续讨论。<br>举个例子，我在奶茶店点了一杯奶茶，点好后就一直在柜台等着，直到奶茶做好。</p>
<h5 id="5-2-非阻塞IO"><a href="#5-2-非阻塞IO" class="headerlink" title="5.2.非阻塞IO"></a>5.2.非阻塞IO</h5><p>非阻塞IO与阻塞IO不同，发起IO请求后，不需要一直等待，在拿到IO数据之前还可以做一些别的操作。那怎么知道何时能拿到IO数据呢？一般会采用轮询的方法。<br>轮询就是每隔一段时间去检查是否IO进入可读状态，如果发现数据不可读则立即返回不会阻塞。但是轮询浪费CPU资源，因为大部分时间是无数据可读，但是仍会不间断的反复地去查询。<br>举个例子，我在奶茶店点了一杯奶茶，没有选择一直等着，而是选择去边上的商店逛逛，每隔一分钟回奶茶店看看奶茶是否完成。但是这仍然会浪费你的时间，因为可能有多次查询的结果都是奶茶没完成。</p>
<h5 id="5-3-IO复用"><a href="#5-3-IO复用" class="headerlink" title="5.3.IO复用"></a>5.3.IO复用</h5><p>IO复用是基于非阻塞IO的，可以理解成多个IO请求委托给一个对象，让它去统一检查IO是否进入可读状态。这会带来效率的提升，因为不需要所有对象都去轮询。<br>把例子展开下，一个班级中每个同学都在奶茶店点了一杯奶茶，全权委托班长去轮询奶茶是否已经做好。每一杯奶茶做好了，班长就去通知对应的同学。</p>
<h5 id="5-4-信号驱动IO"><a href="#5-4-信号驱动IO" class="headerlink" title="5.4.信号驱动IO"></a>5.4.信号驱动IO</h5><p>信号驱动IO就比较好理解。IO进入可读状态后，系统直接通知用户。<br>对应的例子是，我在奶茶店点了一杯奶茶，而且给店员留了手机号码。然后我就去边上商店逛逛，店员在制作完奶茶后会打电话通知我。不用每隔一段时间再去查看（轮询），也不需要委托给其他人让他去查看（IO复用），非常开心。</p>
<h5 id="5-5-异步IO"><a href="#5-5-异步IO" class="headerlink" title="5.5.异步IO"></a>5.5.异步IO</h5><p>异步IO和信号驱动IO模式比较接近，但是告知的时间点不同。信号驱动IO在操作系统内核读取完数据后告知用户，用户接到通知后还需要从内核中读取到用户空间，之后才可以使用IO传输过的数据。而异步IO中，操作系统已经把上面的两步全部做完，放到用户空间后再告知用户，用户可以直接使用IO传输过的数据。<br>这两个IO的对比再举个例子，我们在网上点了一台冰箱，有以下两个不同的场景。<br>信号驱动IO：快递员送到小区门口，然后快递员给我们打电话（内核空间中数据读取完成，进入可读状态），我们还需要从小区门口搬到房间（将数据从内核空间中读取到用户空间），然后再安装冰箱（使用IO的接收到的数据）。<br>异步IO：快递员直接将冰箱送到家，这里包含了仓库到小区门口和小区门口到房间两步（包括读取到内核空间，内核空间到用户空间），送到房间门口时再通知我，我直接可以安装冰箱。</p>
<h1 id="6-NIO"><a href="#6-NIO" class="headerlink" title="6.NIO"></a>6.NIO</h1><p>NIO全称为Non-blocking I/O（在Java领域，也称为New I/O）<br>与上面所说的IO复用模式相同，其中一个重要的角色就是监控管理IO是否可读的对象，在NIO中这个对象是Selector。Selector有一个重要方法select，select维护一张监听套接字的列表（使用前需要注册Selector上），一直阻塞直到其中有一个套接字有数据可供读写。</p>
<img src="/2018/07/02/20180702-learn-io/20180702_03.png">
<p>上图中一个Selector管理着多个Channel，一个Channel代表一个IO通道。</p>
<p>我们用一个交通管理系统去类比下NIO中的主要对象：<br>Channel：车辆<br>Selector：调度系统<br>Buffer：车辆上的货物<br>Stream：货物</p>
<p>我们再看下主干代码，注意其中的注释：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.Channel注册到Selector中</span></span><br><span class="line">channel.register(selector, opType);</span><br><span class="line"><span class="comment">// 2.Selector阻塞等待Channel变化</span></span><br><span class="line">Set selectedKeys = selector.selectedKeys();</span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey <span class="built_in">key</span> = keyIterator.next();</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">    <span class="comment">// 3.按照类型做对应操作</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">key</span>.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// 注册新的Channel到Selector中</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">key</span>.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// 读操作</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">key</span>.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// 写操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/22/20180622-multithreading-n-questions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="corresponding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corresponding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/22/20180622-multithreading-n-questions/" itemprop="url">多线程基础小问</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-22T19:07:00+08:00">
                2018-06-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <img src="/2018/06/22/20180622-multithreading-n-questions/0622_00.jpg">
<p>对于多线程我自认为有所了解，但是到探究其中细节还是会一脸懵逼。<br>在经过一段时间系统学习后，回头去看多线程的基础知识，发现之前有很多地方理解错误。<br>这里提出多线程的几个小问题，希望能抛砖引玉，让大家借此有更加深入的思考。</p>
<h1 id="1-wait和sleep的差异？"><a href="#1-wait和sleep的差异？" class="headerlink" title="1.wait和sleep的差异？"></a>1.wait和sleep的差异？</h1><p>这个问题看上去很简单，大家都能说出一二三来。<br>a.wait是Object的方法；sleep是Thread方法。<br>b.wait只能在同步代码中调用。<br>c.wait会释放出锁；sleep不会释放出锁。</p>
<p>这次我们就展开深入下：</p>
<h2 id="1-a-为什么要设置wait是Object的方法；sleep是Thread方法？"><a href="#1-a-为什么要设置wait是Object的方法；sleep是Thread方法？" class="headerlink" title="1.a.为什么要设置wait是Object的方法；sleep是Thread方法？"></a>1.a.为什么要设置wait是Object的方法；sleep是Thread方法？</h2><p>个人理解是这样的，java语言的创造者在设计时考虑这两个函数的使用场景。<br>在运行一个线程中，我们只需要对Thread这个对象使用sleep函数（用来休眠线程），但是我们可能会用多个对象进行锁管理（即在一个线程中使用多个锁）。<br>如果把wait设置成Thread方法，那么在一个线程中只能用Thread对象的wait和notify，非常有局限性（相当于一个线程中只能使用一个锁）。</p>
<p>例如下面这样的场景，银行给用户开金卡需要两个条件：存款10000，今年消费次数超过5次。我们在这两个条件未达到的时候，分别使用wait()，等待对应notify。<br>如果wait是Thread方法的话，就不能实现这样的需求。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">synchronized</span> (notEnoughDeposit) &#123;</span><br><span class="line">    <span class="selector-tag">while</span>(deposit &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">        <span class="selector-tag">notEnoughDeposit</span><span class="selector-class">.wait</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">synchronized</span> (notEnoughConsumeCount) &#123;</span><br><span class="line">        <span class="selector-tag">while</span>(consumeCount &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="selector-tag">notEnoughConsumeCount</span><span class="selector-class">.wait</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 办理金卡</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>sleep只能在Thread中使用，不需要考虑多个对象嵌套的调用。同时结合“最小职责”的设计原则，sleep()就设置成Thread的方法。</p>
<h2 id="1-b-为什么wait只能在同步代码中调用？"><a href="#1-b-为什么wait只能在同步代码中调用？" class="headerlink" title="1.b.为什么wait只能在同步代码中调用？"></a>1.b.为什么wait只能在同步代码中调用？</h2><p>我们看下wait使用的具体场景，下面代码是没有加入同步块：<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(deposit &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">    notEnoughDeposit.<span class="built_in">wait</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(consumeCount &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    notEnoughConsumeCount.<span class="built_in">wait</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 办理金卡</span></span><br></pre></td></tr></table></figure></p>
<p>这里就会存在一个问题，如果没有在wait()外围加入同步块，在办理金卡的时候deposit可能会变化。用户在中间的时间空隙（条件判断和真正办卡中间）中可能再去消费，导致卡中余额小于10000，不符合金卡办理条件。<br>在java规范中，如果wait和notify外围没有同步块，会抛出ILLegalMonitorStateException。<br>所以java程序设计总是需要保证 notify 和 wait 操作的原子性，这也就是为什么wait只能在同步代码中调用的原因。</p>
<h2 id="1-c-怎么理解wait会释放出锁；sleep不会释放出锁？"><a href="#1-c-怎么理解wait会释放出锁；sleep不会释放出锁？" class="headerlink" title="1.c.怎么理解wait会释放出锁；sleep不会释放出锁？"></a>1.c.怎么理解wait会释放出锁；sleep不会释放出锁？</h2><p>wait调用后，会释放出锁。如果当前其他线程正在阻塞状态的话会被唤醒，唤醒后其他线程就继续操作。<br>sleep就相当于当前线程休眠一段时间，不会释放出锁，其他阻塞的线程自然也获取不到锁。这里特别要注意的是，sleep并不代表会一直占用系统CPU。因为操作系统底层也有对应的优化机制，检查到当前线程sleep，会转而执行那些非阻塞的线程。</p>
<h1 id="2-锁的机制？"><a href="#2-锁的机制？" class="headerlink" title="2.锁的机制？"></a>2.锁的机制？</h1><p>我们先来看下这张图，再理清其中的概念：</p>
<img src="/2018/06/22/20180622-multithreading-n-questions/0622_01.png">
<h2 id="什么是锁？"><a href="#什么是锁？" class="headerlink" title="什么是锁？"></a>什么是锁？</h2><p>锁是对象内存堆头部的一部分数据。</p>
<h2 id="什么是监视器（monitor）？"><a href="#什么是监视器（monitor）？" class="headerlink" title="什么是监视器（monitor）？"></a>什么是监视器（monitor）？</h2><p>监视器是一种虚拟的概念，一个锁只能被一个线程持有，其他线程阻塞等待。获得这个锁的线程处于监视器中。</p>
<h2 id="什么是等待池（wait-set）？"><a href="#什么是等待池（wait-set）？" class="headerlink" title="什么是等待池（wait set）？"></a>什么是等待池（wait set）？</h2><p>调用了某个对象的wait()方法，线程就会释放该对象的锁后，进入到了该对象的等待池中。</p>
<h2 id="什么是阻塞队列（entry-set）？"><a href="#什么是阻塞队列（entry-set）？" class="headerlink" title="什么是阻塞队列（entry set）？"></a>什么是阻塞队列（entry set）？</h2><p>线程获取锁失败后，进入到阻塞队列。当持有锁的线程释放锁后，阻塞队列中一个线程会获取该锁，然后进入监视器。</p>
<p>明白这些概念后，我们再看一张图，这里面表示锁操作的关键流程</p>
<img src="/2018/06/22/20180622-multithreading-n-questions/0622_02.png">
<p>下面是每一步对应的操作（注：下面第x步不是顺序执行）<br>第1步：线程A尝试获取object锁，获取锁成功，进入Monitor成功<br>第2步：线程A持有锁，线程B尝试获取object锁，获取锁失败，进入Monitor失败<br>第3步：线程A持有锁，完成操作释放object锁，线程B离开阻塞队列，尝试获取object锁<br>第4步：线程A持有锁，在运行过程中调用wait，释放object锁，同时进入等待池<br>第5步：线程B持有锁，在运行过程中调动notify或者notifyAll，会触发第6步操作，等待线程其他操作完毕，才释放object锁<br>第6步：线程A之前调用wait，处于等待池中，在接受notify或者notifyAll后，会进入阻塞队列，在之后进行第3步操作</p>
<p>以上就是常见的锁操作，包括获取锁、释放锁、wait、notify。</p>
<h1 id="3-notify和notifyAll的差异？"><a href="#3-notify和notifyAll的差异？" class="headerlink" title="3.notify和notifyAll的差异？"></a>3.notify和notifyAll的差异？</h1><p>从字面上理解，notify就是随机唤醒一个wait的线程，notifyAll唤醒所有wait的线程。</p>
<h2 id="那么继续问下去，两者是否可以调换使用？"><a href="#那么继续问下去，两者是否可以调换使用？" class="headerlink" title="那么继续问下去，两者是否可以调换使用？"></a>那么继续问下去，两者是否可以调换使用？</h2><p>我们先来看下面的代码：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span><span class="comment">(!condition)</span> &#123;</span><br><span class="line"> obj.wait<span class="comment">()</span>; </span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="comment">(!condition)</span> &#123;</span><br><span class="line"> obj.wait<span class="comment">()</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有两种写法在一种情况下有差别，就是一个线程被错误的唤醒后，if代码块会继续执行下去，但是后续执行都是错误的。而while代码块会再次验证条件是否满足，发现没有满足条件的话，选择再次wait。</p>
<p>这个有个建议：永远在while循环里而不是if语句下使用wait。<br>这样，循环会在线程睡眠前后都检查wait的条件，并在条件实际上并未改变的情况下处理唤醒通知。</p>
<h2 id="假死的情况"><a href="#假死的情况" class="headerlink" title="假死的情况"></a>假死的情况</h2><p>在while的基础上，如果使用notify错误的唤醒了一个wait的线程。它在接下去的while判断中，发现仍旧没有达到条件，这个线程重新选择wait。同时其他线程没有被唤醒，这就会导致所有线程一直假死在那边。<br>而使用notifyAll则不会出现这种情况，因为所有wait的线程都会被唤醒，总有一个线程能重新通过条件判断（这一点要开发者自己保障），程序会继续运行下去。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/06/20180206-stack-become-queue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="corresponding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corresponding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/06/20180206-stack-become-queue/" itemprop="url">用 6 个栈实现一个 O(1) 队列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-06T15:35:51+08:00">
                2018-02-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.cnblogs.com/ikesnowy/p/7157813.html" target="_blank" rel="noopener">原文链接 转载已授权</a> </p>
<p>《算法（第四版）》中的题目是这样的：<br>用有限个栈实现一个队列，<br>保证每个队列操作（在最坏情况下）都只需要常数次的栈操作。</p>
<p>那么这里就使用六个栈来解决这个问题。</p>
<p>这个算法来自于这篇<a href="https://ecommons.cornell.edu/bitstream/handle/1813/6273/80-433.pdf?sequence=1&amp;isAllowed=y" target="_blank" rel="noopener">论文</a><br>原文里用的是 Pure Lisp，不过语法很简单，还是很容易看懂的。</p>
<h1 id="先导知识——用两个栈模拟一个队列"><a href="#先导知识——用两个栈模拟一个队列" class="headerlink" title="先导知识——用两个栈模拟一个队列"></a>先导知识——用两个栈模拟一个队列</h1><p>如何使用两个栈来模拟一个队列操作？<br>这是一道很经典的题目，答案也有很多种，这里只介绍之后会用到的一种方法。<br>首先我们有两个栈，H 和 T，分别用作出队和入队用。<br><img src="/2018/02/06/20180206-stack-become-queue/0206_01.png"></p>
<p>这样，入队操作等同于向 T 添加元素，T 的入栈操作只需要 O(1) 时间。<br><img src="/2018/02/06/20180206-stack-become-queue/0206_02.png"></p>
<p>如果 H 不为空，出队操作等同于 H 弹栈，H 的弹栈操作也只需要 O(1) 时间。<br><img src="/2018/02/06/20180206-stack-become-queue/0206_03.png"></p>
<p>但如果 H 为空，则需要将 T 中的元素依次弹出并压入到 H 中，这是一个 O(n) 的操作。<br><img src="/2018/02/06/20180206-stack-become-queue/0206_04.png"></p>
<p>显然，这种方式中，出队操作的最坏时间复杂度是 O(n)，并不满足题目要求。</p>
<h1 id="分摊-O-n"><a href="#分摊-O-n" class="headerlink" title="分摊 O(n)"></a>分摊 O(n)</h1><p>那么，怎么解决这个问题呢？</p>
<p>一个很自然的想法是，如果在栈 H 变为空之前，我们就能逐步将栈 T 的内容弹出并压入到另一个栈 H’ 中，等到栈 H 为空时，直接交换 H 和 H’ 即可。<br>假设目前的队列状态是这样，有三个元素等待出队，还有三个元素等待入队。<br><img src="/2018/02/06/20180206-stack-become-queue/0206_05.png"></p>
<p>现在依次让三个元素出队，与此同时我们让栈 T 中的元素依次进入 H’ 中。<br>每一次出队都执行两个操作，元素出队和元素复制（Pop &amp; Push），时间复杂度 O(1) + O(1) + O(1) = O(1)。</p>
<p>第一次操作（出队）<br><img src="/2018/02/06/20180206-stack-become-queue/0206_06.png"></p>
<p>第二次操作（出队）<br><img src="/2018/02/06/20180206-stack-become-queue/0206_07.png"></p>
<p>第三次操作（出队）<br><img src="/2018/02/06/20180206-stack-become-queue/0206_08.png"></p>
<p>现在栈 H 和栈 T 都为空，下一次出队操作时，我们直接交换栈 H 和栈 H’（由于是交换引用，因此时间复杂度仍为 O(1)）。<br><img src="/2018/02/06/20180206-stack-become-queue/0206_09.png"></p>
<p>之后再进行出队操作。</p>
<p>这就是这个算法基本想法，在栈 H 变为空之前，分步将栈 T 中的内容分步复制到另一个栈中。<br>当栈 H 为空时直接用准备好的栈 H’ 替代 H，保证时间复杂度为常数。</p>
<h1 id="对复制时-Enqueue-的支持和-T’-的引入"><a href="#对复制时-Enqueue-的支持和-T’-的引入" class="headerlink" title="对复制时 Enqueue 的支持和 T’ 的引入"></a>对复制时 Enqueue 的支持和 T’ 的引入</h1><p>刚才是一种理想情况，显然我们的队列在复制时不可能只发生出队操作，为了增加对入队操作的支持，我们引入临时栈 T’。</p>
<p>例如我们有队列状态如下，现在启动复制进程，入队操作全部由 T’ 完成。<br><img src="/2018/02/06/20180206-stack-become-queue/0206_10.png"></p>
<p>我们进行一次入队操作和两次出队操作，如下组图所示：</p>
<p>第一次操作（入队）<br><img src="/2018/02/06/20180206-stack-become-queue/0206_11.png"></p>
<p>第二次操作（出队）<br><img src="/2018/02/06/20180206-stack-become-queue/0206_12.png"></p>
<p>第三次操作（出队）<br><img src="/2018/02/06/20180206-stack-become-queue/0206_13.png"></p>
<p>现在 H 和 T 均为空，下一次操作时（不论入队还是出队），我们先交换 H 和 H’ 以及 T 和 T’，同时让入队操作控制权回到 T。<br><img src="/2018/02/06/20180206-stack-become-queue/0206_14.png"></p>
<p>这样，我们增加了对复制时入队操作的支持，但还并不完全，只有在理想情况下才可以做到。</p>
<h1 id="h-与-HR-，对复制时出入队序列支持的扩展"><a href="#h-与-HR-，对复制时出入队序列支持的扩展" class="headerlink" title="h 与 HR ，对复制时出入队序列支持的扩展"></a>h 与 HR ，对复制时出入队序列支持的扩展</h1><p>在之前的例子中，当复制结束时 H 总是为空的，现在我们来讨论一下复制结束时 H 不为空的情况。<br>如果复制结束时 H 不为空，直接交换的结果是我们丢失了原来栈 H 中的数据。<br>因此，在翻转 T 的同时，我们还应翻转 H 到 HR，并在最后将 HR 的内容再度翻转并添加到 H’ 上。</p>
<p>这个过程可以以下图方式进行：</p>
<p>初始状态：<br><img src="/2018/02/06/20180206-stack-become-queue/0206_15.png"></p>
<p>第一次操作（入队），H-&gt;HR ,T-&gt;H’，时间复杂度 O(1) + O(1) + O(1) + O(1) + O(1) = O(1)。<br><img src="/2018/02/06/20180206-stack-become-queue/0206_16.png"></p>
<p>第二次操作（入队）<br><img src="/2018/02/06/20180206-stack-become-queue/0206_17.png"></p>
<p>第三次操作（入队）<br><img src="/2018/02/06/20180206-stack-become-queue/0206_18.png"></p>
<p>第四次操作（入队）<br><img src="/2018/02/06/20180206-stack-become-queue/0206_19.png"></p>
<p>第五次操作（入队）<br><img src="/2018/02/06/20180206-stack-become-queue/0206_20.png"></p>
<p>第六次操作（出/入队执行前）<br><img src="/2018/02/06/20180206-stack-become-queue/0206_21.png"></p>
<p>这样我们就解决了 H 复制结束后不为空的问题，代价是引入了两个额外的问题：</p>
<p>操作次数增加到了 2k 次，k 代表栈 T 中的元素数量。（如果当 T 中元素数量大于 H 中元素数量时开始复制）<br>由于 H 被用于复制进程，我们无法在复制过程中支持出队操作。第一个问题解决方案比较简单，我们可以在每一次出/入队操作执行时进行两次的复制步骤（对 T 和 H 进行两次的 Pop 操作），时间复杂度仍为 O(1)。</p>
<p>第二个问题我们通过引入栈 h 来解决。<br>h 用于在复制时代替 H 执行出队功能，它会在复制开始时自动变为栈 H 的一个浅拷贝（也就是说，h 和 H 共用同一片内存空间，但它们用于指示栈顶位置的指针相互独立）。</p>
<p>现在我们有了全部 6 个栈，它们的功能如下图所示（为了方便介绍我将一些栈的位置做了调换）。<br><img src="/2018/02/06/20180206-stack-become-queue/0206_22.png"></p>
<p>由于我们并不能预知接下来会发生的操作，因此当 H 栈中的元素数量第一次小于 T 栈中的元素数量时，我们就必须启动复制进程了（总是假设接下来全部都是出队操作）。我们引入一个布尔类型变量 IsCopying 来指示复制进程。<br><img src="/2018/02/06/20180206-stack-become-queue/0206_23.png"></p>
<p>现在我们进行第一次入队操作，IsCopying = true，开始复制。<br>首先 h 变为 H 的浅拷贝，这个过程是 O(1) 的。<br><img src="/2018/02/06/20180206-stack-become-queue/0206_24.png"></p>
<p>如果在复制过程中有出队操作，作为 H 的翻转 HR 中就有一个元素不再需要复制，我们引入一个变量 needcopy 来记录 HR 中需要复制的元素数量。<br><img src="/2018/02/06/20180206-stack-become-queue/0206_25.png"></p>
<p>接下来是两次复制操作，T 和 H 分别有两个元素进入了 H’ 和 HR 。<br><img src="/2018/02/06/20180206-stack-become-queue/0206_26.png"></p>
<p>然后是第二次出/入队操作，这次我们选择出队，1 出队后显然 HR 中的 1 不再需要复制，needcopy – 1。<br><img src="/2018/02/06/20180206-stack-become-queue/0206_27.png"></p>
<p>随后再是两次复制操作，第一次将 H 中的 3 移到 HR 中，needcopy + 1，T 中的 5 移到 H’ 中；第二次只将 T 中的 4 移到 H’ 中。<br><img src="/2018/02/06/20180206-stack-become-queue/0206_28.png"></p>
<p>第三次出/入队操作我们选择入队，8 入队。随后 HR 中的两个元素进入了 H’，needcopy – 2。<br><img src="/2018/02/06/20180206-stack-become-queue/0206_29.png"></p>
<p>由于 needcopy 变成了 0，我们再额外进行一次交换操作，并将 IsCopying 置为 false。<br><img src="/2018/02/06/20180206-stack-become-queue/0206_30.png"><br>至此，完整的算法运行完毕。</p>
<h1 id="有关复制开始时机的证明"><a href="#有关复制开始时机的证明" class="headerlink" title="有关复制开始时机的证明"></a>有关复制开始时机的证明</h1><p>这里我们选择了在第 k + 1 个元素入队时开始复制，现在证明一定能够在 h 空之前完成复制：</p>
<p>假设复制开始时 H 有 k 个元素，T 有 k + 1个元素。<br>完成第一轮复制（H-&gt;HR , T-&gt;H’）需要 k + 1 次操作，<br>完成第二轮复制（H-&gt;H’）需要 k 次操作，总共需要 2k + 1 次操作才能完成复制。<br>而 h 的长度为 k，能够提供 2k 次的操作机会。第 k + 1 个元素入队时也能提供 2 次操作机会，因此一共是 2k + 2 次操作机会。</p>
<p>由于 2k + 1 &lt; 2k + 2，我们证明了该算法能够及时完成复制工作。</p>
<h1 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h1><p>根据之前的内容，我们可以开始设计程序了。主要实现三个功能，Enqueue(), Dequeue() 和 Peek()。</p>
<p>根据算法要求我们添加一个进行复制时操作的函数 OneStep()，用于执行元素的复制，栈交换等操作。</p>
<p>Peek() 只需要根据是否在进行复制选择栈 h 或栈 H 进行 Peek()。</p>
<h2 id="Enqueue"><a href="#Enqueue" class="headerlink" title="Enqueue()"></a>Enqueue()</h2><p>如果不处于复制状态<br>如果 H.Length – T.Length &gt; 0，直接将元素压入栈 T。<br>否则令 IsCopying = true，h 进行浅拷贝，进行两次的 OneStep。<br>如果处于复制状态，将元素压入 T’，进行两次的 OneStep。</p>
<h2 id="Dequeue"><a href="#Dequeue" class="headerlink" title="Dequeue()"></a>Dequeue()</h2><p>如果不处于复制状态<br>如果 H.Length – T.Length &gt; 0，直接从 H 弹出元素。<br>否则从 H 弹出元素，IsCopying = true，h 进行浅拷贝，进行两次的 OneStep。<br>如果处于复制状态，从 h 弹出元素，needcopy - 1，进行两次的 OneStep。</p>
<h2 id="OneStep"><a href="#OneStep" class="headerlink" title="OneStep()"></a>OneStep()</h2><p>如果不处于复制状态，什么也不做。<br>如果处于复制状态。<br>如果 H 和 T 都不为空，从 H 搬运一个元素至 HR ，从 T 搬运一个元素至 H’ ，needcopy + 1。<br>如果 H 为空但 T 不为空，从 T 搬运一个元素至 H’ 。<br>如果 H 和 T 都为空，但 needcopy &gt; 1，从 HR 搬运一个元素至 H’ ，needcopy – 1。<br>如果 H 和 T 都为空，但 needcopy = 1，从 HR 搬运一个元素至 H’ ，needcopy – 1，交换 H 和 H’ 以及 T 和 T’，其他栈置空，退出复制状态。<br>如果 H 和 T 都为空，但 needcopy = 0，交换 H 和 H’ 以及 T 和 T’，其他栈置空，退出复制状态。</p>
<h1 id="程序实现（C-）"><a href="#程序实现（C-）" class="headerlink" title="程序实现（C#）"></a>程序实现（C#）</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">using Generics;</span><br><span class="line"></span><br><span class="line">namespace _1._3._49</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">StackQueue</span>&lt;<span class="type">Item</span>&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        Stack&lt;Item&gt; H;</span><br><span class="line">        Stack&lt;Item&gt; T;</span><br><span class="line">        Stack&lt;Item&gt; h;</span><br><span class="line">        Stack&lt;Item&gt; HH;</span><br><span class="line">        Stack&lt;Item&gt; TT;</span><br><span class="line">        Stack&lt;Item&gt; Hr;</span><br><span class="line"></span><br><span class="line">        bool isRecopying;</span><br><span class="line">        int nowcopying;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StackQueue()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.isRecopying = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.nowcopying = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.H = new Stack&lt;Item&gt;();</span><br><span class="line">            <span class="keyword">this</span>.T = new Stack&lt;Item&gt;();</span><br><span class="line">            <span class="keyword">this</span>.h = new Stack&lt;Item&gt;();</span><br><span class="line">            <span class="keyword">this</span>.HH = new Stack&lt;Item&gt;();</span><br><span class="line">            <span class="keyword">this</span>.TT = new Stack&lt;Item&gt;();</span><br><span class="line">            <span class="keyword">this</span>.Hr = new Stack&lt;Item&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Item Peek()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isRecopying)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> h.Peek();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> H.Peek();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> void Enqueue(Item item)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.isRecopying &amp;&amp; Lendiff() &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.nowcopying = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">this</span>.T.Push(item);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.isRecopying &amp;&amp; Lendiff() == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.T.Push(item);</span><br><span class="line">                <span class="keyword">this</span>.isRecopying = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">this</span>.h = <span class="keyword">this</span>.H.Copy();</span><br><span class="line">                OneStep(OneStep(<span class="keyword">this</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.isRecopying)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.TT.Push(item);</span><br><span class="line">                OneStep(OneStep(<span class="keyword">this</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> int Lendiff()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.H.Size() - <span class="keyword">this</span>.T.Size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Item Dequeue()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.isRecopying &amp;&amp; Lendiff() &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.H.Pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.isRecopying &amp;&amp; Lendiff() == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Item temp = <span class="keyword">this</span>.H.Pop();</span><br><span class="line">                <span class="keyword">this</span>.h = <span class="keyword">this</span>.H.Copy();</span><br><span class="line">                <span class="keyword">this</span>.isRecopying = <span class="literal">true</span>;</span><br><span class="line">                OneStep(OneStep(<span class="keyword">this</span>));</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Item temp = <span class="keyword">this</span>.h.Pop();</span><br><span class="line">                <span class="keyword">this</span>.nowcopying--;</span><br><span class="line">                OneStep(OneStep(<span class="keyword">this</span>));</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> static StackQueue&lt;Item&gt; OneStep(StackQueue&lt;Item&gt; q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.isRecopying &amp;&amp; !q.H.IsEmpty() &amp;&amp; !q.T.IsEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                q.nowcopying++;</span><br><span class="line">                q.HH.Push(q.T.Pop());</span><br><span class="line">                q.Hr.Push(q.H.Pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q.isRecopying &amp;&amp; q.H.IsEmpty() &amp;&amp; !q.T.IsEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                q.isRecopying = <span class="literal">true</span>;</span><br><span class="line">                q.HH.Push(q.T.Pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q.isRecopying &amp;&amp; q.H.IsEmpty() &amp;&amp; q.T.IsEmpty() &amp;&amp; q.nowcopying &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.isRecopying = <span class="literal">true</span>;</span><br><span class="line">                q.nowcopying--;</span><br><span class="line">                q.HH.Push(q.Hr.Pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q.isRecopying &amp;&amp; q.H.IsEmpty() &amp;&amp; q.T.IsEmpty() &amp;&amp; q.nowcopying == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.isRecopying = <span class="literal">false</span>;</span><br><span class="line">                q.nowcopying--;</span><br><span class="line">                q.HH.Push(q.Hr.Pop());</span><br><span class="line">                q.H = q.HH;</span><br><span class="line">                q.T = q.TT;</span><br><span class="line">                q.HH = new Stack&lt;Item&gt;();</span><br><span class="line">                q.TT = new Stack&lt;Item&gt;();</span><br><span class="line">                q.Hr = new Stack&lt;Item&gt;();</span><br><span class="line">                q.h = new Stack&lt;Item&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q.isRecopying &amp;&amp; q.H.IsEmpty() &amp;&amp; q.T.IsEmpty() &amp;&amp; q.nowcopying == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.isRecopying = <span class="literal">false</span>;</span><br><span class="line">                q.H = q.HH;</span><br><span class="line">                q.T = q.TT;</span><br><span class="line">                q.HH = new Stack&lt;Item&gt;();</span><br><span class="line">                q.TT = new Stack&lt;Item&gt;();</span><br><span class="line">                q.Hr = new Stack&lt;Item&gt;();</span><br><span class="line">                q.h = new Stack&lt;Item&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/10/20180110-Double-Stuffed-Security-in-Android-Oreo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="corresponding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corresponding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/10/20180110-Double-Stuffed-Security-in-Android-Oreo/" itemprop="url">像奥利奥一样的双重安全措施，尽在 Android Oreo</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-10T19:26:48+08:00">
                2018-01-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/译文/" itemprop="url" rel="index">
                    <span itemprop="name">译文</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <img src="/2018/01/10/20180110-Double-Stuffed-Security-in-Android-Oreo/0.jpg">
<blockquote>
<ul>
<li>原文地址：<a href="https://android-developers.googleblog.com/2017/12/double-stuffed-security-in-android-oreo.html" target="_blank" rel="noopener">Double Stuffed Security in Android Oreo</a></li>
<li>原文作者：<a href="https://android-developers.googleblog.com/2017/12/double-stuffed-security-in-android-oreo.html" target="_blank" rel="noopener">Gian G Spicuzza</a></li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li>
<li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO/double-stuffed-security-in-android-oreo.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO/double-stuffed-security-in-android-oreo.md</a></li>
<li>译者：<a href="https://github.com/XPGSnail" target="_blank" rel="noopener">一只胖蜗牛</a></li>
<li>校对者：<a href="https://github.com/corresponding" target="_blank" rel="noopener">corresponding</a>，<a href="https://github.com/SumiMakito" target="_blank" rel="noopener">SumiMakito</a></li>
</ul>
</blockquote>
<h1 id="像奥利奥一样的双重安全措施，尽在-Android-Oreo"><a href="#像奥利奥一样的双重安全措施，尽在-Android-Oreo" class="headerlink" title="像奥利奥一样的双重安全措施，尽在 Android Oreo"></a><a href="https://android-developers.googleblog.com/2017/12/double-stuffed-security-in-android-oreo.html" target="_blank" rel="noopener">像奥利奥一样的双重安全措施，尽在 Android Oreo</a></h1><p>由 Android 安全团队的 Gian G Spicuzza 发表</p>
<p>Android Oreo 中包含很多安全性提升的更新。几个月以来，我们讨论了如何增强 Android 平台及应用的安全性: 从<a href="https://android-developers.googleblog.com/2017/08/making-it-safer-to-get-apps-on-android-o.html" target="_blank" rel="noopener">提供更安全的获取应用渠道</a>，移除<a href="https://android-developers.googleblog.com/2017/04/android-o-to-drop-insecure-tls-version.html" target="_blank" rel="noopener">不安全的网络协议</a>，提供更多<a href="https://android-developers.googleblog.com/2017/04/changes-to-device-identifiers-in.html" target="_blank" rel="noopener">用户控制符</a>，<a href="https://android-developers.googleblog.com/2017/08/hardening-kernel-in-android-oreo.html" target="_blank" rel="noopener">加固内核</a>，<a href="https://android-developers.googleblog.com/2017/07/shut-hal-up.html" target="_blank" rel="noopener">使 Android 更易于更新</a>,直到<a href="https://android-developers.googleblog.com/2017/06/2017-android-security-rewards.html" target="_blank" rel="noopener">加倍 Android 安全奖励奖励项目的支出</a>。如今 Oreo 终于正式和大家见面了，让我们回顾下这其中的改进。  </p>
<h3 id="扩大硬件安全支持"><a href="#扩大硬件安全支持" class="headerlink" title="扩大硬件安全支持"></a>扩大硬件安全支持</h3><p>Android 早已支持<a href="https://source.android.com/security/verifiedboot/" target="_blank" rel="noopener">开机验证模式(Verified Boot)</a>，旨在防止设备软件被篡改的情况下启动。在 Android Oreo 中，我们随着<a href="https://source.android.com/devices/architecture/treble" target="_blank" rel="noopener"> Project Treble </a>一同运行的验证开机模式(Verified Boot)，称之为 Android 验证开机模式2.0(Android Verified Boot 2.0)(AVB)。AVB 有一些使得更新更加容易、安全的功能，例如通用的分区尾部（AVB 中位于文件系统分区尾部的结构）以及回滚保护。回滚保护旨在保护 OS 降级的设备，防止降级到到低版本的系统后被人攻击。为此，设备将通过专用的硬件保存系统版本信息或使用可信执行环境（Trusted Execution Environment, TEE）对数据进行签名。 Pixel 2 和 Pixel 2 XL 自带这种保护，并且我们建议所有设备制造商将这个功能添加到他们的新设备中。</p>
<p>Oreo 还包括新的<a href="https://android-review.googlesource.com/#/c/platform/hardware/interfaces/+/527086/-1..1/oemlock/1.0/IOemLock.hal" target="_blank" rel="noopener">原始设备制造商锁(OEM Lock)硬件抽象层(HAL)</a>使得设备制造商能够更加灵活的保护设备，无论设备处于锁定、解锁或者可解锁状态。例如，新的 Pixel 设备通过硬件抽象层命令向启动引导程序（bootloader）传递命令。启动引导装载程序会在下次开机分析这些命令并检查安全存储于有重放保护的内存区（Replay Protected Memory Block, RPMB）中对锁更改的信息是否合法。如果你的设备被偷了，这些保护措施旨在保护你的设备被重置，从而保护你的数据安全。新的硬件抽象层(HAL)甚至支持将锁移动到专用的硬件中。</p>
<p>谈到硬件，我们添加了防伪硬件支持，例如在每一个 Piexl 2 和 Piexl 2 XL 设备中内嵌的<a href="https://android-developers.googleblog.com/2017/11/how-pixel-2s-security-module-delivers.html" target="_blank" rel="noopener">安全模块</a>。这种物理芯片可以防止很多软硬件攻击，并且还抵抗物理渗透攻击. 安全模块防止推导设备密码及限制解锁尝试的频率，使得很多攻击由于时间限制而失效。</p>
<p>新的 Pixel 设备配有特殊的安全模块，所有搭载Android Oreo 的<a href="https://www.android.com/gms/" target="_blank" rel="noopener">谷歌移动服务(GMS)</a>的设备也需要实现<a href="https://android-developers.googleblog.com/2017/09/keystore-key-attestation.html" target="_blank" rel="noopener">密钥验证</a>。这提供了一种强<a href="https://source.android.com/security/keystore/attestation#id-attestation" target="_blank" rel="noopener">验证标识符</a>机制，例如硬件标识符。</p>
<p>我们也为企业管理设备添加了新的功能。当配置文件或者公司管理员远程锁定配置文件时，加密密钥会从内存（RAM）中移除.这有助于保护企业数据的安全。</p>
<h3 id="平台加固及进程隔离"><a href="#平台加固及进程隔离" class="headerlink" title="平台加固及进程隔离"></a>平台加固及进程隔离</h3><p>作为<a href="https://android-developers.googleblog.com/2017/05/here-comes-treble-modular-base-for.html" target="_blank" rel="noopener"> Project Treble </a>的一部分，为了使设备厂商可以更简单、低成本地更新，我们对 Android 的框架也进行了重构。将平台和供应商代码分离的目的也是为了提高安全性，根据<a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege" target="_blank" rel="noopener">最小特权原则</a>，这些硬件抽象层(HALs)运行在<a href="https://android-developers.googleblog.com/2017/07/shut-hal-up.html" target="_blank" rel="noopener">自己的沙盒中</a>，只对有权限的驱动设备开放。</p>
<p>追随着Android Nougat 中<a href="https://android-developers.googleblog.com/2016/05/hardening-media-stack.html" target="_blank" rel="noopener">媒体堆栈加固</a>，我们在Android Oreeo 媒体框架中移除了许多直接访问硬件的模块，从而创造了更好的隔离环境。此外，此外我们启用了所有媒体组件中的控制流完整性（Control Flow Integrity, CFI）保护。这种缺陷可以通过破坏应用的正常控制流，从而利用这种特权执行恶意的活动。 CFI 拥有健全的安全验证机制，不允许随意更改原来编译后二进制文件的控制流程图，也使得这样的攻击难以执行。</p>
<p>除了这些架构改变和CFI以外，Android Oreo 还带来了其他平台安全性相关的提升：</p>
<ul>
<li><strong><a href="https://android-developers.googleblog.com/2017/07/seccomp-filter-in-android-o.html" target="_blank" rel="noopener">Seccomp（Secure computing mode, 安全计算模式）过滤</a></strong>: 一些系统层的调用不再对应用开放，从而减少潜在损害应用途径。</li>
<li><strong><a href="https://lwn.net/Articles/695991/" target="_blank" rel="noopener">加固用户拷贝</a></strong>: 一个最新的 Android <a href="https://events.linuxfoundation.org/sites/events/files/slides/Android-%20protecting%20the%20kernel.pdf" target="_blank" rel="noopener">安全漏洞掉渣</a>显示：在内核漏洞中，失效的或者无边界检查情况约占 45%。在 Android 内核 3.18 及以上版本中，我们新增了一个边界检查的补丁，使得利用这个漏洞变得更困难，同时还同帮助开发者在他们代码中查找问题并修复问题。</li>
<li><strong>Privileged Access Never(PAN)仿真</strong>: 同时针对 3.18 以上的内核新增了补丁，这个功能禁止内核直接访问用户空间，同时确保开发者利用加固后的方式开访问用户空间。</li>
<li><strong>内核地址空间布局随机化(KASLR)</strong>：虽然Android已经支持地址空间布局随机化（ASLR）好多年了，我们仍针对 Android 内核 4.4 及以上版本提供了内核地址空间布局随机化（KASLR）补丁减少风险。内核地址空间布局随机化（KASLR）将在每次设备启动加载内核代码时随机分配地址，使得代码复用攻击，尤其是远程攻击更加难以执行。</li>
</ul>
<h3 id="应用程序安全性及设备标示变更"><a href="#应用程序安全性及设备标示变更" class="headerlink" title="应用程序安全性及设备标示变更"></a>应用程序安全性及设备标示变更</h3><p><a href="https://developer.android.com/topic/instant-apps/index.html" target="_blank" rel="noopener">Android 即时运行应用</a>运行在一个受限制的沙盒中，因此限制了部分权限和功能，例如访问设备内应用列表或者着明文传递数据。虽然是从 Android Oreo 才发布,但是即时运行应用支持在 <a href="https://www.android.com/versions/lollipop-5-0/" target="_blank" rel="noopener">Android Lollipop</a> 及以上版本的设备上运行。</p>
<p>为了更安全的处理不可信内容，我们通过将渲染引擎放到另一个进程中并将它运行在一个独立的资源受限的沙盒中来<a href="https://android-developers.googleblog.com/2017/06/whats-new-in-webview-security.html" target="_blank" rel="noopener">隔离 WebView</a>。此外，WebView 还支持<a href="https://safebrowsing.google.com/" target="_blank" rel="noopener">安全浏览</a>，从而保护使用者浏览含有潜在危险的网站。</p>
<p>最后，我们针对<a href="https://android-developers.googleblog.com/2017/04/changes-to-device-identifiers-in.html" target="_blank" rel="noopener">设备标识做了重大的改变</a>开放给用户更多的控制权，包括：</p>
<ul>
<li>静态的 Android ID 和 Widevine 将变为基于应用变化的值，这有助于限制设备中无法重置的标识符的使用。</li>
<li>依照 <a href="https://tools.ietf.org/html/rfc7844#section-3.7" target="_blank" rel="noopener">IETF RFC 7844</a>，现在 <code>net.hostname</code> 将为空且 DHCP 客户端也将不再发送主机名称（hostname)。</li>
<li>对于需要设备标识符的应用，我们新增了一个 <code>Build.getSerial() API</code> 并且通过权限对其进行保护。</li>
<li>我们与安全研究人员一起 <sup>1</sup> 在各种芯片组固件中的 Wi-Fi 扫描环节中新增一个健全的MAC地址随机化功能.</li>
</ul>
<p>Android Oreo 带来远不止这些改进，还有<a href="https://www.android.com/versions/oreo-8-0/" target="_blank" rel="noopener">更多</a>。一如既往，如果您有关于 Android 的反馈或是改进建议。欢迎发送邮件至 security@android.com。</p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/02/20180102-women-and-mobile-games-learnings-for-developers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="corresponding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corresponding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/02/20180102-women-and-mobile-games-learnings-for-developers/" itemprop="url">开发者须知-女性玩家和手机游戏</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-02T19:02:37+08:00">
                2018-01-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/译文/" itemprop="url" rel="index">
                    <span itemprop="name">译文</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <img src="/2018/01/02/20180102-women-and-mobile-games-learnings-for-developers/title.jpg">
<blockquote>
<ul>
<li>原文地址：<a href="https://medium.com/googleplaydev/women-and-mobile-games-learnings-for-developers-cc4ac63da3f2" target="_blank" rel="noopener">Women and mobile games: learnings for developers</a></li>
<li>原文作者：<a href="https://medium.com/@tobias.knoke?source=post_header_lockup" target="_blank" rel="noopener">Tobias Knoke</a></li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li>
<li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO/women-and-mobile-games-learnings-for-developers.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO/women-and-mobile-games-learnings-for-developers.md</a></li>
<li>译者：<a href="https://github.com/corresponding" target="_blank" rel="noopener">corresponding</a></li>
<li>校对者：<a href="https://github.com/hanliuxin5" target="_blank" rel="noopener">hanliuxin5</a>，<a href="https://github.com/tanglie1993" target="_blank" rel="noopener">tanglie1993</a></li>
</ul>
</blockquote>
<h1 id="开发者须知：女性玩家和手机游戏"><a href="#开发者须知：女性玩家和手机游戏" class="headerlink" title="开发者须知：女性玩家和手机游戏"></a>开发者须知：女性玩家和手机游戏</h1><p>Women and mobile games: learnings for developers</p>
<h2 id="让手机游戏变得更加多元化，更具包容性，更具吸引力的市场机遇"><a href="#让手机游戏变得更加多元化，更具包容性，更具吸引力的市场机遇" class="headerlink" title="让手机游戏变得更加多元化，更具包容性，更具吸引力的市场机遇"></a>让手机游戏变得更加多元化，更具包容性，更具吸引力的市场机遇</h2><p>The market opportunity in making mobile gaming more diverse, more inclusive, and more engaging</p>
<p>目前世界上有二十多亿部活跃的安卓设备，这意味着比起过去更多的人在玩手机游戏。手机游戏玩家的增长导致了这些游戏玩家的特点，需求和动机的多样性在不断扩大。我们之前文章 <a href="https://medium.com/googleplaydev/who-plays-mobile-games-8b33f76bb6d8" target="_blank" rel="noopener">谁在玩手机游戏</a> 讨论过，现在需要以满足在玩家玩游戏时的需求来对待玩家，而不是根据一些刻板印象和像人口统计那样的死板数据。与此同时，现在在游戏界有很多关于性别和包容的讨论，而关于<strong>女性手机游戏玩家</strong>的研究和讨论却很少。<br>There are now over two billion active Android devices which means more people are playing mobile games than ever before. The growth of the mobile games audience had led to an expansion of diversity in characteristics, needs, and motivations of those playing games. In our previous post Who plays mobile games we discussed the opportunity to think of players in terms of the needs met by playing games, rather than in terms of stereotypes and demographics. At the same time, there is a lot of conversation in the gaming community about gender and inclusivity, but relatively little research or discussion about the experiences of women who play mobile games.</p>
<p>我们想更多的了解这方面，所以我们和游戏情报商 NewZoo 合作，进行定量的研究，希望以此了解美国女性玩家的体验和看法。我们和数十位游戏作者，测评人员，玩家和学者一起合作，把我们的研究场景化。通过 <a href="https://play.google.com/about/changethegame" target="_blank" rel="noopener">交互性的体验</a> 和 <a href="http://services.google.com/fh/files/misc/changethegame_white_paper.pdf" target="_blank" rel="noopener">在总结中收获更多</a> ，我们深入研究。请继续读下去，了解开发者如何让游戏更具包容性，并吸引近在咫尺的玩家。<br>We wanted to understand more about this so we partnered with gaming intelligence provider Newzoo to produce a quantitative research study to understand the experiences and perceptions of women who play games in the United States. We worked with dozens of game makers, critics, players, and academics to contextualize our research. Dive deeper into the insights through this interactive experience or discover more learnings in a summary of our findings. Read on to find out how you as a developer can make your game more inclusive and appealing to all players out there.</p>
<img src="/2018/01/02/20180102-women-and-mobile-games-learnings-for-developers/0.png">
<h3 id="了解你的用户"><a href="#了解你的用户" class="headerlink" title="了解你的用户"></a><strong>了解你的用户</strong></h3><p>Know your audience</p>
<p>无论从人数上和偏好上来说，女性手机游戏玩家有巨大市场潜力。在我们的调查中，美国有大量女性手机游戏玩家（其中 65% 都处于 10 - 65 岁年龄段）。在过去的一年里，这比去电影院看过电影的比例（62%）或读过一本书的比例（44%）更加高。这里可以清晰的看出，比起其他娱乐活动，女性更愿意玩手机游戏。报告还表明，女性就和男性一样喜欢玩手机游戏 — <strong>有一半的玩家是女性</strong>！相比其他平台，女性不仅更喜欢在手机上游戏，而且<strong>女性玩的频率比男性更高</strong>。<br>There is significant market potential in women who play mobile games, both in terms of volume and preference for the platform. In our research we found a significant number of women in the US play mobile games today (65% of those aged between 10–65 years). This is a higher percentage than those who have watched a movie at a movie theater (62%), or read a book (44%), in the last year. It’s clear that women engage significantly more in mobile gaming than in other forms of entertainment, and that’s not it… Research has shown that they are just as likely to play mobile games as men — women represent half of all mobile game players! They are not only more likely to prefer mobile compared to other platforms, women also tend to play more frequently than men.</p>
<p>作为游戏开发者，你意识到女性游戏的机会了吗？这可能是个通过了解这些用户而进入这个未开发的市场的机会。第一步，你可能要衡量和评估女性玩家的占比。<strong>在你的用户群体中，女性是否被很好的代表了？她们和男性是否有不同的游戏体验？</strong><br>As a games developer, do you consider the opportunity presented women for your games? There may be an opportunity for you to grow your business in untapped markets by better understanding your players. As a starting point you might want to measure and evaluate the percentage of players who are women. Are women well represented in your player base? Is there a difference in their user experience compared to your male players?</p>
<p>对开发新游戏时的建议：当你在设计游戏或者思考未来的发展方向时，多去想想那些目标用户，而不用去讨好那些你所认为的”典型”用户。不同用户的游戏体验可能会不同吗？通过彻底分析和研究用户，你可以从那些尚未被顾及的用户（比如那些女性游戏玩家）中寻找商机。<br>The same goes for new developments: when designing your game, or thinking of future development, it can be a useful exercise to think of the range of people who may play your game, rather than gravitating to the ‘typical’ player. Could there be a difference in the user experience of some players? By thoroughly analysing and researching user audiences you can potentially make a strong business case to capture an underserved audience — such as women who play games.</p>
<img src="/2018/01/02/20180102-women-and-mobile-games-learnings-for-developers/1.png">
<h3 id="制作更具包容性的游戏"><a href="#制作更具包容性的游戏" class="headerlink" title="制作更具包容性的游戏"></a><strong>制作更具包容性的游戏</strong></h3><p>Build more inclusive games</p>
<p>如果你观察 <a href="https://play.google.com/store" target="_blank" rel="noopener"> Google 应用市场</a> 中受欢迎的游戏，部分图像和图标的性质暗示着女性玩家在游戏世界中是一个相对较小的群体。在Google应用市场收入前 100 的游戏中，以男性角色作为图标的游戏数量比以女性角色作为图标的游戏数量多 44%。所以在我们的调查中，尽管女性玩家玩的更多，但是她们还是认为自己不属于现在的游戏社区。在推广游戏时，更换更合适的图标和形象，会让你从竞争中脱颖而出，也会减少你错过潜在玩家的可能。请尝试以下几点：<br>If you look at popular games on Google Play, the nature of much of the imagery and icons would imply women are a relatively niche group in the world of gaming: among the top 100 revenue generating games on Google Play, characters who are men are featured in their app icons 44% more often than characters who are women. Consequently our research found women often do not feel like they belong to this community although they are playing games very actively. Using alternative, or less alienating, iconography, characters, and imagery when promoting your game could help differentiate it clearly from your competition, and ensure you don’t miss out on reaching potential players. Try the following quick tips:</p>
<ul>
<li>在做 <a href="https://support.google.com/googleplay/android-developer/answer/6227309?hl=en-GB" target="_blank" rel="noopener">商店列表</a> 时，<strong>测试更有包容性的图像</strong>。<br>Test more inclusive imagery when running store listing experiments.</li>
<li><strong>多关注应用的图标，截图和视频</strong>，并考虑测试不同图像对转换率的影响。<br>Pay attention to your icon, screenshots, and videos, and consider testing the impact of different imagery on conversion rates.</li>
<li>考虑下<strong>使用女性角色来体验游戏</strong>，或者在运行<strong>电话回访</strong>时<strong>尝试新的可能性</strong>。<br>Think of launching with characters who are women, or testing new ones when running LiveOps.</li>
<li>追踪用户对游戏角色的共鸣，同时<strong>倾听用户群体的反馈</strong>也很重要。<br>Track how people are resonating with the characters, and, invaluably, listen to the feedback of your community.</li>
</ul>
<h3 id="发展一个多样化的开发团队"><a href="#发展一个多样化的开发团队" class="headerlink" title="发展一个多样化的开发团队"></a><strong>发展一个多样化的开发团队</strong></h3><p>Grow a diverse team</p>
<p>在一大群人中提取共同需求很难。我们都想开发<strong>自己</strong>想玩的游戏。为了减少偏见，<strong>在游戏生命周期的几个阶段，都需要获取潜在用户的反馈</strong>。<br>It is very difficult to have the empathy and perspective needed to build a product that meets the needs of a wide range of potential people. It’s human nature to build games you want to play. To reduce potential bias, request feedback from a broad representation of your potential players at several stages throughout your game’s lifecycle.</p>
<p>你的开发团队的形象也影响能否取到悦更多的用户。尽管有如此多的女性玩家，游戏行业仍然只关注男性用户: IDGA的调查发现，女性、跨性别者和其他只占 <a href="http://c.ymcdn.com/sites/www.igda.org/resource/resmgr/files__2016_dss/IGDA_DSS_2016_Summary_Report.pdf" target="_blank" rel="noopener">全球 27.8% 的游戏产业</a> 。这种不平衡的现象呼应我们的研究结果，只有 23％ 的女性和 40％ 的男性认为在游戏行业中人人享有平等的待遇和机会。<br>The profile of your development team also impacts your ability to build games that appeal to a wide spectrum of players. Despite the high proportion of women playing mobile games, men are overrepresented in the gaming industry: according to the IDGA, only 27.8% of the gaming industry globally are women, transgender, or other people. This imbalanced representation is felt by players who responded to our research with only 23% of women and 40% of men believing there is equal treatment and opportunity for all in the games industry.</p>
<p>来自团队成员多样化的观点将帮助您开发真正创新且有意思的游戏，并且吸引更多的潜在玩家。现在就看下自己的团队和游戏的用户构成的差别。你的团队成员能代表你的受众吗？您的团队是否已经整装待发，来帮助您最大化的捕获潜在受众，并且让您的游戏吸引所有人？<br>Diversity of perspectives from your team members will help you build truly innovative and exciting games that will appeal to a broad spectrum of potential players. Look at your team and compare it with the user composition of your game. Is your team truly representative of your audience? Is it well equipped to help you capture the maximum potential audience possible by making your game appealing to everyone?</p>
<img src="/2018/01/02/20180102-women-and-mobile-games-learnings-for-developers/2.png">
<h3 id="把握这个机遇"><a href="#把握这个机遇" class="headerlink" title="把握这个机遇"></a><strong>把握这个机遇</strong></h3><p>Take advantage of this opportunity</p>
<p>尽管未来女性玩家数量巨大，但研究结果却让人惊讶，他们比男性更难以真正接受自己的游戏爱好。大部分女性玩家不属于游戏世界。一般女性玩家不太喜欢和朋友交谈游戏内容，为游戏付费，以及享受付费所带来的快乐。<br>While there is great potential in the sheer volume of women playing mobile games, it is striking from the research how less likely they are than men to truly embrace their play habits. With a few notable exceptions, there is a sense that women don’t belong in the world of gaming. They are less likely to talk about games with their friends, pay for content, or feel good when they do pay.</p>
<p>我们相信，这是一个游戏产业真正与女性玩家互动的绝佳机会。随着用户获取成本的上升，需要想想如何能开发出与所有玩家产生共鸣并且能病毒式传播的游戏。只有让女性玩家参与到游戏中，你才能解决这个问题。<br>We believe this represents a great opportunity for the industry to truly engage with women who play games. As user acquisition costs rise, think of the potential virality of building a game that resonates with and excites all players. This can only be achieved by recognizing and addressing the barriers for women to engage with your game.</p>
<h3 id="着眼未来"><a href="#着眼未来" class="headerlink" title="着眼未来"></a><strong>着眼未来</strong></h3><p>The road ahead</p>
<p>我们相信，游戏市场还有很大的空间，能让我们使手机游戏更加多元化，更具包容性，更吸引所有玩家。为了把握这个机会，您的第一步是：<br>We believe there is a great opportunity in market growth and making mobile gaming more diverse, more inclusive, and more engaging for all players. The first steps for you in order to take advantage of this opportunity are:</p>
<ul>
<li>了解你的用户：当前用户和潜在用户<br>Know your audience: current and potential</li>
<li>研究你的游戏是怎样把一些潜在用户排除在外的<br>Consider how your games may exclude some potential players</li>
<li>评估你团队观点的多样性，这将如何影响你开发的游戏<br>Assess the range of perspectives in your team, and how this affects the games you build</li>
<li>头脑风暴，你可能会想出一款所有人都喜欢的游戏<br>Brainstorm how you may produce the next game that all players could embrace</li>
</ul>
<p>手机游戏生为大众。为了褒奖和激励女性玩家和女性开发者，我们启动了 <a href="http://g.co/changethegame" target="_blank" rel="noopener">改变游戏</a> 的计划。这是 Google 应用商店的一项旨在促进游戏多样性的计划，同时这项计划也褒奖所有女性玩家，并通过正在进行的研究和合作为下一代游戏开发者提供支持。<br>Mobile games are for everyone. To celebrate and empower women who play games and creators, we’re launching CHANGE THE GAME; a new Google Play initiative to promote diversity in games, celebrate all women who play games, and empower the next generation of game-makers through ongoing research, development programs, and partnerships.</p>
<p>作为一个应用开发者，你能影响未来游戏的走向。我希望你能参与到我们活动中，和我们一起让游戏世界变得更加包容性。如果我们一起努力，手机游戏的世界会变得更加有趣。<br>As a mobile developer, you have a major influence on how future games will look like. We hope you can join our efforts of making the gaming world a more inclusive community; if we all contribute to this, mobile games will bring us even more joy than they do today.</p>
<hr>
<h3 id="你是怎么想的呢？"><a href="#你是怎么想的呢？" class="headerlink" title="你是怎么想的呢？"></a>你是怎么想的呢？</h3><p>What do you think?</p>
<p>你有没有想过开发人员怎样去设计更有包容性的游戏呢？在文章下面留言或者 twitter 中添加<strong>#AskPlayDev</strong>标签后发言，我们会通过 <a href="http://twitter.com/googleplaydev" target="_blank" rel="noopener">@GooglePlayDev</a> （那里我们会展示在 Google 应用商店获得成功的窍门）回复。<br>Do you have thoughts on how developers can build more inclusive games? Join the discussion in the comments below or tweet using the hashtag #AskPlayDev and we’ll reply from @GooglePlayDev, where we regularly share news and tips on how to be successful on Google Play.</p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/20/20171220-Okio-source/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="corresponding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corresponding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/20/20171220-Okio-source/" itemprop="url">Okio源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-20T19:39:26+08:00">
                2017-12-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <img src="/2017/12/20/20171220-Okio-source/1.jpg" title="深秋">
<p>大家一定听说或者使用过鼎鼎大名的OKHttp和Retrofit，它们内部都调用了Okio。<br>它们三个都是Square团队开源的库，主要处理I/O操作和网络请求。<br>今天我们就来读下Okio的源码，看看Okio有什么神奇之处。</p>
<h1 id="Okio是什么"><a href="#Okio是什么" class="headerlink" title="Okio是什么?"></a>Okio是什么?</h1><p>Okio是一个完善java.io和java.nio的库，可以更方便的读、写、处理数据。</p>
<p>看到上面的官方介绍，我们可以发现两个重点：<br>1.完善java.io和java.nio；<br>2.Okio的主要功能是，读、写、处理数据。</p>
<p>再深入思考下，java.io和java.nio有哪些尚未完善的地方？Okio有做了哪些优化？</p>
<p>java.io能处理所有的IO信息，但是还是有些不完美之处：<br>1.需要自己去管理byte数组；<br>2.java.io类和继承关系过于复杂，使用起来更加不便；<br>3.java.io操作可能会某些原因读取速度特别慢，甚至一直等待无法返回；<br>4.操作字符流和字节流方法不同，需要区别对待；<br>5.涉及到多个流之间的数据传递，需要反复拷贝，效率不高。</p>
<p>被Android官方青睐的IO库，Okio一一解决了这些问题：<br>1.使用ByteString去封装byte数组；<br>2.简化类关系，主要使用Buffer、Sink、Source等类，相互关系简单；<br>3.使用Timeout去控制超时；<br>4.可用相同方法去操作字符流和字节流；<br>5.提高多个流之间的数据传递速度。</p>
<p>带着这些问题，我们继续前进。</p>
<h1 id="ByteString"><a href="#ByteString" class="headerlink" title="ByteString"></a>ByteString</h1><p>记得我最开始编程时，C语言中没有字符串类型，只能使用char*的方式存储字符串，而且经常涉及数组和指针的转换，<br>需要使用memcpy和memset等等函数，容易出错，而且还需要加入大量的检测。<br>后面使用面向对象语言后，发现用String对象直接管理字符串，良好的封装char数组的常用方法，使用起来各种清爽。</p>
<p>同样使用过java.io的开发者，肯定会想起被byte数组笼罩的恐惧。<br>需要不厌其烦的处理一串串byte数组，完成encode和decode函数，还要特别关注编码问题。<br>这个时候就希望，能有一个对象来管理byte数组，并且帮我们封装好各种函数，使用时直接调用下即可。</p>
<p>Okio就满足开发者这个愿望，提供了ByteString类，把对字节数组的常用方法都封装好了。<br>使用Okio库后，开发者可以以ByteString作为最小粒度进行操作。</p>
<p>先来看下ByteString的组成<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.实现了Serializable和Comparable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteString</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">ByteString</span>&gt; &#123;</span></span><br><span class="line">  <span class="comment">// 1.byte数组，所以为ByteString</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">byte</span>[] data;</span><br><span class="line">  <span class="comment">// 2.hashCode，在需要时才计算出。不会被序列化</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> hashCode;</span><br><span class="line">  <span class="comment">// 3.data utf8化后生成的String，在需要时才计算出。不会被序列化</span></span><br><span class="line">  <span class="keyword">transient</span> String utf8; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ByteString的内部也不复杂，主要就是byte数组。<br>这里要看下String的结构，其实String可以命名为CharString。<br>因为一般开发中，字符串用的比较多，所以java官方直接命名为String。<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.同样实现了Serializable和Comparable接口，额外实现了CharSequence处理常规char数组数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.char数组，所以String等于CharString</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">	<span class="comment">// 2.hashCode</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下去看下，ByteString的读和写<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteString <span class="keyword">read</span>(InputStream in, <span class="keyword">int</span> byteCount) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.检查合法性</span></span><br><span class="line">    <span class="keyword">if</span> (in == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"in == null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (byteCount &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"byteCount &lt; 0: "</span> + byteCount);</span><br><span class="line">    <span class="comment">// 2.分配空间</span></span><br><span class="line">    <span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span class="keyword">byte</span>[byteCount];</span><br><span class="line">    <span class="comment">// 3.循环读取inputStream中的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> offset = <span class="number">0</span>, <span class="keyword">read</span>; offset &lt; byteCount; offset += <span class="keyword">read</span>) &#123;</span><br><span class="line">      <span class="comment">// 3.1.每次尽可能多的读取inputStream数据，放入result中</span></span><br><span class="line">      <span class="keyword">read</span> = in.<span class="keyword">read</span>(result, offset, byteCount - offset);</span><br><span class="line">      <span class="comment">// 3.2.读取inputStream异常</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">read</span> == -<span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.生成ByteString</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ByteString(result);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span>(<span class="params">OutputStream <span class="keyword">out</span></span>) throws IOException </span>&#123;</span><br><span class="line">	<span class="comment">// 1.检查合法性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">out</span> == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"out == null"</span>);</span><br><span class="line">	<span class="comment">// 2.直接写入byte数组</span></span><br><span class="line">    <span class="keyword">out</span>.write(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h1><p>IO操作的最重要部分就是对流的处理，所以定义好一个流非常关键。<br>Okio中，就是用Buffer去表示流。</p>
<img src="/2017/12/20/20171220-Okio-source/2.png" title="Buffer类关系图">
<p>先看下翻译<br>source：来源；水源；<br>sink：水槽；洗涤槽；<br>一下子就明白了Source表示输入源，Sink表示输出源。<br>对应java.io中的inputStream和outputStream。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> <span class="keyword">implements</span> <span class="title">BufferedSource</span>, <span class="title">BufferedSink</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">  Segment head;</span><br><span class="line">  <span class="keyword">long</span> size;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>size表示Buffer中的字节数量。<br>主要成员变量也非常简单，就是segment。<br>源码上注释非常简洁清晰：A segment of a buffer，翻译过来就是Buffer的片段。<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span> </span>&#123;</span><br><span class="line">  Segment prev;			<span class="comment">// 指向双向链表上一节点</span></span><br><span class="line">  Segment next;			<span class="comment">// 指向双向链表下一节点</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">byte</span>[] data;    <span class="comment">// data表示本segment存储的数据</span></span><br><span class="line">  <span class="keyword">int</span> pos;              <span class="comment">// pos表示data中下一个读取字节的index</span></span><br><span class="line">  <span class="keyword">int</span> limit;            <span class="comment">// limit表示data中下一个写入字节的index。为什么用limit命名呢，因为这个index也是读取字节的上限</span></span><br><span class="line">  <span class="keyword">boolean</span> shared;       <span class="comment">// 是否共享。Okio为了提高效率，在某些时候不拷贝整个segment，而是采用弱引用方式指向segment</span></span><br><span class="line">  <span class="keyword">boolean</span> owner;        <span class="comment">// 因为加入共享功能后，就需要确定持有者，只有持有者才能往这个segment中写数据</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从prev和next就可以发现这是双向链表。在Buffer中就持有head，通过head去访问整个链表。<br>通过后续的代码阅读，发现这是一个双向循环链表。</p>
<img src="/2017/12/20/20171220-Okio-source/3.png" title="segment双向链表">
<p>我们分析下Okio中是如何写入和读取byte数据的。</p>
<h2 id="Buffer-writeByte"><a href="#Buffer-writeByte" class="headerlink" title="Buffer.writeByte"></a>Buffer.writeByte</h2><p>先来看看Buffer怎么样写入一个byte<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.注意入参是int格式，不过其中有效数据的只有8 bit</span></span><br><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="function">Buffer <span class="title">writeByte</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1.寻找可供写入的segment</span></span><br><span class="line">    Segment tail = writableSegment(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 2.在segment中写入字节byte。limit的含义在上文提及，表示下一个写入字节的index</span></span><br><span class="line">    tail.data[tail.limit++] = (<span class="keyword">byte</span>) b;</span><br><span class="line">    <span class="comment">// 3.buffer中size变化</span></span><br><span class="line">	size += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>writeByte函数的代码都很简单，我们继续看看如何寻找可供写入的segment。</p>
<h2 id="Buffer-writableSegment"><a href="#Buffer-writableSegment" class="headerlink" title="Buffer.writableSegment"></a>Buffer.writableSegment</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.入参minimumCapacity表示允许写的最小空间</span></span><br><span class="line">Segment writableSegment(<span class="keyword">int</span> minimumCapacity) &#123;</span><br><span class="line">    <span class="comment">// 1.检查合法性</span></span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity &lt; <span class="number">1</span> || minimumCapacity &gt; Segment.<span class="keyword">SIZE</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 2.当前head为空时，先新建一个</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 2.1.从SegmentPool中取出一个segment</span></span><br><span class="line">      head = SegmentPool.take();</span><br><span class="line">      <span class="comment">// 2.2.设置为双向循环链表</span></span><br><span class="line">      <span class="keyword">return</span> head.<span class="keyword">next</span> = head.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.选择链表最尾部的segment</span></span><br><span class="line">    Segment tail = head.prev;</span><br><span class="line">    <span class="comment">// 4.如果尾部segment中没有足够的可写空间，或者当前Buffer不是尾部segment的持有者，重新从SegmentPool取出segment插入链表</span></span><br><span class="line">    <span class="keyword">if</span> (tail.limit + minimumCapacity &gt; Segment.<span class="keyword">SIZE</span> || !tail.owner) &#123;</span><br><span class="line">      tail = tail.<span class="keyword">push</span>(SegmentPool.take());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里引入了SegmentPool这个类，主要用来管理Segment对象，回收旧segment，分配segment。<br>SegmentPool减少了segment的新建和释放次数，缓解java GC的压力。</p>
<p>注：类似于Handler中message.obtain()，其背后也有一个pool去管理所有的message对象。</p>
<h2 id="SegmentPool"><a href="#SegmentPool" class="headerlink" title="SegmentPool"></a>SegmentPool</h2><p>这个类代码很短，全部贴出来<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> SegmentPool &#123;</span><br><span class="line">  <span class="comment">// pool 容量上限，最大为64KiB</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MAX_SIZE = <span class="number">64</span> * <span class="number">1024</span>;</span><br><span class="line">  <span class="comment">// 单向链表</span></span><br><span class="line">  <span class="keyword">static</span> Segment <span class="keyword">next</span>;</span><br><span class="line">  <span class="comment">// pool中总字节数</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">long</span> byteCount;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> SegmentPool() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Segment take() &#123;</span><br><span class="line">    <span class="comment">// take和recycle中next都被synchronize包含，所以是线程安全的</span></span><br><span class="line">    <span class="keyword">synchronized</span> (SegmentPool.<span class="keyword">class</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果当前pool不为空，链表还有数据，从链表头取出segment</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">next</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Segment result = <span class="keyword">next</span>;</span><br><span class="line">        <span class="keyword">next</span> = result.<span class="keyword">next</span>;</span><br><span class="line">        result.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">        byteCount -= Segment.<span class="keyword">SIZE</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前pool部为空，链表中没有数据，新建一个segment</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Segment();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> recycle(Segment segment) &#123;</span><br><span class="line">    <span class="keyword">if</span> (segment.<span class="keyword">next</span> != <span class="keyword">null</span> || segment.prev != <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 如果当前segment被共享，则放弃回收</span></span><br><span class="line">    <span class="keyword">if</span> (segment.shared) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// take和recycle中next都被synchronize包含，所以是线程安全的</span></span><br><span class="line">    <span class="keyword">synchronized</span> (SegmentPool.<span class="keyword">class</span>) &#123;</span><br><span class="line">      <span class="comment">// pool达到上限的，放弃回收</span></span><br><span class="line">      <span class="keyword">if</span> (byteCount + Segment.<span class="keyword">SIZE</span> &gt; MAX_SIZE) <span class="keyword">return</span>;</span><br><span class="line">      byteCount += Segment.<span class="keyword">SIZE</span>;</span><br><span class="line">      segment.<span class="keyword">next</span> = <span class="keyword">next</span>;</span><br><span class="line">      <span class="keyword">next</span> = segment;</span><br><span class="line">      <span class="comment">// 重新设置segment的pos和limit</span></span><br><span class="line">      segment.pos = segment.limit = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>segmentPool这个类非常简单，内部维护一个单向列表。<br>take()会从头部取出segment，recycler()将待回收的segment放回到链表头部。</p>
<h2 id="Buffer-readByte"><a href="#Buffer-readByte" class="headerlink" title="Buffer.readByte"></a>Buffer.readByte</h2><p>我们来看下readByte，其方法和writeByte完全对称。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span> readByte() &#123;</span><br><span class="line">    <span class="comment">// 1.检查合法性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">size</span> == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"size == 0"</span>);</span><br><span class="line">    <span class="comment">// 2.取出segment中数据</span></span><br><span class="line">    Segment segment = head;</span><br><span class="line">    <span class="keyword">int</span> pos = segment.pos;</span><br><span class="line">    <span class="keyword">int</span> limit = segment.limit;</span><br><span class="line">    <span class="keyword">byte</span>[] data = segment.data;</span><br><span class="line">    <span class="keyword">byte</span> b = data[pos++];</span><br><span class="line">    <span class="keyword">size</span> -= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 3.如果当前segment中数据被读取完毕</span></span><br><span class="line">    <span class="keyword">if</span> (pos == limit) &#123;</span><br><span class="line">      <span class="comment">// 3.1.从双向链表中pop出来</span></span><br><span class="line">      head = segment.<span class="keyword">pop</span>();</span><br><span class="line">      <span class="comment">// 3.2.回收这个segment，放入到segmentPool中</span></span><br><span class="line">      SegmentPool.recycle(segment);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 4.如果当前segment中数据未被读取完毕，只更新pos信息</span></span><br><span class="line">      segment.pos = pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h1><p>IO最重要的就是对流的处理，Okio中对应的数据结构是Source和Sink</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.Closeable接口中方法为close()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Source</span> <span class="keyword">extends</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.读取Buffer中byteCount长度的数据，返回值为本次读取的字节长度</span></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">read</span><span class="params">(Buffer sink, <span class="keyword">long</span> byteCount)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">  <span class="comment">// 2.超时控制</span></span><br><span class="line">  <span class="function">Timeout <span class="title">timeout</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 3.关闭source并且释放资源，允许调用多次</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个接口，后续都是使用其实现类作为输入流。</p>
<h2 id="Okio-Source"><a href="#Okio-Source" class="headerlink" title="Okio.Source"></a>Okio.Source</h2><p>我们看下Okio.Source，开发者一般都使用这个函数生成Source。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function">Source <span class="title">source</span><span class="params">(<span class="keyword">final</span> InputStream in, <span class="keyword">final</span> Timeout timeout)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.检查合法性</span></span><br><span class="line">    <span class="keyword">if</span> (in == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"in == null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout == null"</span>);</span><br><span class="line">    <span class="comment">// 2.新建了一个匿名类，实现Source接口</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Source() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">long</span> <span class="title">read</span><span class="params">(Buffer sink, <span class="keyword">long</span> byteCount)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 2.1.检查合法性</span></span><br><span class="line">        <span class="keyword">if</span> (byteCount &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"byteCount &lt; 0: "</span> + byteCount);</span><br><span class="line">        <span class="keyword">if</span> (byteCount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 2.2.检查是否超时</span></span><br><span class="line">          timeout.throwIfReached();</span><br><span class="line">          <span class="comment">// 2.3.寻找可供写入的segment，在之前详细解释过</span></span><br><span class="line">          Segment tail = sink.writableSegment(<span class="number">1</span>);</span><br><span class="line">          <span class="comment">// 3.3.当前segment剩余可以写入大小，和byteCount两者间选择较小的值，设置为maxToCopy</span></span><br><span class="line">          <span class="keyword">int</span> maxToCopy = (<span class="keyword">int</span>) Math.min(byteCount, Segment.SIZE - tail.limit);</span><br><span class="line">          <span class="comment">// 3.4.从InputStream中尽可能的提取maxToCopy长度，写入到segment中</span></span><br><span class="line">          <span class="keyword">int</span> bytesRead = in.read(tail.data, tail.limit, maxToCopy);</span><br><span class="line">          <span class="comment">// 3.5.读取异常</span></span><br><span class="line">          <span class="keyword">if</span> (bytesRead == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          <span class="comment">// 3.6.调整segment和buffer中的参数</span></span><br><span class="line">          tail.limit += bytesRead;</span><br><span class="line">          sink.size += bytesRead;</span><br><span class="line">          <span class="keyword">return</span> bytesRead;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AssertionError e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (isAndroidGetsocknameError(e)) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(e);</span><br><span class="line">          <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        in.close();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function">Timeout <span class="title">timeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timeout;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function">String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"source("</span> + in + <span class="string">")"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码逻辑非常清晰，流水型执行下去即可。<br>这里出现了一个新的对象timeout，用来管理超时，我们看看其内部结构。</p>
<h2 id="Timeout"><a href="#Timeout" class="headerlink" title="Timeout"></a>Timeout</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Timeout</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.判断deadlineNanoTime是否被定义。如果缺少该变量的话，deadlineNanoTime或者timeoutNanos为0时，无法判断是未设置还是设置为0</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> hasDeadline;</span><br><span class="line">  <span class="comment">// 2.截止时间，单位为纳秒</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> deadlineNanoTime;</span><br><span class="line">  <span class="comment">// 3.设定的超时时间间隔，单位为纳秒</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> timeoutNanos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Timeout主要用来设置超时时间，对Stream的读取超过指定时间后，认定为失败，开发者需要选择close或者重新操作这个Stream。</p>
<p>注：读取网络Socket流时，有时会陷入无限等待中，需要使用AsyncTimeout。AsyncTimeout会新开线程监听超时，当前线程无限等待也没有关系。</p>
<p>继续看下上面被调用的throwIfReached()<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">throwIfReached</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.判断当前线程是否被中断</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedIOException(<span class="string">"thread interrupted"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.判断当前是否超时</span></span><br><span class="line">    <span class="keyword">if</span> (hasDeadline &amp;&amp; deadlineNanoTime - System.nanoTime() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedIOException(<span class="string">"deadline reached"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Okio-buffer"><a href="#Okio-buffer" class="headerlink" title="Okio.buffer"></a>Okio.buffer</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.这里传入上面通过Okio.source生成的Source</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BufferedSource buffer(<span class="keyword">Source</span> <span class="keyword">source</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.生成BufferSource，真正处理输入流，你看命名中都写着real</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RealBufferedSource(<span class="keyword">source</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="RealBufferedSource"><a href="#RealBufferedSource" class="headerlink" title="RealBufferedSource"></a>RealBufferedSource</h1><p>终于找到开发者最后操作的Source类，先来看下它的成员吧。<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.实现BufferedSource接口</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealBufferedSource</span> <span class="keyword">implements</span> <span class="title">BufferedSource</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.初始化时自动生成</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Buffer buffer = <span class="keyword">new</span> Buffer();</span><br><span class="line">  <span class="comment">// 2.Okio.Buffer中传入的source对象</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Source source;</span><br><span class="line">  <span class="comment">// 3.判断source是否关闭</span></span><br><span class="line">  <span class="keyword">boolean</span> closed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="RealBufferedSource-read"><a href="#RealBufferedSource-read" class="headerlink" title="RealBufferedSource.read"></a>RealBufferedSource.read</h2><p>对于输入流来说，我们需要紧紧抓住read方法。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override <span class="keyword">public</span> <span class="keyword">int</span> <span class="built_in">read</span>(<span class="keyword">byte</span>[] sink, <span class="keyword">int</span> offset, <span class="keyword">int</span> byteCount) throws IOException &#123;</span><br><span class="line">    <span class="comment">// 1.检查合法性</span></span><br><span class="line">    checkOffsetAndCount(sink.length, offset, byteCount);</span><br><span class="line">    <span class="comment">// 2.当前buffer为空时</span></span><br><span class="line">    <span class="built_in">if</span> (<span class="built_in">buffer</span>.<span class="built_in">size</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 2.1.尽可能读取一个segment放入到buffer中</span></span><br><span class="line">      <span class="keyword">long</span> <span class="built_in">read</span> = source.<span class="built_in">read</span>(<span class="built_in">buffer</span>, Segment.SIZE);</span><br><span class="line">      <span class="comment">// 2.2.读取异常</span></span><br><span class="line">      <span class="built_in">if</span> (<span class="built_in">read</span> == <span class="number">-1</span>) <span class="built_in">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.选择buffer中数据和byteCount中较小值</span></span><br><span class="line">    <span class="keyword">int</span> toRead = (<span class="keyword">int</span>) Math.<span class="built_in">min</span>(byteCount, <span class="built_in">buffer</span>.<span class="built_in">size</span>);</span><br><span class="line">    <span class="comment">// 4.将buffer中数据输出到byte数组</span></span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">buffer</span>.<span class="built_in">read</span>(sink, offset, toRead);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>主要流程就是，现将source数据读取到buffer中，再将buffer提取到byte数组中。buffer.read()这个函数这里就不展开讨论了，其原理和buffer.readByte非常相近。</p>
<h1 id="Sink"><a href="#Sink" class="headerlink" title="Sink"></a>Sink</h1><p>同理，完全对应的，也可以按照Okio.sink-&gt; Okio.buffer(Sink)-&gt; RealBufferedSink-&gt; RealBufferedSink.write()流程走完一遍Okio中关于写的操作。</p>
<p>总结，Okio这个库本身并不复杂，将常用的流和字节数据进行良好的封装，加之源码中相近的注释，阅读起来非常流畅，想必使用起来的体验也会非常棒。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/14/20171214-shrinking-apks-growing-installs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="corresponding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corresponding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/14/20171214-shrinking-apks-growing-installs/" itemprop="url">缩小APK，增加下载量</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-14T17:10:12+08:00">
                2017-12-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/译文/" itemprop="url" rel="index">
                    <span itemprop="name">译文</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<ul>
<li>原文地址：<a href="https://medium.com/googleplaydev/shrinking-apks-growing-installs-5d3fcba23ce2" target="_blank" rel="noopener">Shrinking APKs, growing installs: How your app’s APK size impacts install conversion rates</a></li>
<li>原文作者：<a href="https://medium.com/@samueltolomei?source=post_header_lockup" target="_blank" rel="noopener">Sam Tolomei</a></li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li>
<li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO/shrinking-apks-growing-installs.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO/shrinking-apks-growing-installs.md</a></li>
<li>译者：<a href="https://github.com/tanglie1993" target="_blank" rel="noopener">tanglie1993</a></li>
<li>校对者：<a href="http://www.swants.cn" target="_blank" rel="noopener">swants</a>, <a href="https://github.com/corresponding" target="_blank" rel="noopener">corresponding</a></li>
</ul>
</blockquote>
<h1 id="缩小APK，增加下载量"><a href="#缩小APK，增加下载量" class="headerlink" title="缩小APK，增加下载量"></a>缩小APK，增加下载量</h1><h2 id="你的APK大小是如何影响下载转化率的"><a href="#你的APK大小是如何影响下载转化率的" class="headerlink" title="你的APK大小是如何影响下载转化率的"></a>你的APK大小是如何影响下载转化率的</h2><img src="/2017/12/14/20171214-shrinking-apks-growing-installs/0.png">
<p>自从 Android Marketplace （Google Play 的前身）在 2012 年 3 月上线以来，<strong>app 的平均大小增长了四倍</strong>。随着移动 app 的不断成熟，开发者们不断增加新的特性来服务和吸引用户，这使不少人从中受益。然而，随着 app 的特性越来越多——更多 SDK、更高分辨率的图片、更好的图形—— APK 也变得越来越大。在本文中，我讨论了 APK 大小的重要性，并且分析了 Google 在过去 2 年中所做的用户体验研究的结果。<br><img src="/2017/12/14/20171214-shrinking-apks-growing-installs/1.png"></p>
<p>下载的 APK 的平均大小随时间的变化（Google 内部数据）</p>
<p>发现 APK 在变大之后，我们分析了 APK 大小对下载转化率的影响。我们发现，<strong>更小的 APK 对应着更高的下载转化率</strong>，对于新兴市场中的用户而言尤其如此。在许多开发者把注意力投入到向新市场（特别是新兴市场）扩张中去的情况下，关注 app 的大小就显得很重要。</p>
<h3 id="APK-大小是否会影响下载转化率？"><a href="#APK-大小是否会影响下载转化率？" class="headerlink" title="APK 大小是否会影响下载转化率？"></a><strong>APK 大小是否会影响下载转化率？</strong></h3><p>为了研究 APK 大小对用户的选择是否有显著影响，我们分析了<strong>用户在浏览了 Play store 中的一个项目之后成功下载这个 app 的百分比</strong>。</p>
<img src="/2017/12/14/20171214-shrinking-apks-growing-installs/2.png">
<p>在 App store  的相应页面中，你可以通过点击“Read More”看到一个 app 的大小。</p>
<p>这看起来还是有些意义的！总的来说，我们发现在小于 100 MB 的情况下，APK 大小和下载转化率之间存在负相关。<strong>一个 APK 的大小每增长 6 MB，下载转化率就有 1% 的降低</strong>。在市场团队使用 A/B 测试来优化下载转化率的情况下，APK 大小会有重大影响。</p>
<p>这个下降中的一个重要部分不是因为用户选择了不下载，而是下载由于种种原因没有成功。我们发现，一个 10MB 的 app 的下载完成率将比 100MB 的 app 高<strong>大约 30%</strong>。</p>
<p>这可能是因为：</p>
<ol>
<li>用户考虑了需要下载的数据量（以及数据的<strong>价格</strong>）。</li>
<li>在他们的移动网络或 wifi 中的 <strong>下载所需时间</strong> （人们经常陷入“我现在就要这个 app！”的思维模式）。</li>
<li>下载过程中的 <strong>网络连接性问题</strong>。</li>
</ol>
<h3 id="人们对-APK-大小的偏好和下载转化率是否会因地域而异？"><a href="#人们对-APK-大小的偏好和下载转化率是否会因地域而异？" class="headerlink" title="人们对 APK 大小的偏好和下载转化率是否会因地域而异？"></a><strong>人们对 APK 大小的偏好和下载转化率是否会因地域而异？</strong></h3><p>这是一个好问题，答案是肯定的。在新兴市场中，有许多没能使用到稳定 wifi 的用户，他们需要支付流量的费用。</p>
<p><strong>超过 50% 的印度和印尼安卓智能手机用户完全没有 wifi</strong>。所以如果一个用户需要下载一个 app，他很可能要为 APK 的每一 MB 付费（Google 内部数据，2017年）。</p>
<img src="/2017/12/14/20171214-shrinking-apks-growing-installs/3.png">
<p>印度 wifi 普及率调查 (Google 内部安卓用户调查)</p>
<p>与之相似, 出于流量价格和存储空间的考虑，<strong>新兴市场中大约 70% 的用户会在下载前考虑 app 的大小</strong>。</p>
<img src="/2017/12/14/20171214-shrinking-apks-growing-installs/4.png">
<p>被调查的印尼用户中会在安装时考虑 app 大小的人所占百分比 (Google 内部安卓用户调查)</p>
<img src="/2017/12/14/20171214-shrinking-apks-growing-installs/5.png">
<p>安装时会考虑 app 大小的用户这样做的原因 (Google 内部安卓用户调查)</p>
<p>我们可以看到，这些市场偏好非常显著。比如，新兴市场（如中东、非洲和东南亚）用户下载的 APK 的平均大小，<strong>是发达市场（如美国和西欧）的四分之一</strong>。</p>
<img src="/2017/12/14/20171214-shrinking-apks-growing-installs/6.png">
<p>APK 大小中位数，根据下载量加权，按市场分类。绿色 = 更大的中位数 APK 大小，红色 = 更小的 中位数 APK 大小（Google 内部数据）。</p>
<p>研究下载转化率数据，就可以发现新兴市场（如印度和巴西）和发达市场（如日本、美国和德国）相比，在面对越来越大的 APK 时会有不同的反应。</p>
<img src="/2017/12/14/20171214-shrinking-apks-growing-installs/7.png">
<p>APK 每缩小 10MB 对应下载转化率的增加，按市场分类（Google 内部数据）。</p>
<p>从上图中，我们可以看到 APK 缩小 10MB，在印度和巴西造成的影响会比德国、美国和日本更大。从 APK 中移除 10MB 内容，在新兴市场中对应着 <strong>下载转化率 2.5% 的增长</strong>。</p>
<p>让我们把实际的数字填入下载转化率的增长中：如果你的 app 在印度每个月有 10000 下载量，转化率 20%，缩小 10MB 可以使得下载量每月增加 1140 左右。</p>
<p>最后，当把非游戏的 app 和游戏比较时，我们可以在下载转化率和 APK 大小之间看到类似的关系。但是，对于超过 500MB 的游戏而言，用户们对于 APK 大小的微小变化更不敏感。对于 500-3000MB 的游戏而言，APK 每缩小 200MB，下载转化率只增加 1%。</p>
<h3 id="那么，我是否应该缩小-APK？如果应该，该怎么做？"><a href="#那么，我是否应该缩小-APK？如果应该，该怎么做？" class="headerlink" title="那么，我是否应该缩小 APK？如果应该，该怎么做？"></a><strong>那么，我是否应该缩小 APK？如果应该，该怎么做？</strong></h3><p>根据以上数据很容易看出，对于全世界人民来说 APK 大小都是很重要的。</p>
<p>“这很重要，” 你说，“但是我具体可以如何缩小 APK 呢？” 我很高兴你这样问了！缩小 APK 有以下几个入门要点：</p>
<ul>
<li><p><a href="https://developer.android.com/topic/performance/reduce-apk-size.html" target="_blank" rel="noopener"><strong>缩小 APK</strong></a>安卓开发者网站上的入门教材，它包含了移除不使用的资源和压缩图片文件。</p>
</li>
<li><p><a href="https://developer.android.com/develop/quality-guidelines/building-for-billions.html" target="_blank" rel="noopener"><strong>Building for Billions 指南</strong></a>, 在安卓开发者网站上，它讨论了缩小 APK，以及其它针对新兴市场的措施。</p>
</li>
<li><a href="https://medium.com/googleplaydev/how-to-optimize-your-android-app-for-emerging-markets-7124c4180fc" target="_blank" rel="noopener"><strong>如何针对新兴市场优化你的应用</strong></a>, 我们团队的另一篇 medium 文章。针对新兴市场，通过三个 app 去分析优化带来的好处。</li>
</ul>
<p>至于其他的针对新兴市场的考虑，可以去 Google Play 的 <a href="https://developer.android.com/topic/billions/index.html" target="_blank" rel="noopener">Building for Billions</a> 网站上寻找指导。</p>
<p>我花很多篇幅讨论了在新兴市场中缩小 APK 的好处。还有一个另外的缩小 APK 的原因，<br>这就是 Android Instant App 要求更小的 APK。Instant App 允许安卓用户不经过安装直接使用，是另一种让你的用户发现你的 app 的方式。关于开始使用 <a href="https://developer.android.com/topic/instant-apps/index.html" target="_blank" rel="noopener">Android Instant App</a>，你可以在这里找到更多信息。你也可以学习更多 <a href="https://android-developers.googleblog.com/2017/08/android-instant-apps-best-practices-for.html" target="_blank" rel="noopener">管理下载内容大小的最佳实践</a>。</p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/06/20171206-android-binder-theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="corresponding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corresponding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/06/20171206-android-binder-theory/" itemprop="url">浅谈Binder通信原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-06T19:48:09+08:00">
                2017-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <img src="/2017/12/06/20171206-android-binder-theory/banner.jpg" title="怀念夏日">
<h1 id="主要成员"><a href="#主要成员" class="headerlink" title="主要成员"></a>主要成员</h1><p>我们先来梳理下Binder通信的几个重要的成员：<br>1.Binder驱动<br>2.应用<br>3.系统服务<br>4.Binder<br>其中应用和系统服务处于不同的进程，由靠Binder驱动进行信息交互。</p>
<p>在网购如此发达的现在，人人都清楚淘宝上的聊天流程。<br>在这个过程中，也有对应的部分：<br>1.淘宝<br>2.用户<br>3.店家<br>4.聊天窗口</p>
<p>注：真实的淘宝通信系统肯定有所不同，这里仅提取与Binder通信相近之处。<br>再注：本来想举微信聊天的例子，但是微信聊天中客户端和服务端的属性没那么明显，所以选择淘宝聊天流程。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">应用和系统服务处于不同进程              用户没在商家身边</span><br><span class="line">应用无法直接调用系统服务中函数          用户直接和商家口头对话</span><br><span class="line">应用需要通过<span class="keyword">Binder驱动去与系统服务通信 </span> 用户需要通过淘宝去和店家联系</span><br><span class="line"><span class="keyword">Binder驱动中管理各个Binder </span>             淘宝管理用户和商家的“聊天窗口”对象</span><br><span class="line">应用可以访问到指定地址                  用户可以访问到指定“聊天窗口”</span><br><span class="line">系统服务也可以访问到同一个地址          商家可以访问到同一个“聊天窗口”  </span><br><span class="line">应用和系统服务都监听这个地址中内容变化  用户和商家都关注这个“聊天窗口”，看到对方发信息过来，处理后回复</span><br></pre></td></tr></table></figure>
<h2 id="聊天窗口"><a href="#聊天窗口" class="headerlink" title="聊天窗口"></a>聊天窗口</h2><p>在用户和商家通信过程中，什么东西最重要呢？其实就是“聊天窗口”。<br>假设我们设计一个聊天系统，“聊天窗口”会有哪些重要的属性？<br>1.它是一个对象；<br>2.淘宝系统内部有一个地址k可以访问到它；<br>3.一端是用户，可以通过地址c访问到它；<br>4.另一端是商家，可以通过地址s访问到它。</p>
<p>同时也要需要解决很多问题，比如：<br>1.如何让用户联系到商家；<br>2.一个用户需要同事联系多个商家;<br>2.一个商家需要同时服务多个用户；<br>3.会不会有人把自己伪造成其他人等等。</p>
<h2 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h2><p>与“聊天窗口”类似，Binder也有对应的属性：<br>1.它是一个对象；<br>2.Binder驱动有一个地址k可以访问到它；<br>3.一端是应用，可以通过地址c访问到它；<br>4.另一端是系统服务，可以通过地址s访问到它。</p>
<p>同样也需要解决很多问题，比如：<br>1.如何让应用联系到系统服务；<br>2.一个应用需要同事联系多个系统服务;<br>2.一个系统服务需要同时服务多个应用；<br>3.会不会有应用把自己伪造成其他应用等等。</p>
<h1 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h1><p>让我们看看，用户如何联系到商家：</p>
<img src="/2017/12/06/20171206-android-binder-theory/binder_associate_taobao.png" title="淘宝聊天流程图">
<p>同样在Binder中，也有一套这样的流程：</p>
<img src="/2017/12/06/20171206-android-binder-theory/binder_associate.png" title="建立Binder流程图">
<p>这张图片清晰表述了整个流程<br>1.打开Binder驱动；<br>2.将系统服务中地址s和Binder驱动中地址k指向同一地址；<br>3.将应用地址c和Binder驱动中地址k指向同一地址。<br>整个过程结束后，应用中地址c和系统服务中地址s也指向同一地址。这样两个不同的进程就关联成功了。</p>
<h1 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h1><p>其中有一个重要的问题，应用如何找到Binder驱动中的地址k？<br>在每次Android重启后，Binder驱动中地址k都不相同，应该怎么办？</p>
<p>怎么解决这个问题呢？<br>首先想到的方法，每次都记录下这些服务，下次启动时从备份文件中读取。<br>这个方法看上去很干脆利落，但是有一个风险。<br>如果上次服务发生异常，备份文件中也记录错误的数据，那这个手机就完了，永远无法启动。</p>
<p>需要改变下策略，希望每次Android系统重启时，这些系统服务都是新生成的。<br>这些系统服务启动时没有历史包袱一身轻松，然后愉快的注册到服务管理中心中。<br>应用只需要向服务管理中心查询服务名，就可以获取到地址k。</p>
<p>在Binder通信，这个服务管理中心就是ServiceManager，它管理所有的服务。<br>主要完成这两项任务：<br>1.所有的系统服务启动时，需要把服务名字和服务记录到ServiceManager中；<br>2.所有的应用使用指定系统服务前，先根据服务名称去向ServiceManager索要服务。</p>
<p>注：上面步骤中，按照C/S架构中划分：<br>1.系统服务是客户端，ServiceManager是服务端；<br>2.应用是客户端，ServiceManager是服务端。</p>
<p>我们看下Binder通信流程图：<br><img src="/2017/12/06/20171206-android-binder-theory/binder_simple.png" title="Binder简略流程图"></p>
<p>再加入Binder驱动元素:<br><img src="/2017/12/06/20171206-android-binder-theory/binder_full.png" title="Binder完整流程图"></p>
<p>回到我们的例子，淘宝也有一个ServiceManager的角色，就是店铺黄页。<br>店铺黄页管理所有的店铺，也完成两项任务：<br>1.每个商家上线后都会去淘宝黄页注册，比如Nike店铺注册Nike；<br>2.用户去淘宝黄页询问Nike的商家，获取聊天窗口中店铺的地址。</p>
<p>这时细心的读者会发现一个问题，ServiceManager呢，这些系统服务和应用怎么找到它呢？<br>为了解决这个问题，Android系统不得不做例外处理：<br>1.在Android启动后，ServiceManager第一个初始化；<br>2.将自己编号设为0。<br>之后，无论是应用或者系统服务，都可以通过编码0访问到ServiceManager。</p>
<hr>
<p>后记：在上大学时去图书馆随便翻书看过到多米尼克，感慨这个世界群星璀璨，有各种天才。<br>他发明的多米尼克训练法，告知人们需要用串联、转化、联想等等法则去记忆。<br>在学习Android底层中，有太多的对象和函数，如果能将其中主要流程和真实生活产生对应，会加速学习过程，而且印象深刻。</p>
<img src="/2017/12/06/20171206-android-binder-theory/DominicOBrien.jpg" title="Dominic O" alt="Brien">
<p>多米尼克·奥布莱恩，1957年8月10出生于英国。1991年，他参加了由“世界大脑先生”托尼·布赞发起的第一届世界记忆锦标赛，凭其独创的“多米尼克记忆系统”，38秒记住一副扑克牌的顺序，30分钟记住2385个随机产生的数字，1个小时记住110种元素的原子序数、符号、类别和精确到4位小数的原子量，一时技惊四座，横扫所有对手，获得第一届世界记忆锦标赛的总冠军。此后十余年间，他先后获得8次世界记忆冠军，几乎打破所有记忆领域的世界纪录，成为举世公认的“世界首席记忆大师”。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/28/20171128-android-initiate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="corresponding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corresponding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/28/20171128-android-initiate/" itemprop="url">追溯Android的根源</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-28T19:33:32+08:00">
                2017-11-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <img src="/2017/11/28/20171128-android-initiate/android-initiate_head.jpg" title="创世纪">
<p>某日进去一小区被保安拦住，被问了三个哲学问题：<br>“你是谁？”<br>“你从哪里来？”<br>“你要到哪里去？”<br>于是我陷入了深深的沉思。</p>
<p>同样，学习Android也有三个终极问题：<br>什么是Android？<br>Android世界的起源？<br>Android中APP是怎么运行的？</p>
<p>对于第一个问题，大家都能很快的回答出来。简单来说，Android是一种基于Linux，主要用于移动设备的操作系统。<br>第三个问题这样回答：APP的屏幕显示、输入事件获取、视频、音频等各个功能，在Android底层都有其对应的系统服务。<br>当然其中涉及到ActivityManagerService，WindowManagerService等等，后续有空会展开分析。<br>今天，我们来好好地看下第二个问题，Android系统是如何启动的，探讨下Android系统的起源。</p>
<hr>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><h2 id="main"><a href="#main" class="headerlink" title="main()"></a>main()</h2><p>就像我们编写的第一行代码helloworld一样，main()是helloworld世界的入口。<br>在Android中，main()也是Android世界的第一个入口，这个入口的位置在system\core\init\init.cpp。</p>
<p>main()主要工作：<br>    1.参数校验<br>    2.挂载一些设备，设置权限（与传统Linux程序相同）<br>    3.初始化环境<br>    4.LoadBootScripts()加载待启动项<br>    5.处理待启动项</p>
<h2 id="LoadBootScripts"><a href="#LoadBootScripts" class="headerlink" title="LoadBootScripts()"></a>LoadBootScripts()</h2><p>作用就是，加载引导的脚本init.rc，所有开机需要启动的配置读写在这里面。<br>像Android这样完善而又庞大的系统，在开机时肯定要启动有无数的服务。<br>如果全部都写到函数中，想必会变成硬编码，不方便于配置，所以这里用脚本方式配置启动内容。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadBootScripts</span><span class="params">(ActionManager&amp; action_manager, ServiceList&amp; service_list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成解析器</span></span><br><span class="line">    Parser parser = CreateParser(action_manager, service_list);</span><br><span class="line">    <span class="comment">// 解析文件内容后，放入action_manager和service_list中</span></span><br><span class="line">    parser.ParseConfig(<span class="string">"/init.rc"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="init-rc"><a href="#init-rc" class="headerlink" title="init.rc"></a>init.rc</h2><p>该文件放在system\core\rootdir目录下<br>节选下其中重要的片段<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line">    class main</span><br><span class="line">    priority -20</span><br><span class="line">   <span class="built_in"> user </span>root</span><br><span class="line">   <span class="built_in"> group </span>root readproc</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    onrestart write /sys/android_power/request_state wake</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    onrestart restart wificond</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br></pre></td></tr></table></figure></p>
<p>这段代码表示：启动名为zygote的Service。zygote翻译过来是“受精卵”，可以孕育出新生命。<br>在Android中，zygote也是万物的起源。<br>这段代码清晰的指出了Zygote的代码入口：app_process。</p>
<h2 id="app-process"><a href="#app-process" class="headerlink" title="app_process"></a>app_process</h2><p>上面同样表示app_process是在目录/system/bin/中，不过因为这应该是软链接后的位置，<br>真实的位置在frameworks\base\cmds\app_process\App_main.cpp，而且入口也是main()。<br>这里截取其中的重要代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里有两个变量去控制新进程的诞生</span></span><br><span class="line">    <span class="keyword">bool</span> zygote = <span class="literal">false</span>;                <span class="comment">// 是否为zygote进程</span></span><br><span class="line">    <span class="keyword">bool</span> startSystemServer = <span class="literal">false</span>;     <span class="comment">// 是否启动系统服务，例如ActivityManagerService等</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; argc) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--zygote"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            zygote = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--start-system-server"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            startSystemServer = <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按照之前的入参--zygote --start-system-server分析，发现zygote和startSystemServer都被设置为true</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;   </span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args, zygote);  <span class="comment">// 终于接近zygote真实本体了！</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里看下runtime，是AppRuntime类。我们赶紧去寻找下它的start方法吧。<br>发现AppRuntime继承于AndroidRuntime，AndroidRuntime中提供start()方法</p>
<h2 id="AndroidRuntime"><a href="#AndroidRuntime" class="headerlink" title="AndroidRuntime"></a>AndroidRuntime</h2><p>位于frameworks\base\core\jni\AndroidRuntime.cpp中<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AndroidRuntime::start(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 开启virtual machine，这里env是JNIEnv*类型，指向整个Android的JNI世界</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    startVm(&amp;mJavaVM, &amp;env, zygote);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 给虚拟机注册JNI的函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    startReg(env);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 调用JNI static方法，启动zygote</span></span><br><span class="line"><span class="comment">    * 这里startClass是com.android.internal.os.ZygoteInit类</span></span><br><span class="line"><span class="comment">    * startMeth是startClass中的main()方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="startVm"><a href="#startVm" class="headerlink" title="startVm()"></a>startVm()</h3><p>这个函数有一超级长的check，最关键是最后一句JNI_CreateJavaVM(pJavaVM, pEnv, &amp;initArgs);<br>完成这个函数后，VM正式创建成功，后续可以开始通过JNI对native底层代码进行调用了。</p>
<h3 id="startReg"><a href="#startReg" class="headerlink" title="startReg()"></a>startReg()</h3><p>这个函数中，最重要的是register_jni_procs(gRegJNI, NELEM(gRegJNI), env)<br>其中gRegJNI表示待注册的JNI函数，截取一段给大家看看<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> RegJNIRec gRegJNI[] = &#123;</span><br><span class="line">    REG_JNI(register_android_os_Process),</span><br><span class="line">    REG_JNI(register_android_os_SystemProperties),</span><br><span class="line">    REG_JNI(register_android_os_Binder),</span><br><span class="line">    REG_JNI(register_android_os_Parcel),</span><br></pre></td></tr></table></figure></p>
<p>发现原来Parcel、Binder等等Android独有的特性都在此处被注册，后面就可以通过JNI方式直接调用。</p>
<h3 id="env-gt-CallStaticVoidMethod"><a href="#env-gt-CallStaticVoidMethod" class="headerlink" title="env-&gt;CallStaticVoidMethod"></a>env-&gt;CallStaticVoidMethod</h3><p>根据这个函数的入参，可以得知最后调用com.android.internal.os.ZygoteInit的main()函数。<br>从类名上可以推测出，这负责zygote的生成。</p>
<h2 id="zygoteInit-main"><a href="#zygoteInit-main" class="headerlink" title="zygoteInit.main()"></a>zygoteInit.main()</h2><p>对应的文件为frameworks\base\core\java\com\android\internal\os\ZygoteInit.java<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> argv[]) &#123;</span><br><span class="line">    <span class="comment">// 注册server socket，这里采用socket方式和其他进程通信</span></span><br><span class="line">    zygoteServer.registerServerSocket(socketName);</span><br><span class="line">    <span class="comment">// 加载classes,opengl,textsource等各种资源</span></span><br><span class="line">    preload(bootTimingsTraceLog);</span><br><span class="line">    <span class="comment">// 开启新进程，用以启动system server</span></span><br><span class="line">    <span class="built_in">if</span> (startSystemServer) &#123;</span><br><span class="line">        Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line">        r.<span class="built_in">run</span>();</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化zygote</span></span><br><span class="line">    caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">    caller.<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>说了这么多，大家一定被绕晕了吧，这里整理一张流程图，大家可以对着看。<br><img src="/2017/11/28/20171128-android-initiate/android_initiate.png" title="Android启动流程图"></p>
<p>这里走向两个分支，我们接下去也分开去介绍zygote和System server初始化。</p>
<h1 id="zygote"><a href="#zygote" class="headerlink" title="zygote"></a>zygote</h1><p>zygote，这是一个平凡而又伟大的进程，以后Android的所有进程都由他诞生。<br>我们继续来看下zygoteInit.main()中走向zygote分支的流程，后续调用zygoteServer.runSelectLoop()。</p>
<h2 id="zygoteServer-runSelectLoop"><a href="#zygoteServer-runSelectLoop" class="headerlink" title="zygoteServer.runSelectLoop()"></a>zygoteServer.runSelectLoop()</h2><p>对应的文件为frameworks\base\core\java\com\android\internal\os\zygoteServer.java<br>其主要功能是，不断接受请求并作出响应。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Runnable runSelectLoop(<span class="built_in">String</span> abiList) &#123;</span><br><span class="line">    <span class="comment">// 不断循环，接受并处理新请求</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 监听数据源</span></span><br><span class="line">        Os.poll(pollFds, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="comment">// 解析出数据源的命令</span></span><br><span class="line">            ZygoteConnection connection = peers.<span class="keyword">get</span>(i);</span><br><span class="line">            <span class="keyword">final</span> Runnable command = connection.processOneCommand(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> commond;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>zygote是采用poll的方式去监听数据源。<br>注：poll 是 Linux API 提供的复用方式。IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。<br>至此，zygote会处于runSelectLoop()的循环中，不断监听外部请求并作出响应，fork出进程。</p>
<h1 id="system-server"><a href="#system-server" class="headerlink" title="system server"></a>system server</h1><p>在android的启动过程中，我们也需要启动各种应用服务，我们来找下有他们是怎样诞生的。</p>
<h2 id="forkSystemServer"><a href="#forkSystemServer" class="headerlink" title="forkSystemServer()"></a>forkSystemServer()</h2><p>这个也在zygoteInit.main()中被调用到，上面已经有提及，这里就不重复列出了。<br>在这里发现了zygote的作用，zygote把自己的进程fork一份，用来启动各大系统服务。<br>zygote进程就像受精卵一样，慢慢分裂诞生出整个Android系统，并且在后续中，新进程的诞生也依赖与zygote的fork。<br>截取其中的重要代码<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Runnable forkSystemServer(）&#123;</span><br><span class="line">    pid = Zygote.forkSystemServer(</span><br><span class="line">                    parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                    parsedArgs.gids,</span><br><span class="line">                    parsedArgs.runtimeFlags,</span><br><span class="line">                    <span class="keyword">null</span>,</span><br><span class="line">                    parsedArgs.permittedCapabilities,</span><br><span class="line">                    parsedArgs.effectiveCapabilities);</span><br><span class="line">                    </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">handleSystemServerProcess</span><span class="params">(parsedArgs)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="handleSystemServerProcess"><a href="#handleSystemServerProcess" class="headerlink" title="handleSystemServerProcess()"></a>handleSystemServerProcess()</h2><p>handleSystemServerProcess()这个函数完成了fork后的剩余工作<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function">Runnable <span class="title">handleSystemServerProcess</span><span class="params">(ZygoteConnection.Arguments parsedArgs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加载system server dex的option</span></span><br><span class="line">    performSystemServerDexOpt(systemServerClasspath);</span><br><span class="line">    <span class="comment">// 启动system server </span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> ZygoteInit.<span class="title">zygoteInit</span><span class="params">(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ZygoteInit-zygoteInit"><a href="#ZygoteInit-zygoteInit" class="headerlink" title="ZygoteInit.zygoteInit()"></a>ZygoteInit.zygoteInit()</h2><p>从函数命名来看，这是各大应用服务的初始化地址。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="function">Runnable <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// native层的初始化system server</span></span><br><span class="line">    ZygoteInit.nativeZygoteInit();</span><br><span class="line">    <span class="comment">// 返回java层初始化system server的runnable，后续必然有run()的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> RuntimeInit.<span class="title">applicationInit</span><span class="params">(targetSdkVersion, argv, classLoader)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="RuntimeInit-applicationInit"><a href="#RuntimeInit-applicationInit" class="headerlink" title="RuntimeInit.applicationInit()"></a>RuntimeInit.applicationInit()</h2><p>越来越接近真相了，再坚持一会。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected static Runnable applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) &#123;</span><br><span class="line">    <span class="regexp">//</span> 未来app调用<span class="keyword">exit</span>()会直接退出，不会清理进程</span><br><span class="line">    nativeSetExitWithoutCleanup(true);</span><br><span class="line">    <span class="regexp">//</span> 寻找最终的类以及方法</span><br><span class="line">    return findStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="findStaticMain"><a href="#findStaticMain" class="headerlink" title="findStaticMain()"></a>findStaticMain()</h2><p>从函数命名可以看出，这回找到服务的main()函数并调用。<br>这里说明良好的说明有多重要，可以让其他开发者在阅读纯代码时就能get到函数的含义。<br>这里列下findStaticMain()的重要片段<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Runnable findStaticMain(String className, String[] argv, ClassLoader classLoader) &#123;</span><br><span class="line">    <span class="keyword">Class</span>&lt;?&gt; cl = <span class="keyword">Class</span>.forName(className, <span class="keyword">true</span>, classLoader);          <span class="comment">// 找到对应的类SystemServer</span></span><br><span class="line">    Method m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> <span class="keyword">Class</span>[] &#123; String[].<span class="keyword">class</span> &#125;);    <span class="comment">// 找到其中的main()函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MethodAndArgsCaller(m, argv);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="MethodAndArgsCaller"><a href="#MethodAndArgsCaller" class="headerlink" title="MethodAndArgsCaller"></a>MethodAndArgsCaller</h2><p>这是一个实现runnable的类，里面主要的run()就是去执行之前找到的method<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAndArgsCaller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ZygoteInit-main"><a href="#ZygoteInit-main" class="headerlink" title="ZygoteInit.main()"></a>ZygoteInit.main()</h2><p>我们继续回到ZygoteInit.main()<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> argv[]) &#123;</span><br><span class="line">    <span class="comment">// 回到最开始出发的地方，这里r</span></span><br><span class="line">    Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line">    <span class="comment">// 接下去果然是run，其中运行SystemServer.main()</span></span><br><span class="line">    <span class="built_in">if</span> (r != null) &#123;</span><br><span class="line">        r.<span class="built_in">run</span>();</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="SystemServer-main"><a href="#SystemServer-main" class="headerlink" title="SystemServer.main()"></a>SystemServer.main()</h2><p>这个函数里面就一句话，调用同一个类的run()<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">    <span class="keyword">new</span> SystemServer().<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="SystemServer-run"><a href="#SystemServer-run" class="headerlink" title="SystemServer().run()"></a>SystemServer().run()</h2><p>看来这个是SystemServer的启动地了，看下其中的关键代码<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">private</span> <span class="selector-tag">void</span> <span class="selector-tag">run</span>() &#123;</span><br><span class="line">    <span class="comment">// 准备主线程的Looper</span></span><br><span class="line">    <span class="selector-tag">Looper</span><span class="selector-class">.prepareMainLooper</span>();</span><br><span class="line">    <span class="comment">// 加载native的服务</span></span><br><span class="line">    <span class="selector-tag">System</span><span class="selector-class">.loadLibrary</span>(<span class="string">"android_servers"</span>);</span><br><span class="line">    <span class="comment">// 开启各项系统服务</span></span><br><span class="line">    <span class="selector-tag">startBootstrapServices</span>();</span><br><span class="line">    <span class="selector-tag">startCoreServices</span>();</span><br><span class="line">    <span class="selector-tag">startOtherServices</span>();</span><br><span class="line">    <span class="comment">// 开启Looper循环，不断监听事件</span></span><br><span class="line">    <span class="selector-tag">Looper</span><span class="selector-class">.loop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，system server全部启动成功，并且开启Looper循环，会不断监听外来的请求并响应。</p>
<p>这里也梳理下system server整个启动过程。<br><img src="/2017/11/28/20171128-android-initiate/android_systemserver.png" title="system server 启动流程图"></p>
<hr>
<p>我们已经清晰的梳理出Android的大致的启动流程。<br>可以结合上一篇文章《浅谈Android底层》一起看。上篇文章，在用户角度从表面慢慢推进到底层system server（包括ServiceManager、AMS、WMS等等）。再进一步，就是追溯这些zygote和system server的起源。</p>
<p>作为应用开发者，只需要完成两部：<br>1.配置AndroidManifest.xml的启动项<br>2.实现对应的Activity<br>就能完成最简单的应用。但是我始终会好奇其背后的神秘而又精密的机制。</p>
<p>我们身上始终留着追溯根源的血液。就像在遥远的古代，刀耕火种的人类在漫天星空下去追溯祖先的由来，构想了无数种文明的起源。此时，作为应用开发者，我们也在追溯Android系统的起源。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/22/20171122-touch-android-groundwork/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="corresponding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corresponding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/22/20171122-touch-android-groundwork/" itemprop="url">浅谈Android底层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-22T20:24:35+08:00">
                2017-11-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="学习的原因"><a href="#学习的原因" class="headerlink" title="学习的原因"></a>学习的原因</h1><blockquote>
<p>很多应用开发者对Android底层望而却步，主要有两个原因：<br>1.底层太难，我看不懂<br>2.学习底层知识对目前开发没有帮助</p>
</blockquote>
<h2 id="对于太难的这点"><a href="#对于太难的这点" class="headerlink" title="对于太难的这点"></a>对于太难的这点</h2><p>我觉得是因为一开始直接扑进源码里面，看到那些一长串一长串的函数，很容易看得晕头转向，恶心想吐。如果掌握合适的学习方法，会发现其实并没有这么困难。<br>我建议，在看源码前先理清Android底层的主干逻辑，再拆解出各个模块，各个击破。</p>
<h2 id="对于无帮助这点"><a href="#对于无帮助这点" class="headerlink" title="对于无帮助这点"></a>对于无帮助这点</h2><p>我觉得Android底层知识的即时回报非常小，但是长期回报是巨大的。<br>如果能熟悉Android底层的原理，当在开发中遇到一些奇奇怪怪的问题时，我们可以通过debug和查看log等方式，结合底层原理去发现蛛丝马迹，真正解决一部分烦人的小概率bug。而且熟悉android底层的设计架构，在未来做软件架构设计时，可以参考借鉴，甚至可以在此基础上设计出更棒的架构。<br>这话听上去觉得特别夸张，其实不然，有两点原因：<br>1.Android底层的架构也在不断调整和优化中，这说明目前的不是最优解；<br>2.Android更新迭代了这么多版本，需要兼容旧版本，有些地方不能完全放开去设计，需要在兼容和完全优化中做选择。</p>
<hr>
<p>作者在学习过程中，尝试按照自己的思路总结Android底层主干逻辑。肯定会有许多不足之处，希望大家多多指出。<br>由表到底，分成三层：</p>
<blockquote>
<p>1.应用程序背后：Android的各大系统服务<br>2.如何获取这些系统服务：ServiceManager<br>3.如何通信：Binder体系</p>
</blockquote>
<h1 id="应用程序背后：Android的各大系统服务"><a href="#应用程序背后：Android的各大系统服务" class="headerlink" title="应用程序背后：Android的各大系统服务"></a>应用程序背后：Android的各大系统服务</h1><p>这里首先要说明下，ActivityManagerService等各种应用服务，虽然说以Service结尾，但是这与Android四大组件Service并无关系。四大组件中的Service，主要提供需要在后台长期运行的服务（如复杂计算、下载等等）；这里的Service代表Client/Server架构中的Server。</p>
<p>Client/Server架构简称为C/S架构，也是客户端/服务器端架构。服务器端主要提供数据管理、数据共享、数据及系统维护和并发控制等，客户端程序主要完成用户的具体的业务。<br>在Android系统中，Client就是我们写的各种应用程序，Server实现页面跳转，屏幕展示等功能细节。Client向Server发出命令，Server去实现完整的功能。</p>
<blockquote>
<p>注：Client/Server架构是Server，我们说的Android系统服务是Service。虽然说都是表示“服务”，建议还是注意下拼写，方便更好区分。</p>
</blockquote>
<h2 id="我举一个简单的例子"><a href="#我举一个简单的例子" class="headerlink" title="我举一个简单的例子"></a>我举一个简单的例子</h2><blockquote>
<p>应用开发者常见的工作是，去实现一个Activity并且显示在手机屏幕上。<br>对于最简单的页面，开发者只要做三步：<br>1.AndroidManifest文件加入声明<br>2.Activity中设置setContentView<br>3.调用startActivity()去启动（发出指令，后续系统Service去实现）</p>
</blockquote>
<p>在背后辛勤工作的就是Android的各大系统服务，例如ActivityManagerService（后续简称AMS）主要管理Activity运行状态，WindowManagerService（后续简称WMS）主要负责控制手机屏幕显示内容。</p>
<h1 id="如何获取这些系统服务：ServiceManager"><a href="#如何获取这些系统服务：ServiceManager" class="headerlink" title="如何获取这些系统服务：ServiceManager"></a>如何获取这些系统服务：ServiceManager</h1><p>上一节简单的描述了下应用通过各大系统服务去完成Activity生成和屏幕显示。<br>这里就会有个问题，我们如何去获取这些服务。在应用开发中，如果我们需要使用第三方控件OkHttp，我们需要导入okhttp包，或者在gradle中写入对其的依赖，之后我们才可以调用OkHttp中的对象和方法。</p>
<p>在Android底层也是类似，其中有一个ServiceManager在统筹管理所有的服务。<br>还是采用上节说的C/S架构，应用程序是客户端，向ServiceManager服务端发起请求获取指定name的服务，要求服务端给与AMS的访问引用。<br>应用程序持有AMS的引用后，继续采用C/S架构。应用本身还是客户端，此时AMS充当服务端，处理服务端发起的各种Activitiy请求。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_01.png" title="Activity&AMS&WMS">
<p>这个时候就继续思考一步，AMS、WMS这些系统服务如何和ServiceManager建立联系的呢？<br>这是在Android手机开机时，AMS、WMS会向ServiceManager注册，将自己的name和实体传给ServiceManager，ServiceManager中会有专门的数据结构（红黑树）去记录这些数据。<br>注：这里还是采用C/S架构，不过AMS变成了客户端，ServiceManager变成服务端。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_02.png" title="AMS&ServerManager&APP">
<p>再再深入一步，我们需要通过ServiceManager获取其他服务，那我们怎么获取ServiceManager呢？<br>这里ServiceManager充当大管家的角色，是在开机时最先被创造的服务，并且被赋予0的代号。所有的服务都要先请示ServiceManager。<br>注：匿名服务除外，匿名服务不需要注册在ServiceManager。当前连接的服务直接传递匿名服务给应用。<br>后续启动的服务都可以根据0去找到ServiceManager，并且把自己注册进去。<br>注：这里还是采用C/S架构，不过AMS变成了客户端，ServiceManager变成服务端。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_03.png" title="AMS&system">
<p>至此我们把获取系统服务，从表到里分析了一遍。我们再换一个维度，以时间发展表述下。<br>注：学习的时候要时刻记住，所有的对象都不是直接持有，需要通过各种请求获取后才持有。<br>再注：这里的持有不一定是持有实体，可能是种引用。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_04.png" title="AMS&ServerManager&system">
<h1 id="如何通信：Binder体系"><a href="#如何通信：Binder体系" class="headerlink" title="如何通信：Binder体系"></a>如何通信：Binder体系</h1><p>上面我们了解了系统服务的作用和如何获取系统服务，还有一个更加基础的问题，应用如何和这些系统服务通信。</p>
<blockquote>
<p>在Android中，各个应用和各个服务处于不同的进程。就不能像进程内编程一样直接调用其他类的函数，需要进程间的通信（IPC：Inter-Process Communication）<br>这里Android采用Binder方式。</p>
</blockquote>
<p>这里思考下，Linux IPC常见的有pipe、socket、共享内存等等，为什么最后Android会选择Binder呢？<br>Android之间有大量的跨进程通信，对性能、安全性、易用性要求都很高，综合考虑后选择了Binder方式。</p>
<h2 id="继续问，Binder的性能优势？"><a href="#继续问，Binder的性能优势？" class="headerlink" title="继续问，Binder的性能优势？"></a>继续问，Binder的性能优势？</h2><p>socket主要用于网络通信，以TCP/IP作为基础，需要分包、重组等工作，所以效率递比较底下。<br>注：Android有采用Unix Domain Socket(UDS)，针对进程间通信优化。在Android中也有使用，这里暂不讨论。</p>
<p>pipe采用消息转发机制，需要两次拷贝。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_05.png" title="pipe">
<p>Binder在数据传输过程中，只需要一次拷贝。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_06.png" title="Binder">
<p>经过上述操作后，服务端地址s和客户端地址c指向同一块内存。<br>服务端想与客户端通信时，就将本地内容拷贝到地址s中，客户端在同时监听地址c中的内存变化，及时获取新信息。</p>
<h2 id="Binder的安全性优势？"><a href="#Binder的安全性优势？" class="headerlink" title="Binder的安全性优势？"></a>Binder的安全性优势？</h2><p>一般的Linux IPC在通信时，请求方会发送user id(uid)和process id(pid)，服务方后根据此去检查请求方的权限，判断后续是否给与服务。<br>看上去特别安全，但是根源上出现了问题，uid和pid是请求方添加的。这意味着，请求方A可以修改uid和pid，设置成B一样。服务端是没有办法识别出来，这样安全性就无法保障了。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_07.png" title="传统IPC">
<p>Binder优化了uid和pid机制，不再由请求方自己添加，而是由内核自动添加。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_08.png" title="Binder安全性">
<h2 id="Binder的易用性优势？"><a href="#Binder的易用性优势？" class="headerlink" title="Binder的易用性优势？"></a>Binder的易用性优势？</h2><p>采用C/S架构，应用和服务分离，逻辑清晰。<br>应用持有一个服务的引用，向该引用发起各种请求，引用内部在通过Binder的细节传输给正式的服务，应用开发者不需要管通信的细节。反之，像Linux IPC的共享内存，虽然不需要拷贝，性能特别高。但是使用起来特别复杂，应用开发者需要控制管理服务的内存。</p>
<p>至此，简单的讲述下了《Android的各大系统服务》，《如何获取这些系统服务：ServiceManager》，《如何通信：Binder体系》。当然，本篇只是描述下系统服务的最表层，背后还有许许多多的代码细节和设计者巧妙构思，后续出相关的文章和大家展示。</p>
<blockquote>
<p>里面出现最多的字样就是C/S架构，大家在学习中牢记这个架构，Android底层所有的细节都围绕这个展开。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="corresponding" />
            
              <p class="site-author-name" itemprop="name">corresponding</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/corresponding" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-globe"></i>GitHub</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">corresponding</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
