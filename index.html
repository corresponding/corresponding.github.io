<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="corresponding">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="corresponding">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="corresponding">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>corresponding</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">corresponding</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/06/20171206-android-binder-theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="corresponding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corresponding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/06/20171206-android-binder-theory/" itemprop="url">浅谈Binder通信原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-06T19:48:09+08:00">
                2017-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <img src="/2017/12/06/20171206-android-binder-theory/banner.jpg" title="怀念夏日">
<p>我们先来梳理下Binder通信的三个重要的组成部分：<br>1.Binder驱动程序<br>2.Binder客户端<br>3.Binder服务端<br>其中客户端和服务端处于不同的进程，由靠Binder驱动进行信息交互。</p>
<p>在网购如此发达的现在，人人都清楚淘宝上的购物流程。<br>在这个过程中，也有三个重要的部分：<br>1.淘宝<br>2.用户<br>3.店家<br>分别与Binder通信中的三项一一对应。<br>注：真实的淘宝通信系统肯定有所不同，这里仅提取与Binder通信相近之处。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">客户端和服务端处于不同进程              用户没在商家身边</span><br><span class="line">客户端无法直接调用服务端中函数          用户不能像现实生活中一样，直接和商家对话</span><br><span class="line">客户端需要通过<span class="keyword">Binder驱动去与服务端通信 </span> 用户需要通过淘宝去和店家联系</span><br><span class="line"><span class="keyword">Binder驱动中管理各个Binder </span>             淘宝管理用户和商家的“聊天窗口”对象</span><br><span class="line">客户端可以访问到指定地址                用户可以访问到指定“聊天窗口”</span><br><span class="line">服务端也可以访问到同一个地址            商家可以访问到同一个“聊天窗口”  </span><br><span class="line">客户端和服务端都监听这个地址中内容变化  用户和商家都关注这个“聊天窗口”，时刻对对方发过来话做出回应</span><br></pre></td></tr></table></figure>
<p>在用户和商家通信过程中，什么东西最重要呢？其实就是“聊天窗口”。<br>作为程序员，肯定知道这个不单单是一个窗口，背后需要有淘宝后台数据中心去管理整个聊天过程。<br>比如：如何让用户联系到商家，一个商家可能需要同时服务多个用户，会不会有人把自己伪造成其他人等等。</p>
<p>回到Binder通信中，我们可以把Binder理解成一个“聊天窗口”的对象，客户端和服务端通过Binder进行通信。<br>同时Binder驱动中管理着这些Binder，统筹着合理的资源。对应网购的例子，<br>比如：如何让客户端关联到服务端，一个服务端可能需要同时服务多个客户端，会不会有客户端把伪造自己窃取他人机密。</p>
<hr>
<p>先来解决第一个问题吧，如何让用户联系到商家：</p>
<img src="/2017/12/06/20171206-android-binder-theory/binder_associate_taobao.png" title="淘宝聊天流程图">
<p>同样在Binder中，也有一套这样的流程：</p>
<img src="/2017/12/06/20171206-android-binder-theory/binder_associate.png" title="建立Binder流程图">
<p>这张图片清晰表述了整个流程<br>1.打开Binder驱动；<br>2.将客户端中地址c和Binder驱动中地址k指向同一地址；<br>3.将服务端中地址s和Binder驱动中地址k指向同一地址。<br>整个过程结束后，客户端中地址c和服务端中地址s也指向同一地址。这样两个不同的进程就关联成功了。</p>
<h1 id="binder-open"><a href="#binder-open" class="headerlink" title="binder_open()"></a>binder_open()</h1><p>执行这个操作的函数是binder_open()，位于native\cmd\servicemanager\binder.c<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span></span> *binder_open(<span class="keyword">const</span> <span class="built_in">char</span>* driver, size_t mapsize) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span></span> *bs  = malloc(<span class="keyword">sizeof</span>(*bs));</span><br><span class="line">    </span><br><span class="line">    bs-&gt;fd = open(driver, O_RDWR | O_CLOEXEC);</span><br><span class="line">    bs-&gt;mapsize = mapsize;</span><br><span class="line">    bs-&gt;mapped = mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的入参driver是”/dev/binder”字符串, 我们会打开这个文件。</p>
<p>我们先来看下binder_state这个数据结构<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;             <span class="comment">// 指向文件地址"/dev/binder"</span></span><br><span class="line">    <span class="keyword">void</span> *mapped;       <span class="comment">// 映射内存的地址</span></span><br><span class="line">    <span class="keyword">size_t</span> mapsize;     <span class="comment">// 大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>它保存着binder的相对应设备文件的信息，其内部的三个信息，分别在binder_open()函数中被赋值。</p>
<h1 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h1><p>这个过程就类比于，淘宝启动聊天窗口。这里面有三个重要步骤：<br>1.新建聊天窗口对象，还未初始化；<br>2.告诉外部它的地址，后续通过这个地址访问它；<br>3.淘宝内部记录它的地址，后续可以用来管理。</p>
<p>抽象化后，可以理解成这三步：<br>1.新建什么对象；<br>2.后续外部怎么访问它；<br>3.后续内部怎么访问它。<br>这是绝大多数初始化的核心步骤，理解这几步后再去看相关的代码事半功倍。</p>
<p>Binder通信中也分成这三步：<br>1.新建binder_proc，还未初始化；<br>2.后续外部将通过filp访问binder_proc；<br>3.内部记录nodes、refs_by_desc、refs_by_node，后续可以访问。</p>
<p>其对应于另外的一个binder_open()函数，在kernel\common\drivers\android\Binder.c中<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> int binder_open(<span class="class"><span class="keyword">struct</span> <span class="title">inode</span></span> *nodp, <span class="class"><span class="keyword">struct</span> <span class="title">file</span></span> *filp) &#123;</span><br><span class="line">    <span class="comment">// 1.初始化binder_proc</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span></span> *<span class="keyword">proc</span> = kzalloc(<span class="keyword">sizeof</span>(*<span class="keyword">proc</span>), GFP_KERNEL);</span><br><span class="line">	<span class="comment">// 1.1.设定任务信息</span></span><br><span class="line">	<span class="keyword">proc</span>-&gt;tsk = current-&gt;group_leader;</span><br><span class="line">	<span class="comment">// 1.2.初始化todo双向链表</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;<span class="keyword">proc</span>-&gt;todo);</span><br><span class="line">	<span class="comment">// 1.3.设定优先级</span></span><br><span class="line">	<span class="keyword">proc</span>-&gt;default_priority.sched_policy = current-&gt;policy;</span><br><span class="line">	<span class="keyword">proc</span>-&gt;default_priority.prio = current-&gt;normal_prio;</span><br><span class="line">    <span class="comment">// 1.4.生成设备context信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span></span> *binder_dev = container_of(filp-&gt;private_data, <span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span></span>, miscdev);</span><br><span class="line">	<span class="keyword">proc</span>-&gt;context = &amp;binder_dev-&gt;context;</span><br><span class="line">	binder_alloc_init(&amp;<span class="keyword">proc</span>-&gt;alloc);</span><br><span class="line">    <span class="comment">// 1.5.其他初始化</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 2.将binder_proc记录在filp中，后续外部将通过filp访问binder_proc</span></span><br><span class="line">	filp-&gt;private_data = <span class="keyword">proc</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们先来看下本次记录的对象：<br>1.binder_proc是Binder进程的上下文结构，每一个进程在Binder驱动中有一个对应的对象；<br>2.node是Binder的实体，在Binder驱动中proc_node就表示一个服务端；<br>3.refs是Binder的引用，在Binder驱动中proc_refs就表示一个客户端。</p>
<p>服务端和客户端是相对的概念。<br>例如应用与ActivityManagerService交互时，应用是客户端，ActivityManagerService是服务端。<br>当ActivityManagerService与ServiceManager交互时，ActivityManagerService是客户端，ServiceManager是服务端。</p>
<p>一个binder_proc对应于一个进程，其中可能有多个服务端和客户端。<br>在binder_proc的数据中，有对应的node和ref的集合，在里面以树和队列形式存在。</p>
<p>我们来看下binder_proc中的主要数据<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span>                <span class="comment">// 任务信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">todo</span>;</span>                  <span class="comment">// todo事件集合，这是一个双向链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> *<span class="title">context</span>;</span>         <span class="comment">// context信息</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> wait;                 <span class="comment">// 等待队列</span></span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">threads</span>;</span>                 <span class="comment">// 线程的树结构</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">nodes</span>;</span>                   <span class="comment">// proc_node的树结构</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_desc</span>;</span>            <span class="comment">// proc_ref的树结构，以desc作为索引</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_node</span>;</span>            <span class="comment">// proc_ref的树结构，以node作为索引</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们重新回到淘宝的例子，并且加以展开。<br>商家这方面：<br>1.一个商家是一个进程，在Binder驱动中对应一个binder_proc；<br>2.一个商家有售前客服和售后客服，分别对应两个线程，在Binder驱动中对应两个node，存储在nodes中；<br>3.售前客服和售后客服可以直接对话，就像同一进程内直接通信一样，不需要借助于Binder驱动。</p>
<p>用户这方面：<br>这里我们把用户变成用户家庭，这样会更加形象写。<br>1.一个用户家庭是一个进程，在Binder驱动中对应一个其他的binder_proc；<br>2.一个用户家庭中有妈妈和儿子，分别对应两个线程，在Binder驱动中对应两个ref，存储在refs_by_desc和refs_by_node中；<br>3.妈妈和儿子也可以直接对话，就像同一进程内直接通信一样，不需要借助于Binder驱动。</p>
<p>淘宝这方面：<br>1.淘宝系统是一个Binder驱动；<br>2.淘宝系统连接无数的用户家庭和商家，每个都对应一个进程；<br>3.淘宝系统可以可以通过refs_by_desc或refs_by_node寻找到对应的用户家庭；<br>4.淘宝系统可以通过nodes找到对应的商家。</p>
<h1 id="mmap"><a href="#mmap" class="headerlink" title="mmap()"></a>mmap()</h1><p>完成open()后，我们可以通过binder_state.fd中的private_data直接访问到之前打开的Binder设备文件信息。<br>此时，我们能找到对应的Binder，不过Binder内部还是空，我们接下去要去分配空间并初始化。</p>
<p>按照老规矩，我们先明确下mmap()的作用：<br>1.在Binder驱动中分配一个真实的物理空间；<br>2.Binder驱动内部有vm_area_struct对象指向这块空间；<br>3.用户空间中可以通过binder_state指向同一块空间。<br>注：用户空间可以是服务端或者客户端，这里是服务端。</p>
<p>类比于我们的例子中哪个过程呢？<br>1.淘宝系统内部开辟一个空间，可以存放配置、聊天记录等信息；<br>2.淘宝系统内部有对象指向这个空间；<br>3.商家通过聊天窗口指向这个空间。</p>
<p>vm_area_struct数据结构是用来记录真实的物理空间。</p>
<p>我们接下来看下代码，mmap()对应binder_mmap()，在kernel\common\drivers\android\Binder.c中<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> int binder_mmap(<span class="class"><span class="keyword">struct</span> <span class="title">file</span></span> *filp, <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span></span> *vma) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span></span> *<span class="keyword">proc</span> = filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    vma-&gt;vm_flags = (vma-&gt;vm_flags | VM_DONTCOPY) &amp; ~VM_MAYWRITE;</span><br><span class="line">	vma-&gt;vm_ops = &amp;binder_vm_ops;</span><br><span class="line">	vma-&gt;vm_private_data = <span class="keyword">proc</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> binder_alloc_mmap_handler(&amp;<span class="keyword">proc</span>-&gt;alloc, vma);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们继续看binder_alloc_mmap_handler()<br>在kernel\common\drivers\android\binder_alloc.c中<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int binder_alloc_mmap_handler(struct binder_alloc *alloc, struct vm_area_struct *vma) &#123;</span><br><span class="line">    <span class="comment">// 1.配置开辟的空间</span></span><br><span class="line">	<span class="function"><span class="title">struct</span> vm_struct *area = get_vm_area(vma-&gt;</span><span class="function"><span class="title">vm_end</span> - vma-&gt;</span>vm_start, VM_IOREMAP);</span><br><span class="line">	<span class="function"><span class="title">alloc</span>-&gt;</span><span class="function"><span class="title">buffer</span> = area-&gt;</span>addr;</span><br><span class="line">	<span class="function"><span class="title">alloc</span>-&gt;</span><span class="function"><span class="title">user_buffer_offset</span> = vma-&gt;</span><span class="function"><span class="title">vm_start</span> - (uintptr_t)alloc-&gt;</span>buffer;</span><br><span class="line">	<span class="function"><span class="title">alloc</span>-&gt;</span><span class="function"><span class="title">pages</span> = kzalloc(sizeof(alloc-&gt;</span><span class="function"><span class="title">pages</span>[0]) * ((vma-&gt;</span><span class="function"><span class="title">vm_end</span> - vma-&gt;</span>vm_start) / PAGE_SIZE), GFP_KERNEL);</span><br><span class="line">	<span class="function"><span class="title">alloc</span>-&gt;</span><span class="function"><span class="title">buffer_size</span> = vma-&gt;</span><span class="function"><span class="title">vm_end</span> - vma-&gt;</span>vm_start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.真正的分配</span></span><br><span class="line">    <span class="function"><span class="title">binder_update_page_range</span>(alloc, 1, alloc-&gt;</span><span class="function"><span class="title">buffer</span>, alloc-&gt;</span>buffer + PAGE_SIZE, vma);</span><br><span class="line">	<span class="comment">// 3.关联用户空间和Binder内核空间</span></span><br><span class="line">	<span class="function"><span class="title">struct</span> binder_buffer *buffer = alloc-&gt;</span>buffer;</span><br><span class="line">	INIT_LIST_HEAD(&amp;<span class="function"><span class="title">alloc</span>-&gt;</span>buffers);</span><br><span class="line">	<span class="function"><span class="title">list_add</span>(&amp;buffer-&gt;</span><span class="function"><span class="title">entry</span>, &amp;alloc-&gt;</span>buffers);</span><br><span class="line">	<span class="function"><span class="title">buffer</span>-&gt;</span>free = <span class="number">1</span>;</span><br><span class="line">	binder_insert_free_buffer(alloc, buffer);</span><br><span class="line">	<span class="function"><span class="title">alloc</span>-&gt;</span><span class="function"><span class="title">free_async_space</span> = alloc-&gt;</span>buffer_size / <span class="number">2</span>;</span><br><span class="line">	<span class="function"><span class="title">alloc</span>-&gt;</span>vma = vma;</span><br><span class="line">	<span class="function"><span class="title">alloc</span>-&gt;</span><span class="function"><span class="title">vma_vm_mm</span> = vma-&gt;</span>vm_mm;</span><br><span class="line"></span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到目前为止，我们已经完成了Binder驱动分配空间，驱动中地址k，服务端地址s指向这个空间。<br>淘宝已经开启好这个聊天窗口，商家已经上线了，接下去就是用户也进入这个聊天窗口。</p>
<h1 id="客户端关联这块空间"><a href="#客户端关联这块空间" class="headerlink" title="客户端关联这块空间"></a>客户端关联这块空间</h1><p>接下去要做的就是，客户端也去关联这块空间。</p>
<p>其中最主要的一步就是要先找到Binder驱动中的地址k，这一步不详细介绍。暂时先用一个例子带过。<br>有一个淘宝黄页这样的商家，这里描述下它的特性：<br>1.淘宝黄页也是一个商家；<br>2.它主要提供查询服务；<br>3.每个商家上线后都会去淘宝黄页注册，比如Nike店铺注册Nike；<br>4.用户去淘宝黄页询问Nike的商家，获取到驱动中地址k。</p>
<p>当然淘宝官方肯定会提供黄页这样服务，我们这里先假设淘宝黄页也是一个商家提供的。<br>这里可以类比这样的情况，在二十年前，安装固定电话时大部分人会购买电话黄页，这些黄页都是第三方公司收入提供的。</p>
<p>在Binder通信中，ServiceManager充当这个淘宝黄页的角色。这些知识后续会仔细展开。</p>
<hr>
<p>后记：在上大学时去图书馆随便翻书看过到多米尼克，感慨这个世界群星璀璨，有各种天才。<br>他发明的多米尼克训练法，告知人们需要用串联、转化、联想等等法则去记忆。<br>在学习Android底层中，有太多的对象和函数，如果能将其中主要流程和真实生活产生对应，会加速学习过程，而且印象深刻。</p>
<img src="/2017/12/06/20171206-android-binder-theory/DominicOBrien.jpg" title="Dominic O" alt="Brien">
<p>多米尼克·奥布莱恩，1957年8月10出生于英国。1991年，他参加了由“世界大脑先生”托尼·布赞发起的第一届世界记忆锦标赛，凭其独创的“多米尼克记忆系统”，38秒记住一副扑克牌的顺序，30分钟记住2385个随机产生的数字，1个小时记住110种元素的原子序数、符号、类别和精确到4位小数的原子量，一时技惊四座，横扫所有对手，获得第一届世界记忆锦标赛的总冠军。此后十余年间，他先后获得8次世界记忆冠军，几乎打破所有记忆领域的世界纪录，成为举世公认的“世界首席记忆大师”。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/28/20171128-android-initiate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="corresponding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corresponding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/28/20171128-android-initiate/" itemprop="url">追溯Android的根源</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-28T19:33:32+08:00">
                2017-11-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <img src="/2017/11/28/20171128-android-initiate/android-initiate_head.jpg" title="创世纪">
<p>某日进去一小区被保安拦住，被问了三个哲学问题：<br>“你是谁？”<br>“你从哪里来？”<br>“你要到哪里去？”<br>于是我陷入了深深的沉思。</p>
<p>同样，学习Android也有三个终极问题：<br>什么是Android？<br>Android世界的起源？<br>Android中APP是怎么运行的？</p>
<p>对于第一个问题，大家都能很快的回答出来。简单来说，Android是一种基于Linux，主要用于移动设备的操作系统。<br>第三个问题这样回答：APP的屏幕显示、输入事件获取、视频、音频等各个功能，在Android底层都有其对应的系统服务。<br>当然其中涉及到ActivityManagerService，WindowManagerService等等，后续有空会展开分析。<br>今天，我们来好好地看下第二个问题，Android系统是如何启动的，探讨下Android系统的起源。</p>
<hr>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><h2 id="main"><a href="#main" class="headerlink" title="main()"></a>main()</h2><p>就像我们编写的第一行代码helloworld一样，main()是helloworld世界的入口。<br>在Android中，main()也是Android世界的第一个入口，这个入口的位置在system\core\init\init.cpp。</p>
<p>main()主要工作：<br>    1.参数校验<br>    2.挂载一些设备，设置权限（与传统Linux程序相同）<br>    3.初始化环境<br>    4.LoadBootScripts()加载待启动项<br>    5.处理待启动项</p>
<h2 id="LoadBootScripts"><a href="#LoadBootScripts" class="headerlink" title="LoadBootScripts()"></a>LoadBootScripts()</h2><p>作用就是，加载引导的脚本init.rc，所有开机需要启动的配置读写在这里面。<br>像Android这样完善而又庞大的系统，在开机时肯定要启动有无数的服务。<br>如果全部都写到函数中，想必会变成硬编码，不方便于配置，所以这里用脚本方式配置启动内容。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadBootScripts</span><span class="params">(ActionManager&amp; action_manager, ServiceList&amp; service_list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成解析器</span></span><br><span class="line">    Parser parser = CreateParser(action_manager, service_list);</span><br><span class="line">    <span class="comment">// 解析文件内容后，放入action_manager和service_list中</span></span><br><span class="line">    parser.ParseConfig(<span class="string">"/init.rc"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="init-rc"><a href="#init-rc" class="headerlink" title="init.rc"></a>init.rc</h2><p>该文件放在system\core\rootdir目录下<br>节选下其中重要的片段<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line">    class main</span><br><span class="line">    priority -20</span><br><span class="line">   <span class="built_in"> user </span>root</span><br><span class="line">   <span class="built_in"> group </span>root readproc</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    onrestart write /sys/android_power/request_state wake</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    onrestart restart wificond</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br></pre></td></tr></table></figure></p>
<p>这段代码表示：启动名为zygote的Service。zygote翻译过来是“受精卵”，可以孕育出新生命。<br>在Android中，zygote也是万物的起源。<br>这段代码清晰的指出了Zygote的代码入口：app_process。</p>
<h2 id="app-process"><a href="#app-process" class="headerlink" title="app_process"></a>app_process</h2><p>上面同样表示app_process是在目录/system/bin/中，不过因为这应该是软链接后的位置，<br>真实的位置在frameworks\base\cmds\app_process\App_main.cpp，而且入口也是main()。<br>这里截取其中的重要代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里有两个变量去控制新进程的诞生</span></span><br><span class="line">    <span class="keyword">bool</span> zygote = <span class="literal">false</span>;                <span class="comment">// 是否为zygote进程</span></span><br><span class="line">    <span class="keyword">bool</span> startSystemServer = <span class="literal">false</span>;     <span class="comment">// 是否启动系统服务，例如ActivityManagerService等</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; argc) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--zygote"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            zygote = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--start-system-server"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            startSystemServer = <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按照之前的入参--zygote --start-system-server分析，发现zygote和startSystemServer都被设置为true</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;   </span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args, zygote);  <span class="comment">// 终于接近zygote真实本体了！</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里看下runtime，是AppRuntime类。我们赶紧去寻找下它的start方法吧。<br>发现AppRuntime继承于AndroidRuntime，AndroidRuntime中提供start()方法</p>
<h2 id="AndroidRuntime"><a href="#AndroidRuntime" class="headerlink" title="AndroidRuntime"></a>AndroidRuntime</h2><p>位于frameworks\base\core\jni\AndroidRuntime.cpp中<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AndroidRuntime::start(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 开启virtual machine，这里env是JNIEnv*类型，指向整个Android的JNI世界</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    startVm(&amp;mJavaVM, &amp;env, zygote);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 给虚拟机注册JNI的函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    startReg(env);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 调用JNI static方法，启动zygote</span></span><br><span class="line"><span class="comment">    * 这里startClass是com.android.internal.os.ZygoteInit类</span></span><br><span class="line"><span class="comment">    * startMeth是startClass中的main()方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="startVm"><a href="#startVm" class="headerlink" title="startVm()"></a>startVm()</h3><p>这个函数有一超级长的check，最关键是最后一句JNI_CreateJavaVM(pJavaVM, pEnv, &amp;initArgs);<br>完成这个函数后，VM正式创建成功，后续可以开始通过JNI对native底层代码进行调用了。</p>
<h3 id="startReg"><a href="#startReg" class="headerlink" title="startReg()"></a>startReg()</h3><p>这个函数中，最重要的是register_jni_procs(gRegJNI, NELEM(gRegJNI), env)<br>其中gRegJNI表示待注册的JNI函数，截取一段给大家看看<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> RegJNIRec gRegJNI[] = &#123;</span><br><span class="line">    REG_JNI(register_android_os_Process),</span><br><span class="line">    REG_JNI(register_android_os_SystemProperties),</span><br><span class="line">    REG_JNI(register_android_os_Binder),</span><br><span class="line">    REG_JNI(register_android_os_Parcel),</span><br></pre></td></tr></table></figure></p>
<p>发现原来Parcel、Binder等等Android独有的特性都在此处被注册，后面就可以通过JNI方式直接调用。</p>
<h3 id="env-gt-CallStaticVoidMethod"><a href="#env-gt-CallStaticVoidMethod" class="headerlink" title="env-&gt;CallStaticVoidMethod"></a>env-&gt;CallStaticVoidMethod</h3><p>根据这个函数的入参，可以得知最后调用com.android.internal.os.ZygoteInit的main()函数。<br>从类名上可以推测出，这负责zygote的生成。</p>
<h2 id="zygoteInit-main"><a href="#zygoteInit-main" class="headerlink" title="zygoteInit.main()"></a>zygoteInit.main()</h2><p>对应的文件为frameworks\base\core\java\com\android\internal\os\ZygoteInit.java<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> argv[]) &#123;</span><br><span class="line">    <span class="comment">// 注册server socket，这里采用socket方式和其他进程通信</span></span><br><span class="line">    zygoteServer.registerServerSocket(socketName);</span><br><span class="line">    <span class="comment">// 加载classes,opengl,textsource等各种资源</span></span><br><span class="line">    preload(bootTimingsTraceLog);</span><br><span class="line">    <span class="comment">// 开启新进程，用以启动system server</span></span><br><span class="line">    <span class="built_in">if</span> (startSystemServer) &#123;</span><br><span class="line">        Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line">        r.<span class="built_in">run</span>();</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化zygote</span></span><br><span class="line">    caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">    caller.<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>说了这么多，大家一定被绕晕了吧，这里整理一张流程图，大家可以对着看。<br><img src="/2017/11/28/20171128-android-initiate/android_initiate.png" title="Android启动流程图"></p>
<p>这里走向两个分支，我们接下去也分开去介绍zygote和System server初始化。</p>
<h1 id="zygote"><a href="#zygote" class="headerlink" title="zygote"></a>zygote</h1><p>zygote，这是一个平凡而又伟大的进程，以后Android的所有进程都由他诞生。<br>我们继续来看下zygoteInit.main()中走向zygote分支的流程，后续调用zygoteServer.runSelectLoop()。</p>
<h2 id="zygoteServer-runSelectLoop"><a href="#zygoteServer-runSelectLoop" class="headerlink" title="zygoteServer.runSelectLoop()"></a>zygoteServer.runSelectLoop()</h2><p>对应的文件为frameworks\base\core\java\com\android\internal\os\zygoteServer.java<br>其主要功能是，不断接受请求并作出响应。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Runnable runSelectLoop(<span class="built_in">String</span> abiList) &#123;</span><br><span class="line">    <span class="comment">// 不断循环，接受并处理新请求</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 监听数据源</span></span><br><span class="line">        Os.poll(pollFds, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="comment">// 解析出数据源的命令</span></span><br><span class="line">            ZygoteConnection connection = peers.<span class="keyword">get</span>(i);</span><br><span class="line">            <span class="keyword">final</span> Runnable command = connection.processOneCommand(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> commond;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>zygote是采用poll的方式去监听数据源。<br>注：poll 是 Linux API 提供的复用方式。IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。<br>至此，zygote会处于runSelectLoop()的循环中，不断监听外部请求并作出响应，fork出进程。</p>
<h1 id="system-server"><a href="#system-server" class="headerlink" title="system server"></a>system server</h1><p>在android的启动过程中，我们也需要启动各种应用服务，我们来找下有他们是怎样诞生的。</p>
<h2 id="forkSystemServer"><a href="#forkSystemServer" class="headerlink" title="forkSystemServer()"></a>forkSystemServer()</h2><p>这个也在zygoteInit.main()中被调用到，上面已经有提及，这里就不重复列出了。<br>在这里发现了zygote的作用，zygote把自己的进程fork一份，用来启动各大系统服务。<br>zygote进程就像受精卵一样，慢慢分裂诞生出整个Android系统，并且在后续中，新进程的诞生也依赖与zygote的fork。<br>截取其中的重要代码<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Runnable forkSystemServer(）&#123;</span><br><span class="line">    pid = Zygote.forkSystemServer(</span><br><span class="line">                    parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                    parsedArgs.gids,</span><br><span class="line">                    parsedArgs.runtimeFlags,</span><br><span class="line">                    <span class="keyword">null</span>,</span><br><span class="line">                    parsedArgs.permittedCapabilities,</span><br><span class="line">                    parsedArgs.effectiveCapabilities);</span><br><span class="line">                    </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">handleSystemServerProcess</span><span class="params">(parsedArgs)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="handleSystemServerProcess"><a href="#handleSystemServerProcess" class="headerlink" title="handleSystemServerProcess()"></a>handleSystemServerProcess()</h2><p>handleSystemServerProcess()这个函数完成了fork后的剩余工作<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function">Runnable <span class="title">handleSystemServerProcess</span><span class="params">(ZygoteConnection.Arguments parsedArgs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加载system server dex的option</span></span><br><span class="line">    performSystemServerDexOpt(systemServerClasspath);</span><br><span class="line">    <span class="comment">// 启动system server </span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> ZygoteInit.<span class="title">zygoteInit</span><span class="params">(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ZygoteInit-zygoteInit"><a href="#ZygoteInit-zygoteInit" class="headerlink" title="ZygoteInit.zygoteInit()"></a>ZygoteInit.zygoteInit()</h2><p>从函数命名来看，这是各大应用服务的初始化地址。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="function">Runnable <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// native层的初始化system server</span></span><br><span class="line">    ZygoteInit.nativeZygoteInit();</span><br><span class="line">    <span class="comment">// 返回java层初始化system server的runnable，后续必然有run()的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> RuntimeInit.<span class="title">applicationInit</span><span class="params">(targetSdkVersion, argv, classLoader)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="RuntimeInit-applicationInit"><a href="#RuntimeInit-applicationInit" class="headerlink" title="RuntimeInit.applicationInit()"></a>RuntimeInit.applicationInit()</h2><p>越来越接近真相了，再坚持一会。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected static Runnable applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) &#123;</span><br><span class="line">    <span class="regexp">//</span> 未来app调用<span class="keyword">exit</span>()会直接退出，不会清理进程</span><br><span class="line">    nativeSetExitWithoutCleanup(true);</span><br><span class="line">    <span class="regexp">//</span> 寻找最终的类以及方法</span><br><span class="line">    return findStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="findStaticMain"><a href="#findStaticMain" class="headerlink" title="findStaticMain()"></a>findStaticMain()</h2><p>从函数命名可以看出，这回找到服务的main()函数并调用。<br>这里说明良好的说明有多重要，可以让其他开发者在阅读纯代码时就能get到函数的含义。<br>这里列下findStaticMain()的重要片段<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Runnable findStaticMain(String className, String[] argv, ClassLoader classLoader) &#123;</span><br><span class="line">    <span class="keyword">Class</span>&lt;?&gt; cl = <span class="keyword">Class</span>.forName(className, <span class="keyword">true</span>, classLoader);          <span class="comment">// 找到对应的类SystemServer</span></span><br><span class="line">    Method m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> <span class="keyword">Class</span>[] &#123; String[].<span class="keyword">class</span> &#125;);    <span class="comment">// 找到其中的main()函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MethodAndArgsCaller(m, argv);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="MethodAndArgsCaller"><a href="#MethodAndArgsCaller" class="headerlink" title="MethodAndArgsCaller"></a>MethodAndArgsCaller</h2><p>这是一个实现runnable的类，里面主要的run()就是去执行之前找到的method<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAndArgsCaller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ZygoteInit-main"><a href="#ZygoteInit-main" class="headerlink" title="ZygoteInit.main()"></a>ZygoteInit.main()</h2><p>我们继续回到ZygoteInit.main()<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> argv[]) &#123;</span><br><span class="line">    <span class="comment">// 回到最开始出发的地方，这里r</span></span><br><span class="line">    Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line">    <span class="comment">// 接下去果然是run，其中运行SystemServer.main()</span></span><br><span class="line">    <span class="built_in">if</span> (r != null) &#123;</span><br><span class="line">        r.<span class="built_in">run</span>();</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="SystemServer-main"><a href="#SystemServer-main" class="headerlink" title="SystemServer.main()"></a>SystemServer.main()</h2><p>这个函数里面就一句话，调用同一个类的run()<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">    <span class="keyword">new</span> SystemServer().<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="SystemServer-run"><a href="#SystemServer-run" class="headerlink" title="SystemServer().run()"></a>SystemServer().run()</h2><p>看来这个是SystemServer的启动地了，看下其中的关键代码<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">private</span> <span class="selector-tag">void</span> <span class="selector-tag">run</span>() &#123;</span><br><span class="line">    <span class="comment">// 准备主线程的Looper</span></span><br><span class="line">    <span class="selector-tag">Looper</span><span class="selector-class">.prepareMainLooper</span>();</span><br><span class="line">    <span class="comment">// 加载native的服务</span></span><br><span class="line">    <span class="selector-tag">System</span><span class="selector-class">.loadLibrary</span>(<span class="string">"android_servers"</span>);</span><br><span class="line">    <span class="comment">// 开启各项系统服务</span></span><br><span class="line">    <span class="selector-tag">startBootstrapServices</span>();</span><br><span class="line">    <span class="selector-tag">startCoreServices</span>();</span><br><span class="line">    <span class="selector-tag">startOtherServices</span>();</span><br><span class="line">    <span class="comment">// 开启Looper循环，不断监听事件</span></span><br><span class="line">    <span class="selector-tag">Looper</span><span class="selector-class">.loop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，system server全部启动成功，并且开启Looper循环，会不断监听外来的请求并响应。</p>
<p>这里也梳理下system server整个启动过程。<br><img src="/2017/11/28/20171128-android-initiate/android_systemserver.png" title="system server 启动流程图"></p>
<hr>
<p>我们已经清晰的梳理出Android的大致的启动流程。<br>可以结合上一篇文章《浅谈Android底层》一起看。上篇文章，在用户角度从表面慢慢推进到底层system server（包括ServiceManager、AMS、WMS等等）。再进一步，就是追溯这些zygote和system server的起源。</p>
<p>作为应用开发者，只需要完成两部：<br>1.配置AndroidManifest.xml的启动项<br>2.实现对应的Activity<br>就能完成最简单的应用。但是我始终会好奇其背后的神秘而又精密的机制。</p>
<p>我们身上始终留着追溯根源的血液。就像在遥远的古代，刀耕火种的人类在漫天星空下去追溯祖先的由来，构想了无数种文明的起源。此时，作为应用开发者，我们也在追溯Android系统的起源。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/22/20171122-touch-android-groundwork/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="corresponding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corresponding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/22/20171122-touch-android-groundwork/" itemprop="url">浅谈Android底层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-22T20:24:35+08:00">
                2017-11-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="学习的原因"><a href="#学习的原因" class="headerlink" title="学习的原因"></a>学习的原因</h1><blockquote>
<p>很多应用开发者对Android底层望而却步，主要有两个原因：<br>1.底层太难，我看不懂<br>2.学习底层知识对目前开发没有帮助</p>
</blockquote>
<h2 id="对于太难的这点"><a href="#对于太难的这点" class="headerlink" title="对于太难的这点"></a>对于太难的这点</h2><p>我觉得是因为一开始直接扑进源码里面，看到那些一长串一长串的函数，很容易看得晕头转向，恶心想吐。如果掌握合适的学习方法，会发现其实并没有这么困难。<br>我建议，在看源码前先理清Android底层的主干逻辑，再拆解出各个模块，各个击破。</p>
<h2 id="对于无帮助这点"><a href="#对于无帮助这点" class="headerlink" title="对于无帮助这点"></a>对于无帮助这点</h2><p>我觉得Android底层知识的即时回报非常小，但是长期回报是巨大的。<br>如果能熟悉Android底层的原理，当在开发中遇到一些奇奇怪怪的问题时，我们可以通过debug和查看log等方式，结合底层原理去发现蛛丝马迹，真正解决一部分烦人的小概率bug。而且熟悉android底层的设计架构，在未来做软件架构设计时，可以参考借鉴，甚至可以在此基础上设计出更棒的架构。<br>这话听上去觉得特别夸张，其实不然，有两点原因：<br>1.Android底层的架构也在不断调整和优化中，这说明目前的不是最优解；<br>2.Android更新迭代了这么多版本，需要兼容旧版本，有些地方不能完全放开去设计，需要在兼容和完全优化中做选择。</p>
<hr>
<p>作者在学习过程中，尝试按照自己的思路总结Android底层主干逻辑。肯定会有许多不足之处，希望大家多多指出。<br>由表到底，分成三层：</p>
<blockquote>
<p>1.应用程序背后：Android的各大系统服务<br>2.如何获取这些系统服务：ServiceManager<br>3.如何通信：Binder体系</p>
</blockquote>
<h1 id="应用程序背后：Android的各大系统服务"><a href="#应用程序背后：Android的各大系统服务" class="headerlink" title="应用程序背后：Android的各大系统服务"></a>应用程序背后：Android的各大系统服务</h1><p>这里首先要说明下，ActivityManagerService等各种应用服务，虽然说以Service结尾，但是这与Android四大组件Service并无关系。四大组件中的Service，主要提供需要在后台长期运行的服务（如复杂计算、下载等等）；这里的Service代表Client/Server架构中的Server。</p>
<p>Client/Server架构简称为C/S架构，也是客户端/服务器端架构。服务器端主要提供数据管理、数据共享、数据及系统维护和并发控制等，客户端程序主要完成用户的具体的业务。<br>在Android系统中，Client就是我们写的各种应用程序，Server实现页面跳转，屏幕展示等功能细节。Client向Server发出命令，Server去实现完整的功能。</p>
<blockquote>
<p>注：Client/Server架构是Server，我们说的Android系统服务是Service。虽然说都是表示“服务”，建议还是注意下拼写，方便更好区分。</p>
</blockquote>
<h2 id="我举一个简单的例子"><a href="#我举一个简单的例子" class="headerlink" title="我举一个简单的例子"></a>我举一个简单的例子</h2><blockquote>
<p>应用开发者常见的工作是，去实现一个Activity并且显示在手机屏幕上。<br>对于最简单的页面，开发者只要做三步：<br>1.AndroidManifest文件加入声明<br>2.Activity中设置setContentView<br>3.调用startActivity()去启动（发出指令，后续系统Service去实现）</p>
</blockquote>
<p>在背后辛勤工作的就是Android的各大系统服务，例如ActivityManagerService（后续简称AMS）主要管理Activity运行状态，WindowManagerService（后续简称WMS）主要负责控制手机屏幕显示内容。</p>
<h1 id="如何获取这些系统服务：ServiceManager"><a href="#如何获取这些系统服务：ServiceManager" class="headerlink" title="如何获取这些系统服务：ServiceManager"></a>如何获取这些系统服务：ServiceManager</h1><p>上一节简单的描述了下应用通过各大系统服务去完成Activity生成和屏幕显示。<br>这里就会有个问题，我们如何去获取这些服务。在应用开发中，如果我们需要使用第三方控件OkHttp，我们需要导入okhttp包，或者在gradle中写入对其的依赖，之后我们才可以调用OkHttp中的对象和方法。</p>
<p>在Android底层也是类似，其中有一个ServiceManager在统筹管理所有的服务。<br>还是采用上节说的C/S架构，应用程序是客户端，向ServiceManager服务端发起请求获取指定name的服务，要求服务端给与AMS的访问引用。<br>应用程序持有AMS的引用后，继续采用C/S架构。应用本身还是客户端，此时AMS充当服务端，处理服务端发起的各种Activitiy请求。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_01.png" title="Activity&AMS&WMS">
<p>这个时候就继续思考一步，AMS、WMS这些系统服务如何和ServiceManager建立联系的呢？<br>这是在Android手机开机时，AMS、WMS会向ServiceManager注册，将自己的name和实体传给ServiceManager，ServiceManager中会有专门的数据结构（红黑树）去记录这些数据。<br>注：这里还是采用C/S架构，不过AMS变成了客户端，ServiceManager变成服务端。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_02.png" title="AMS&ServerManager&APP">
<p>再再深入一步，我们需要通过ServiceManager获取其他服务，那我们怎么获取ServiceManager呢？<br>这里ServiceManager充当大管家的角色，是在开机时最先被创造的服务，并且被赋予0的代号。所有的服务都要先请示ServiceManager。<br>注：匿名服务除外，匿名服务不需要注册在ServiceManager。当前连接的服务直接传递匿名服务给应用。<br>后续启动的服务都可以根据0去找到ServiceManager，并且把自己注册进去。<br>注：这里还是采用C/S架构，不过AMS变成了客户端，ServiceManager变成服务端。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_03.png" title="AMS&system">
<p>至此我们把获取系统服务，从表到里分析了一遍。我们再换一个维度，以时间发展表述下。<br>注：学习的时候要时刻记住，所有的对象都不是直接持有，需要通过各种请求获取后才持有。<br>再注：这里的持有不一定是持有实体，可能是种引用。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_04.png" title="AMS&ServerManager&system">
<h1 id="如何通信：Binder体系"><a href="#如何通信：Binder体系" class="headerlink" title="如何通信：Binder体系"></a>如何通信：Binder体系</h1><p>上面我们了解了系统服务的作用和如何获取系统服务，还有一个更加基础的问题，应用如何和这些系统服务通信。</p>
<blockquote>
<p>在Android中，各个应用和各个服务处于不同的进程。就不能像进程内编程一样直接调用其他类的函数，需要进程间的通信（IPC：Inter-Process Communication）<br>这里Android采用Binder方式。</p>
</blockquote>
<p>这里思考下，Linux IPC常见的有pipe、socket、共享内存等等，为什么最后Android会选择Binder呢？<br>Android之间有大量的跨进程通信，对性能、安全性、易用性要求都很高，综合考虑后选择了Binder方式。</p>
<h2 id="继续问，Binder的性能优势？"><a href="#继续问，Binder的性能优势？" class="headerlink" title="继续问，Binder的性能优势？"></a>继续问，Binder的性能优势？</h2><p>socket主要用于网络通信，以TCP/IP作为基础，需要分包、重组等工作，所以效率递比较底下。<br>注：Android有采用Unix Domain Socket(UDS)，针对进程间通信优化。在Android中也有使用，这里暂不讨论。</p>
<p>pipe采用消息转发机制，需要两次拷贝。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_05.png" title="pipe">
<p>Binder在数据传输过程中，只需要一次拷贝。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_06.png" title="Binder">
<p>经过上述操作后，服务端地址s和客户端地址c指向同一块内存。<br>服务端想与客户端通信时，就将本地内容拷贝到地址s中，客户端在同时监听地址c中的内存变化，及时获取新信息。</p>
<h2 id="Binder的安全性优势？"><a href="#Binder的安全性优势？" class="headerlink" title="Binder的安全性优势？"></a>Binder的安全性优势？</h2><p>一般的Linux IPC在通信时，请求方会发送user id(uid)和process id(pid)，服务方后根据此去检查请求方的权限，判断后续是否给与服务。<br>看上去特别安全，但是根源上出现了问题，uid和pid是请求方添加的。这意味着，请求方A可以修改uid和pid，设置成B一样。服务端是没有办法识别出来，这样安全性就无法保障了。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_07.png" title="传统IPC">
<p>Binder优化了uid和pid机制，不再由请求方自己添加，而是由内核自动添加。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_08.png" title="Binder安全性">
<h2 id="Binder的易用性优势？"><a href="#Binder的易用性优势？" class="headerlink" title="Binder的易用性优势？"></a>Binder的易用性优势？</h2><p>采用C/S架构，应用和服务分离，逻辑清晰。<br>应用持有一个服务的引用，向该引用发起各种请求，引用内部在通过Binder的细节传输给正式的服务，应用开发者不需要管通信的细节。反之，像Linux IPC的共享内存，虽然不需要拷贝，性能特别高。但是使用起来特别复杂，应用开发者需要控制管理服务的内存。</p>
<p>至此，简单的讲述下了《Android的各大系统服务》，《如何获取这些系统服务：ServiceManager》，《如何通信：Binder体系》。当然，本篇只是描述下系统服务的最表层，背后还有许许多多的代码细节和设计者巧妙构思，后续出相关的文章和大家展示。</p>
<blockquote>
<p>里面出现最多的字样就是C/S架构，大家在学习中牢记这个架构，Android底层所有的细节都围绕这个展开。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/20/20171120-defensive-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="corresponding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corresponding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/20/20171120-defensive-code/" itemprop="url">防御式编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-20T18:50:20+08:00">
                2017-11-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/coding/" itemprop="url" rel="index">
                    <span itemprop="name">coding</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在我自己的编码工作中，调bug的时间至少占总时间的50%。<br>有些时候修复一个的bug甚至会占用几天的时间，最后发现问题出在几天没加条件预防的语句，这太让人恼火了。<br><br>我总是在苦恼，为何我的程序有这么多闪退。<br>为什么就不能有一个安全的编程环境给我们，让我们这些菜鸟写的代码不闪退。</p>
<blockquote>
<p>代码世界中危机丛生，程序跑着跑着就要歇菜。</p>
</blockquote>
<p>随着发际线的慢慢后退，我开始认清一个令人感觉残酷的现实：<br>这是你的代码，你需要为其付所有责任，包括最基础的安全性检查。</p>
<blockquote>
<p>慢慢的我们需要变得保守，不能轻易相信所有的数据，需要在使用前对其检查。</p>
</blockquote>
<hr>
<h1 id="防御式编程"><a href="#防御式编程" class="headerlink" title="防御式编程"></a>防御式编程</h1><p>原则：就是对来源数据持怀疑、不信任的态度<br>对调用者含有敌意，他们可能会放入各种奇怪的未经检查的数据。<br>其中最常用的就是null的判断。</p>
<p>在面向对象的编程中，任何一个对象都初始为null（final和 static关键字声明的变量除外）<br>当然，在一般情况下，变量会在使用前被赋值。<br>当调用null对象的方法时，会抛出NullPointerException。<br>如果没有及时对Exception进行捕获，程序就会报错。</p>
<h2 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h2><p>这里有常用的两种处理方法，两者相互合作，相辅相成。</p>
<h3 id="变量的预先检查"><a href="#变量的预先检查" class="headerlink" title="变量的预先检查"></a>变量的预先检查</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span>(<span class="params">Model arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == arg) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// arg的合理性检查</span></span><br><span class="line">        arg.<span class="keyword">do</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果变量不符合要求，后续代码无法继续执行。<br>可以改成如下方式：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Model arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == arg) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arg不符合要求) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异常后处理"><a href="#异常后处理" class="headerlink" title="异常后处理"></a>异常后处理</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="keyword">func</span><span class="params">(Model arg)</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        arg.<span class="keyword">do</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="type">NullPointerException</span> e) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="type">Exception</span> e) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>合理的使用Exception，能帮助我们更好的代码分层。</p>
</blockquote>
<p>Exception它可以报错误上报给调用链的上层。<br>每个函数都有他的职责范围和处理错误的范围，底层函数不需要处理所有的Exception，他可以将自己无法处理的Exception交给上级。</p>
<h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p>有人会有疑问：每个函数进入处都进行合理性检查，会不会特别降低效率。</p>
<p>对于一般的应用代码而言，这里的开销微乎其微，不用特别在意。<br>现有编译器都会帮用户做性能上优化。<br>如果对于底层或SDK的代码来说，还是需要注意下。</p>
<h2 id="每次都检查，烦"><a href="#每次都检查，烦" class="headerlink" title="每次都检查，烦"></a>每次都检查，烦</h2><p>有人表示：我倒是不纠结与性能，但是在一个深度调用链，每个函数都要写一遍参数检查，又繁琐又影响阅读。<br>我之前也一直在纠结这个问题，觉得很难控制这个度。后来在看Android源码，终于有点想明白了，可以靠函数名传递一些有用信息。（源码真是博大精深，里面有各种精巧的函数设计）<br>这是在ActivityManagerService启动Activity过程中，调用各种startActivityXXX函数。<br>下面简单罗列下</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">startActivityAsUser</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">startActivityMayWait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">startActivityLocked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">startActivityCheckedLocked</span><span class="params">()</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里可以发现，函数中名有Checked和Locked。</p>
</blockquote>
<p>checked表示已经检查过了各种权限，Locked表示处于线程安全的情况下。<br>如果我们需要写几个深度调用函数时，某些可以使用checked字样，就不用重复的做参数检查。</p>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>对于某些赋值后内容不会改变的变量（读上去有点拗口），可以加上final关键字。<br>不用每次检查是否为null，直接去检查其构造函数，看看其中没有null检查。</p>
<h2 id="IDE的warning"><a href="#IDE的warning" class="headerlink" title="IDE的warning"></a>IDE的warning</h2><p>发展到如今，IDE已经上warning提醒已经做得非常完善。<br>有时候因为做得过于完善，所以写一上午的代码，IDE啪啪啪列出十几条warning，大家反正懒得去看。就像每个香烟上都写着“吸烟有害健康”，也没见烟民们戒烟不抽。</p>
<blockquote>
<p>warning还是有用的，大家要理解IDE作者的良苦用心。</p>
</blockquote>
<p>最好是写好小一段代码，就去看看新增的warning，能过滤到一些低级的错误。</p>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>有人会说，这些安全性检查和处理，包括一些理论上不应该出现的情况。<br>本来出现这些情况，可以在开发过程中及时的闪退，在上线前修复。</p>
<blockquote>
<p>别担心，语言开发者早就想到了这个问题，祭出了大杀器Assert断言。</p>
</blockquote>
<p>而且现在的编译器，在release环境下会去掉断言，真是贴心。</p>
<h2 id="工具检查"><a href="#工具检查" class="headerlink" title="工具检查"></a>工具检查</h2><p>有时候难免有疏落，这个时候就需要lint去检查下。<br>在C/C++程序中，可以使用PC-lint，并且打开Pointer-parameter-may-be-NULL这个开关（+fpn）。选项假设所有传递到函数中的指针都有可能是NULL。</p>
<h2 id="重大错误"><a href="#重大错误" class="headerlink" title="重大错误"></a>重大错误</h2><p>如果当程序运行时出现重大错误，核心功能出现问题，程序还是会闪退的。<br>不要企图靠以上各种方法去续1s命。<br>这个时候就需要平时好好做好单元测试，以及好好对待测试人员，希望他们发现尽可能多的bug。</p>
<hr>
<p>总结下，这篇文章核心就是</p>
<blockquote>
<p>“对象使用前，要检查下其合理性”。</p>
</blockquote>
<p>当然检查的力度，是一个仁者见仁智者见智的问题。<br>一千个人读者有一千个哈姆雷特，有代码洁癖者，也有收放自如的高手。<br>这里面没有谁的策略更优。</p>
<blockquote>
<p>对自己来说，写的顺手bug少，最关键。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="corresponding" />
            
              <p class="site-author-name" itemprop="name">corresponding</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/corresponding" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-globe"></i>GitHub</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">corresponding</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
