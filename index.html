<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="corresponding">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="corresponding">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="corresponding">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>corresponding</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">corresponding</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/10/20180110-Double-Stuffed-Security-in-Android-Oreo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="corresponding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corresponding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/10/20180110-Double-Stuffed-Security-in-Android-Oreo/" itemprop="url">像奥利奥一样的双重安全措施，尽在 Android Oreo</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-10T19:26:48+08:00">
                2018-01-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/译文/" itemprop="url" rel="index">
                    <span itemprop="name">译文</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <img src="/2018/01/10/20180110-Double-Stuffed-Security-in-Android-Oreo/0.jpg">
<blockquote>
<ul>
<li>原文地址：<a href="https://android-developers.googleblog.com/2017/12/double-stuffed-security-in-android-oreo.html" target="_blank" rel="noopener">Double Stuffed Security in Android Oreo</a></li>
<li>原文作者：<a href="https://android-developers.googleblog.com/2017/12/double-stuffed-security-in-android-oreo.html" target="_blank" rel="noopener">Gian G Spicuzza</a></li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li>
<li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO/double-stuffed-security-in-android-oreo.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO/double-stuffed-security-in-android-oreo.md</a></li>
<li>译者：<a href="https://github.com/XPGSnail" target="_blank" rel="noopener">一只胖蜗牛</a></li>
<li>校对者：<a href="https://github.com/corresponding" target="_blank" rel="noopener">corresponding</a>，<a href="https://github.com/SumiMakito" target="_blank" rel="noopener">SumiMakito</a></li>
</ul>
</blockquote>
<h1 id="像奥利奥一样的双重安全措施，尽在-Android-Oreo"><a href="#像奥利奥一样的双重安全措施，尽在-Android-Oreo" class="headerlink" title="像奥利奥一样的双重安全措施，尽在 Android Oreo"></a><a href="https://android-developers.googleblog.com/2017/12/double-stuffed-security-in-android-oreo.html" target="_blank" rel="noopener">像奥利奥一样的双重安全措施，尽在 Android Oreo</a></h1><p>由 Android 安全团队的 Gian G Spicuzza 发表</p>
<p>Android Oreo 中包含很多安全性提升的更新。几个月以来，我们讨论了如何增强 Android 平台及应用的安全性: 从<a href="https://android-developers.googleblog.com/2017/08/making-it-safer-to-get-apps-on-android-o.html" target="_blank" rel="noopener">提供更安全的获取应用渠道</a>，移除<a href="https://android-developers.googleblog.com/2017/04/android-o-to-drop-insecure-tls-version.html" target="_blank" rel="noopener">不安全的网络协议</a>，提供更多<a href="https://android-developers.googleblog.com/2017/04/changes-to-device-identifiers-in.html" target="_blank" rel="noopener">用户控制符</a>，<a href="https://android-developers.googleblog.com/2017/08/hardening-kernel-in-android-oreo.html" target="_blank" rel="noopener">加固内核</a>，<a href="https://android-developers.googleblog.com/2017/07/shut-hal-up.html" target="_blank" rel="noopener">使 Android 更易于更新</a>,直到<a href="https://android-developers.googleblog.com/2017/06/2017-android-security-rewards.html" target="_blank" rel="noopener">加倍 Android 安全奖励奖励项目的支出</a>。如今 Oreo 终于正式和大家见面了，让我们回顾下这其中的改进。  </p>
<h3 id="扩大硬件安全支持"><a href="#扩大硬件安全支持" class="headerlink" title="扩大硬件安全支持"></a>扩大硬件安全支持</h3><p>Android 早已支持<a href="https://source.android.com/security/verifiedboot/" target="_blank" rel="noopener">开机验证模式(Verified Boot)</a>，旨在防止设备软件被篡改的情况下启动。在 Android Oreo 中，我们随着<a href="https://source.android.com/devices/architecture/treble" target="_blank" rel="noopener"> Project Treble </a>一同运行的验证开机模式(Verified Boot)，称之为 Android 验证开机模式2.0(Android Verified Boot 2.0)(AVB)。AVB 有一些使得更新更加容易、安全的功能，例如通用的分区尾部（AVB 中位于文件系统分区尾部的结构）以及回滚保护。回滚保护旨在保护 OS 降级的设备，防止降级到到低版本的系统后被人攻击。为此，设备将通过专用的硬件保存系统版本信息或使用可信执行环境（Trusted Execution Environment, TEE）对数据进行签名。 Pixel 2 和 Pixel 2 XL 自带这种保护，并且我们建议所有设备制造商将这个功能添加到他们的新设备中。</p>
<p>Oreo 还包括新的<a href="https://android-review.googlesource.com/#/c/platform/hardware/interfaces/+/527086/-1..1/oemlock/1.0/IOemLock.hal" target="_blank" rel="noopener">原始设备制造商锁(OEM Lock)硬件抽象层(HAL)</a>使得设备制造商能够更加灵活的保护设备，无论设备处于锁定、解锁或者可解锁状态。例如，新的 Pixel 设备通过硬件抽象层命令向启动引导程序（bootloader）传递命令。启动引导装载程序会在下次开机分析这些命令并检查安全存储于有重放保护的内存区（Replay Protected Memory Block, RPMB）中对锁更改的信息是否合法。如果你的设备被偷了，这些保护措施旨在保护你的设备被重置，从而保护你的数据安全。新的硬件抽象层(HAL)甚至支持将锁移动到专用的硬件中。</p>
<p>谈到硬件，我们添加了防伪硬件支持，例如在每一个 Piexl 2 和 Piexl 2 XL 设备中内嵌的<a href="https://android-developers.googleblog.com/2017/11/how-pixel-2s-security-module-delivers.html" target="_blank" rel="noopener">安全模块</a>。这种物理芯片可以防止很多软硬件攻击，并且还抵抗物理渗透攻击. 安全模块防止推导设备密码及限制解锁尝试的频率，使得很多攻击由于时间限制而失效。</p>
<p>新的 Pixel 设备配有特殊的安全模块，所有搭载Android Oreo 的<a href="https://www.android.com/gms/" target="_blank" rel="noopener">谷歌移动服务(GMS)</a>的设备也需要实现<a href="https://android-developers.googleblog.com/2017/09/keystore-key-attestation.html" target="_blank" rel="noopener">密钥验证</a>。这提供了一种强<a href="https://source.android.com/security/keystore/attestation#id-attestation" target="_blank" rel="noopener">验证标识符</a>机制，例如硬件标识符。</p>
<p>我们也为企业管理设备添加了新的功能。当配置文件或者公司管理员远程锁定配置文件时，加密密钥会从内存（RAM）中移除.这有助于保护企业数据的安全。</p>
<h3 id="平台加固及进程隔离"><a href="#平台加固及进程隔离" class="headerlink" title="平台加固及进程隔离"></a>平台加固及进程隔离</h3><p>作为<a href="https://android-developers.googleblog.com/2017/05/here-comes-treble-modular-base-for.html" target="_blank" rel="noopener"> Project Treble </a>的一部分，为了使设备厂商可以更简单、低成本地更新，我们对 Android 的框架也进行了重构。将平台和供应商代码分离的目的也是为了提高安全性，根据<a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege" target="_blank" rel="noopener">最小特权原则</a>，这些硬件抽象层(HALs)运行在<a href="https://android-developers.googleblog.com/2017/07/shut-hal-up.html" target="_blank" rel="noopener">自己的沙盒中</a>，只对有权限的驱动设备开放。</p>
<p>追随着Android Nougat 中<a href="https://android-developers.googleblog.com/2016/05/hardening-media-stack.html" target="_blank" rel="noopener">媒体堆栈加固</a>，我们在Android Oreeo 媒体框架中移除了许多直接访问硬件的模块，从而创造了更好的隔离环境。此外，此外我们启用了所有媒体组件中的控制流完整性（Control Flow Integrity, CFI）保护。这种缺陷可以通过破坏应用的正常控制流，从而利用这种特权执行恶意的活动。 CFI 拥有健全的安全验证机制，不允许随意更改原来编译后二进制文件的控制流程图，也使得这样的攻击难以执行。</p>
<p>除了这些架构改变和CFI以外，Android Oreo 还带来了其他平台安全性相关的提升：</p>
<ul>
<li><strong><a href="https://android-developers.googleblog.com/2017/07/seccomp-filter-in-android-o.html" target="_blank" rel="noopener">Seccomp（Secure computing mode, 安全计算模式）过滤</a></strong>: 一些系统层的调用不再对应用开放，从而减少潜在损害应用途径。</li>
<li><strong><a href="https://lwn.net/Articles/695991/" target="_blank" rel="noopener">加固用户拷贝</a></strong>: 一个最新的 Android <a href="https://events.linuxfoundation.org/sites/events/files/slides/Android-%20protecting%20the%20kernel.pdf" target="_blank" rel="noopener">安全漏洞掉渣</a>显示：在内核漏洞中，失效的或者无边界检查情况约占 45%。在 Android 内核 3.18 及以上版本中，我们新增了一个边界检查的补丁，使得利用这个漏洞变得更困难，同时还同帮助开发者在他们代码中查找问题并修复问题。</li>
<li><strong>Privileged Access Never(PAN)仿真</strong>: 同时针对 3.18 以上的内核新增了补丁，这个功能禁止内核直接访问用户空间，同时确保开发者利用加固后的方式开访问用户空间。</li>
<li><strong>内核地址空间布局随机化(KASLR)</strong>：虽然Android已经支持地址空间布局随机化（ASLR）好多年了，我们仍针对 Android 内核 4.4 及以上版本提供了内核地址空间布局随机化（KASLR）补丁减少风险。内核地址空间布局随机化（KASLR）将在每次设备启动加载内核代码时随机分配地址，使得代码复用攻击，尤其是远程攻击更加难以执行。</li>
</ul>
<h3 id="应用程序安全性及设备标示变更"><a href="#应用程序安全性及设备标示变更" class="headerlink" title="应用程序安全性及设备标示变更"></a>应用程序安全性及设备标示变更</h3><p><a href="https://developer.android.com/topic/instant-apps/index.html" target="_blank" rel="noopener">Android 即时运行应用</a>运行在一个受限制的沙盒中，因此限制了部分权限和功能，例如访问设备内应用列表或者着明文传递数据。虽然是从 Android Oreo 才发布,但是即时运行应用支持在 <a href="https://www.android.com/versions/lollipop-5-0/" target="_blank" rel="noopener">Android Lollipop</a> 及以上版本的设备上运行。</p>
<p>为了更安全的处理不可信内容，我们通过将渲染引擎放到另一个进程中并将它运行在一个独立的资源受限的沙盒中来<a href="https://android-developers.googleblog.com/2017/06/whats-new-in-webview-security.html" target="_blank" rel="noopener">隔离 WebView</a>。此外，WebView 还支持<a href="https://safebrowsing.google.com/" target="_blank" rel="noopener">安全浏览</a>，从而保护使用者浏览含有潜在危险的网站。</p>
<p>最后，我们针对<a href="https://android-developers.googleblog.com/2017/04/changes-to-device-identifiers-in.html" target="_blank" rel="noopener">设备标识做了重大的改变</a>开放给用户更多的控制权，包括：</p>
<ul>
<li>静态的 Android ID 和 Widevine 将变为基于应用变化的值，这有助于限制设备中无法重置的标识符的使用。</li>
<li>依照 <a href="https://tools.ietf.org/html/rfc7844#section-3.7" target="_blank" rel="noopener">IETF RFC 7844</a>，现在 <code>net.hostname</code> 将为空且 DHCP 客户端也将不再发送主机名称（hostname)。</li>
<li>对于需要设备标识符的应用，我们新增了一个 <code>Build.getSerial() API</code> 并且通过权限对其进行保护。</li>
<li>我们与安全研究人员一起 <sup>1</sup> 在各种芯片组固件中的 Wi-Fi 扫描环节中新增一个健全的MAC地址随机化功能.</li>
</ul>
<p>Android Oreo 带来远不止这些改进，还有<a href="https://www.android.com/versions/oreo-8-0/" target="_blank" rel="noopener">更多</a>。一如既往，如果您有关于 Android 的反馈或是改进建议。欢迎发送邮件至 security@android.com。</p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/02/20180102-women-and-mobile-games-learnings-for-developers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="corresponding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corresponding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/02/20180102-women-and-mobile-games-learnings-for-developers/" itemprop="url">开发者须知-女性玩家和手机游戏</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-02T19:02:37+08:00">
                2018-01-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/译文/" itemprop="url" rel="index">
                    <span itemprop="name">译文</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <img src="/2018/01/02/20180102-women-and-mobile-games-learnings-for-developers/title.jpg">
<blockquote>
<ul>
<li>原文地址：<a href="https://medium.com/googleplaydev/women-and-mobile-games-learnings-for-developers-cc4ac63da3f2" target="_blank" rel="noopener">Women and mobile games: learnings for developers</a></li>
<li>原文作者：<a href="https://medium.com/@tobias.knoke?source=post_header_lockup" target="_blank" rel="noopener">Tobias Knoke</a></li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li>
<li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO/women-and-mobile-games-learnings-for-developers.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO/women-and-mobile-games-learnings-for-developers.md</a></li>
<li>译者：<a href="https://github.com/corresponding" target="_blank" rel="noopener">corresponding</a></li>
<li>校对者：<a href="https://github.com/hanliuxin5" target="_blank" rel="noopener">hanliuxin5</a>，<a href="https://github.com/tanglie1993" target="_blank" rel="noopener">tanglie1993</a></li>
</ul>
</blockquote>
<h1 id="开发者须知：女性玩家和手机游戏"><a href="#开发者须知：女性玩家和手机游戏" class="headerlink" title="开发者须知：女性玩家和手机游戏"></a>开发者须知：女性玩家和手机游戏</h1><p>Women and mobile games: learnings for developers</p>
<h2 id="让手机游戏变得更加多元化，更具包容性，更具吸引力的市场机遇"><a href="#让手机游戏变得更加多元化，更具包容性，更具吸引力的市场机遇" class="headerlink" title="让手机游戏变得更加多元化，更具包容性，更具吸引力的市场机遇"></a>让手机游戏变得更加多元化，更具包容性，更具吸引力的市场机遇</h2><p>The market opportunity in making mobile gaming more diverse, more inclusive, and more engaging</p>
<p>目前世界上有二十多亿部活跃的安卓设备，这意味着比起过去更多的人在玩手机游戏。手机游戏玩家的增长导致了这些游戏玩家的特点，需求和动机的多样性在不断扩大。我们之前文章 <a href="https://medium.com/googleplaydev/who-plays-mobile-games-8b33f76bb6d8" target="_blank" rel="noopener">谁在玩手机游戏</a> 讨论过，现在需要以满足在玩家玩游戏时的需求来对待玩家，而不是根据一些刻板印象和像人口统计那样的死板数据。与此同时，现在在游戏界有很多关于性别和包容的讨论，而关于<strong>女性手机游戏玩家</strong>的研究和讨论却很少。<br>There are now over two billion active Android devices which means more people are playing mobile games than ever before. The growth of the mobile games audience had led to an expansion of diversity in characteristics, needs, and motivations of those playing games. In our previous post Who plays mobile games we discussed the opportunity to think of players in terms of the needs met by playing games, rather than in terms of stereotypes and demographics. At the same time, there is a lot of conversation in the gaming community about gender and inclusivity, but relatively little research or discussion about the experiences of women who play mobile games.</p>
<p>我们想更多的了解这方面，所以我们和游戏情报商 NewZoo 合作，进行定量的研究，希望以此了解美国女性玩家的体验和看法。我们和数十位游戏作者，测评人员，玩家和学者一起合作，把我们的研究场景化。通过 <a href="https://play.google.com/about/changethegame" target="_blank" rel="noopener">交互性的体验</a> 和 <a href="http://services.google.com/fh/files/misc/changethegame_white_paper.pdf" target="_blank" rel="noopener">在总结中收获更多</a> ，我们深入研究。请继续读下去，了解开发者如何让游戏更具包容性，并吸引近在咫尺的玩家。<br>We wanted to understand more about this so we partnered with gaming intelligence provider Newzoo to produce a quantitative research study to understand the experiences and perceptions of women who play games in the United States. We worked with dozens of game makers, critics, players, and academics to contextualize our research. Dive deeper into the insights through this interactive experience or discover more learnings in a summary of our findings. Read on to find out how you as a developer can make your game more inclusive and appealing to all players out there.</p>
<img src="/2018/01/02/20180102-women-and-mobile-games-learnings-for-developers/0.png">
<h3 id="了解你的用户"><a href="#了解你的用户" class="headerlink" title="了解你的用户"></a><strong>了解你的用户</strong></h3><p>Know your audience</p>
<p>无论从人数上和偏好上来说，女性手机游戏玩家有巨大市场潜力。在我们的调查中，美国有大量女性手机游戏玩家（其中 65% 都处于 10 - 65 岁年龄段）。在过去的一年里，这比去电影院看过电影的比例（62%）或读过一本书的比例（44%）更加高。这里可以清晰的看出，比起其他娱乐活动，女性更愿意玩手机游戏。报告还表明，女性就和男性一样喜欢玩手机游戏 — <strong>有一半的玩家是女性</strong>！相比其他平台，女性不仅更喜欢在手机上游戏，而且<strong>女性玩的频率比男性更高</strong>。<br>There is significant market potential in women who play mobile games, both in terms of volume and preference for the platform. In our research we found a significant number of women in the US play mobile games today (65% of those aged between 10–65 years). This is a higher percentage than those who have watched a movie at a movie theater (62%), or read a book (44%), in the last year. It’s clear that women engage significantly more in mobile gaming than in other forms of entertainment, and that’s not it… Research has shown that they are just as likely to play mobile games as men — women represent half of all mobile game players! They are not only more likely to prefer mobile compared to other platforms, women also tend to play more frequently than men.</p>
<p>作为游戏开发者，你意识到女性游戏的机会了吗？这可能是个通过了解这些用户而进入这个未开发的市场的机会。第一步，你可能要衡量和评估女性玩家的占比。<strong>在你的用户群体中，女性是否被很好的代表了？她们和男性是否有不同的游戏体验？</strong><br>As a games developer, do you consider the opportunity presented women for your games? There may be an opportunity for you to grow your business in untapped markets by better understanding your players. As a starting point you might want to measure and evaluate the percentage of players who are women. Are women well represented in your player base? Is there a difference in their user experience compared to your male players?</p>
<p>对开发新游戏时的建议：当你在设计游戏或者思考未来的发展方向时，多去想想那些目标用户，而不用去讨好那些你所认为的”典型”用户。不同用户的游戏体验可能会不同吗？通过彻底分析和研究用户，你可以从那些尚未被顾及的用户（比如那些女性游戏玩家）中寻找商机。<br>The same goes for new developments: when designing your game, or thinking of future development, it can be a useful exercise to think of the range of people who may play your game, rather than gravitating to the ‘typical’ player. Could there be a difference in the user experience of some players? By thoroughly analysing and researching user audiences you can potentially make a strong business case to capture an underserved audience — such as women who play games.</p>
<img src="/2018/01/02/20180102-women-and-mobile-games-learnings-for-developers/1.png">
<h3 id="制作更具包容性的游戏"><a href="#制作更具包容性的游戏" class="headerlink" title="制作更具包容性的游戏"></a><strong>制作更具包容性的游戏</strong></h3><p>Build more inclusive games</p>
<p>如果你观察 <a href="https://play.google.com/store" target="_blank" rel="noopener"> Google 应用市场</a> 中受欢迎的游戏，部分图像和图标的性质暗示着女性玩家在游戏世界中是一个相对较小的群体。在Google应用市场收入前 100 的游戏中，以男性角色作为图标的游戏数量比以女性角色作为图标的游戏数量多 44%。所以在我们的调查中，尽管女性玩家玩的更多，但是她们还是认为自己不属于现在的游戏社区。在推广游戏时，更换更合适的图标和形象，会让你从竞争中脱颖而出，也会减少你错过潜在玩家的可能。请尝试以下几点：<br>If you look at popular games on Google Play, the nature of much of the imagery and icons would imply women are a relatively niche group in the world of gaming: among the top 100 revenue generating games on Google Play, characters who are men are featured in their app icons 44% more often than characters who are women. Consequently our research found women often do not feel like they belong to this community although they are playing games very actively. Using alternative, or less alienating, iconography, characters, and imagery when promoting your game could help differentiate it clearly from your competition, and ensure you don’t miss out on reaching potential players. Try the following quick tips:</p>
<ul>
<li>在做 <a href="https://support.google.com/googleplay/android-developer/answer/6227309?hl=en-GB" target="_blank" rel="noopener">商店列表</a> 时，<strong>测试更有包容性的图像</strong>。<br>Test more inclusive imagery when running store listing experiments.</li>
<li><strong>多关注应用的图标，截图和视频</strong>，并考虑测试不同图像对转换率的影响。<br>Pay attention to your icon, screenshots, and videos, and consider testing the impact of different imagery on conversion rates.</li>
<li>考虑下<strong>使用女性角色来体验游戏</strong>，或者在运行<strong>电话回访</strong>时<strong>尝试新的可能性</strong>。<br>Think of launching with characters who are women, or testing new ones when running LiveOps.</li>
<li>追踪用户对游戏角色的共鸣，同时<strong>倾听用户群体的反馈</strong>也很重要。<br>Track how people are resonating with the characters, and, invaluably, listen to the feedback of your community.</li>
</ul>
<h3 id="发展一个多样化的开发团队"><a href="#发展一个多样化的开发团队" class="headerlink" title="发展一个多样化的开发团队"></a><strong>发展一个多样化的开发团队</strong></h3><p>Grow a diverse team</p>
<p>在一大群人中提取共同需求很难。我们都想开发<strong>自己</strong>想玩的游戏。为了减少偏见，<strong>在游戏生命周期的几个阶段，都需要获取潜在用户的反馈</strong>。<br>It is very difficult to have the empathy and perspective needed to build a product that meets the needs of a wide range of potential people. It’s human nature to build games you want to play. To reduce potential bias, request feedback from a broad representation of your potential players at several stages throughout your game’s lifecycle.</p>
<p>你的开发团队的形象也影响能否取到悦更多的用户。尽管有如此多的女性玩家，游戏行业仍然只关注男性用户: IDGA的调查发现，女性、跨性别者和其他只占 <a href="http://c.ymcdn.com/sites/www.igda.org/resource/resmgr/files__2016_dss/IGDA_DSS_2016_Summary_Report.pdf" target="_blank" rel="noopener">全球 27.8% 的游戏产业</a> 。这种不平衡的现象呼应我们的研究结果，只有 23％ 的女性和 40％ 的男性认为在游戏行业中人人享有平等的待遇和机会。<br>The profile of your development team also impacts your ability to build games that appeal to a wide spectrum of players. Despite the high proportion of women playing mobile games, men are overrepresented in the gaming industry: according to the IDGA, only 27.8% of the gaming industry globally are women, transgender, or other people. This imbalanced representation is felt by players who responded to our research with only 23% of women and 40% of men believing there is equal treatment and opportunity for all in the games industry.</p>
<p>来自团队成员多样化的观点将帮助您开发真正创新且有意思的游戏，并且吸引更多的潜在玩家。现在就看下自己的团队和游戏的用户构成的差别。你的团队成员能代表你的受众吗？您的团队是否已经整装待发，来帮助您最大化的捕获潜在受众，并且让您的游戏吸引所有人？<br>Diversity of perspectives from your team members will help you build truly innovative and exciting games that will appeal to a broad spectrum of potential players. Look at your team and compare it with the user composition of your game. Is your team truly representative of your audience? Is it well equipped to help you capture the maximum potential audience possible by making your game appealing to everyone?</p>
<img src="/2018/01/02/20180102-women-and-mobile-games-learnings-for-developers/2.png">
<h3 id="把握这个机遇"><a href="#把握这个机遇" class="headerlink" title="把握这个机遇"></a><strong>把握这个机遇</strong></h3><p>Take advantage of this opportunity</p>
<p>尽管未来女性玩家数量巨大，但研究结果却让人惊讶，他们比男性更难以真正接受自己的游戏爱好。大部分女性玩家不属于游戏世界。一般女性玩家不太喜欢和朋友交谈游戏内容，为游戏付费，以及享受付费所带来的快乐。<br>While there is great potential in the sheer volume of women playing mobile games, it is striking from the research how less likely they are than men to truly embrace their play habits. With a few notable exceptions, there is a sense that women don’t belong in the world of gaming. They are less likely to talk about games with their friends, pay for content, or feel good when they do pay.</p>
<p>我们相信，这是一个游戏产业真正与女性玩家互动的绝佳机会。随着用户获取成本的上升，需要想想如何能开发出与所有玩家产生共鸣并且能病毒式传播的游戏。只有让女性玩家参与到游戏中，你才能解决这个问题。<br>We believe this represents a great opportunity for the industry to truly engage with women who play games. As user acquisition costs rise, think of the potential virality of building a game that resonates with and excites all players. This can only be achieved by recognizing and addressing the barriers for women to engage with your game.</p>
<h3 id="着眼未来"><a href="#着眼未来" class="headerlink" title="着眼未来"></a><strong>着眼未来</strong></h3><p>The road ahead</p>
<p>我们相信，游戏市场还有很大的空间，能让我们使手机游戏更加多元化，更具包容性，更吸引所有玩家。为了把握这个机会，您的第一步是：<br>We believe there is a great opportunity in market growth and making mobile gaming more diverse, more inclusive, and more engaging for all players. The first steps for you in order to take advantage of this opportunity are:</p>
<ul>
<li>了解你的用户：当前用户和潜在用户<br>Know your audience: current and potential</li>
<li>研究你的游戏是怎样把一些潜在用户排除在外的<br>Consider how your games may exclude some potential players</li>
<li>评估你团队观点的多样性，这将如何影响你开发的游戏<br>Assess the range of perspectives in your team, and how this affects the games you build</li>
<li>头脑风暴，你可能会想出一款所有人都喜欢的游戏<br>Brainstorm how you may produce the next game that all players could embrace</li>
</ul>
<p>手机游戏生为大众。为了褒奖和激励女性玩家和女性开发者，我们启动了 <a href="http://g.co/changethegame" target="_blank" rel="noopener">改变游戏</a> 的计划。这是 Google 应用商店的一项旨在促进游戏多样性的计划，同时这项计划也褒奖所有女性玩家，并通过正在进行的研究和合作为下一代游戏开发者提供支持。<br>Mobile games are for everyone. To celebrate and empower women who play games and creators, we’re launching CHANGE THE GAME; a new Google Play initiative to promote diversity in games, celebrate all women who play games, and empower the next generation of game-makers through ongoing research, development programs, and partnerships.</p>
<p>作为一个应用开发者，你能影响未来游戏的走向。我希望你能参与到我们活动中，和我们一起让游戏世界变得更加包容性。如果我们一起努力，手机游戏的世界会变得更加有趣。<br>As a mobile developer, you have a major influence on how future games will look like. We hope you can join our efforts of making the gaming world a more inclusive community; if we all contribute to this, mobile games will bring us even more joy than they do today.</p>
<hr>
<h3 id="你是怎么想的呢？"><a href="#你是怎么想的呢？" class="headerlink" title="你是怎么想的呢？"></a>你是怎么想的呢？</h3><p>What do you think?</p>
<p>你有没有想过开发人员怎样去设计更有包容性的游戏呢？在文章下面留言或者 twitter 中添加<strong>#AskPlayDev</strong>标签后发言，我们会通过 <a href="http://twitter.com/googleplaydev" target="_blank" rel="noopener">@GooglePlayDev</a> （那里我们会展示在 Google 应用商店获得成功的窍门）回复。<br>Do you have thoughts on how developers can build more inclusive games? Join the discussion in the comments below or tweet using the hashtag #AskPlayDev and we’ll reply from @GooglePlayDev, where we regularly share news and tips on how to be successful on Google Play.</p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/20/20171220-Okio-source/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="corresponding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corresponding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/20/20171220-Okio-source/" itemprop="url">Okio源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-20T19:39:26+08:00">
                2017-12-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <img src="/2017/12/20/20171220-Okio-source/1.jpg" title="深秋">
<p>大家一定听说或者使用过鼎鼎大名的OKHttp和Retrofit，它们内部都调用了Okio。<br>它们三个都是Square团队开源的库，主要处理I/O操作和网络请求。<br>今天我们就来读下Okio的源码，看看Okio有什么神奇之处。</p>
<h1 id="Okio是什么"><a href="#Okio是什么" class="headerlink" title="Okio是什么?"></a>Okio是什么?</h1><p>Okio是一个完善java.io和java.nio的库，可以更方便的读、写、处理数据。</p>
<p>看到上面的官方介绍，我们可以发现两个重点：<br>1.完善java.io和java.nio；<br>2.Okio的主要功能是，读、写、处理数据。</p>
<p>再深入思考下，java.io和java.nio有哪些尚未完善的地方？Okio有做了哪些优化？</p>
<p>java.io能处理所有的IO信息，但是还是有些不完美之处：<br>1.需要自己去管理byte数组；<br>2.java.io类和继承关系过于复杂，使用起来更加不便；<br>3.java.io操作可能会某些原因读取速度特别慢，甚至一直等待无法返回；<br>4.操作字符流和字节流方法不同，需要区别对待；<br>5.涉及到多个流之间的数据传递，需要反复拷贝，效率不高。</p>
<p>被Android官方青睐的IO库，Okio一一解决了这些问题：<br>1.使用ByteString去封装byte数组；<br>2.简化类关系，主要使用Buffer、Sink、Source等类，相互关系简单；<br>3.使用Timeout去控制超时；<br>4.可用相同方法去操作字符流和字节流；<br>5.提高多个流之间的数据传递速度。</p>
<p>带着这些问题，我们继续前进。</p>
<h1 id="ByteString"><a href="#ByteString" class="headerlink" title="ByteString"></a>ByteString</h1><p>记得我最开始编程时，C语言中没有字符串类型，只能使用char*的方式存储字符串，而且经常涉及数组和指针的转换，<br>需要使用memcpy和memset等等函数，容易出错，而且还需要加入大量的检测。<br>后面使用面向对象语言后，发现用String对象直接管理字符串，良好的封装char数组的常用方法，使用起来各种清爽。</p>
<p>同样使用过java.io的开发者，肯定会想起被byte数组笼罩的恐惧。<br>需要不厌其烦的处理一串串byte数组，完成encode和decode函数，还要特别关注编码问题。<br>这个时候就希望，能有一个对象来管理byte数组，并且帮我们封装好各种函数，使用时直接调用下即可。</p>
<p>Okio就满足开发者这个愿望，提供了ByteString类，把对字节数组的常用方法都封装好了。<br>使用Okio库后，开发者可以以ByteString作为最小粒度进行操作。</p>
<p>先来看下ByteString的组成<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.实现了Serializable和Comparable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteString</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">ByteString</span>&gt; &#123;</span></span><br><span class="line">  <span class="comment">// 1.byte数组，所以为ByteString</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">byte</span>[] data;</span><br><span class="line">  <span class="comment">// 2.hashCode，在需要时才计算出。不会被序列化</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> hashCode;</span><br><span class="line">  <span class="comment">// 3.data utf8化后生成的String，在需要时才计算出。不会被序列化</span></span><br><span class="line">  <span class="keyword">transient</span> String utf8; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ByteString的内部也不复杂，主要就是byte数组。<br>这里要看下String的结构，其实String可以命名为CharString。<br>因为一般开发中，字符串用的比较多，所以java官方直接命名为String。<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.同样实现了Serializable和Comparable接口，额外实现了CharSequence处理常规char数组数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.char数组，所以String等于CharString</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">	<span class="comment">// 2.hashCode</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下去看下，ByteString的读和写<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteString <span class="keyword">read</span>(InputStream in, <span class="keyword">int</span> byteCount) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.检查合法性</span></span><br><span class="line">    <span class="keyword">if</span> (in == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"in == null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (byteCount &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"byteCount &lt; 0: "</span> + byteCount);</span><br><span class="line">    <span class="comment">// 2.分配空间</span></span><br><span class="line">    <span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span class="keyword">byte</span>[byteCount];</span><br><span class="line">    <span class="comment">// 3.循环读取inputStream中的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> offset = <span class="number">0</span>, <span class="keyword">read</span>; offset &lt; byteCount; offset += <span class="keyword">read</span>) &#123;</span><br><span class="line">      <span class="comment">// 3.1.每次尽可能多的读取inputStream数据，放入result中</span></span><br><span class="line">      <span class="keyword">read</span> = in.<span class="keyword">read</span>(result, offset, byteCount - offset);</span><br><span class="line">      <span class="comment">// 3.2.读取inputStream异常</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">read</span> == -<span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.生成ByteString</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ByteString(result);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span>(<span class="params">OutputStream <span class="keyword">out</span></span>) throws IOException </span>&#123;</span><br><span class="line">	<span class="comment">// 1.检查合法性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">out</span> == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"out == null"</span>);</span><br><span class="line">	<span class="comment">// 2.直接写入byte数组</span></span><br><span class="line">    <span class="keyword">out</span>.write(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h1><p>IO操作的最重要部分就是对流的处理，所以定义好一个流非常关键。<br>Okio中，就是用Buffer去表示流。</p>
<img src="/2017/12/20/20171220-Okio-source/2.png" title="Buffer类关系图">
<p>先看下翻译<br>source：来源；水源；<br>sink：水槽；洗涤槽；<br>一下子就明白了Source表示输入源，Sink表示输出源。<br>对应java.io中的inputStream和outputStream。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> <span class="keyword">implements</span> <span class="title">BufferedSource</span>, <span class="title">BufferedSink</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">  Segment head;</span><br><span class="line">  <span class="keyword">long</span> size;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>size表示Buffer中的字节数量。<br>主要成员变量也非常简单，就是segment。<br>源码上注释非常简洁清晰：A segment of a buffer，翻译过来就是Buffer的片段。<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span> </span>&#123;</span><br><span class="line">  Segment prev;			<span class="comment">// 指向双向链表上一节点</span></span><br><span class="line">  Segment next;			<span class="comment">// 指向双向链表下一节点</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">byte</span>[] data;    <span class="comment">// data表示本segment存储的数据</span></span><br><span class="line">  <span class="keyword">int</span> pos;              <span class="comment">// pos表示data中下一个读取字节的index</span></span><br><span class="line">  <span class="keyword">int</span> limit;            <span class="comment">// limit表示data中下一个写入字节的index。为什么用limit命名呢，因为这个index也是读取字节的上限</span></span><br><span class="line">  <span class="keyword">boolean</span> shared;       <span class="comment">// 是否共享。Okio为了提高效率，在某些时候不拷贝整个segment，而是采用弱引用方式指向segment</span></span><br><span class="line">  <span class="keyword">boolean</span> owner;        <span class="comment">// 因为加入共享功能后，就需要确定持有者，只有持有者才能往这个segment中写数据</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从prev和next就可以发现这是双向链表。在Buffer中就持有head，通过head去访问整个链表。<br>通过后续的代码阅读，发现这是一个双向循环链表。</p>
<img src="/2017/12/20/20171220-Okio-source/3.png" title="segment双向链表">
<p>我们分析下Okio中是如何写入和读取byte数据的。</p>
<h2 id="Buffer-writeByte"><a href="#Buffer-writeByte" class="headerlink" title="Buffer.writeByte"></a>Buffer.writeByte</h2><p>先来看看Buffer怎么样写入一个byte<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.注意入参是int格式，不过其中有效数据的只有8 bit</span></span><br><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="function">Buffer <span class="title">writeByte</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1.寻找可供写入的segment</span></span><br><span class="line">    Segment tail = writableSegment(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 2.在segment中写入字节byte。limit的含义在上文提及，表示下一个写入字节的index</span></span><br><span class="line">    tail.data[tail.limit++] = (<span class="keyword">byte</span>) b;</span><br><span class="line">    <span class="comment">// 3.buffer中size变化</span></span><br><span class="line">	size += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>writeByte函数的代码都很简单，我们继续看看如何寻找可供写入的segment。</p>
<h2 id="Buffer-writableSegment"><a href="#Buffer-writableSegment" class="headerlink" title="Buffer.writableSegment"></a>Buffer.writableSegment</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.入参minimumCapacity表示允许写的最小空间</span></span><br><span class="line">Segment writableSegment(<span class="keyword">int</span> minimumCapacity) &#123;</span><br><span class="line">    <span class="comment">// 1.检查合法性</span></span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity &lt; <span class="number">1</span> || minimumCapacity &gt; Segment.<span class="keyword">SIZE</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 2.当前head为空时，先新建一个</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 2.1.从SegmentPool中取出一个segment</span></span><br><span class="line">      head = SegmentPool.take();</span><br><span class="line">      <span class="comment">// 2.2.设置为双向循环链表</span></span><br><span class="line">      <span class="keyword">return</span> head.<span class="keyword">next</span> = head.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.选择链表最尾部的segment</span></span><br><span class="line">    Segment tail = head.prev;</span><br><span class="line">    <span class="comment">// 4.如果尾部segment中没有足够的可写空间，或者当前Buffer不是尾部segment的持有者，重新从SegmentPool取出segment插入链表</span></span><br><span class="line">    <span class="keyword">if</span> (tail.limit + minimumCapacity &gt; Segment.<span class="keyword">SIZE</span> || !tail.owner) &#123;</span><br><span class="line">      tail = tail.<span class="keyword">push</span>(SegmentPool.take());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里引入了SegmentPool这个类，主要用来管理Segment对象，回收旧segment，分配segment。<br>SegmentPool减少了segment的新建和释放次数，缓解java GC的压力。</p>
<p>注：类似于Handler中message.obtain()，其背后也有一个pool去管理所有的message对象。</p>
<h2 id="SegmentPool"><a href="#SegmentPool" class="headerlink" title="SegmentPool"></a>SegmentPool</h2><p>这个类代码很短，全部贴出来<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> SegmentPool &#123;</span><br><span class="line">  <span class="comment">// pool 容量上限，最大为64KiB</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MAX_SIZE = <span class="number">64</span> * <span class="number">1024</span>;</span><br><span class="line">  <span class="comment">// 单向链表</span></span><br><span class="line">  <span class="keyword">static</span> Segment <span class="keyword">next</span>;</span><br><span class="line">  <span class="comment">// pool中总字节数</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">long</span> byteCount;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> SegmentPool() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Segment take() &#123;</span><br><span class="line">    <span class="comment">// take和recycle中next都被synchronize包含，所以是线程安全的</span></span><br><span class="line">    <span class="keyword">synchronized</span> (SegmentPool.<span class="keyword">class</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果当前pool不为空，链表还有数据，从链表头取出segment</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">next</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Segment result = <span class="keyword">next</span>;</span><br><span class="line">        <span class="keyword">next</span> = result.<span class="keyword">next</span>;</span><br><span class="line">        result.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">        byteCount -= Segment.<span class="keyword">SIZE</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前pool部为空，链表中没有数据，新建一个segment</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Segment();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> recycle(Segment segment) &#123;</span><br><span class="line">    <span class="keyword">if</span> (segment.<span class="keyword">next</span> != <span class="keyword">null</span> || segment.prev != <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 如果当前segment被共享，则放弃回收</span></span><br><span class="line">    <span class="keyword">if</span> (segment.shared) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// take和recycle中next都被synchronize包含，所以是线程安全的</span></span><br><span class="line">    <span class="keyword">synchronized</span> (SegmentPool.<span class="keyword">class</span>) &#123;</span><br><span class="line">      <span class="comment">// pool达到上限的，放弃回收</span></span><br><span class="line">      <span class="keyword">if</span> (byteCount + Segment.<span class="keyword">SIZE</span> &gt; MAX_SIZE) <span class="keyword">return</span>;</span><br><span class="line">      byteCount += Segment.<span class="keyword">SIZE</span>;</span><br><span class="line">      segment.<span class="keyword">next</span> = <span class="keyword">next</span>;</span><br><span class="line">      <span class="keyword">next</span> = segment;</span><br><span class="line">      <span class="comment">// 重新设置segment的pos和limit</span></span><br><span class="line">      segment.pos = segment.limit = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>segmentPool这个类非常简单，内部维护一个单向列表。<br>take()会从头部取出segment，recycler()将待回收的segment放回到链表头部。</p>
<h2 id="Buffer-readByte"><a href="#Buffer-readByte" class="headerlink" title="Buffer.readByte"></a>Buffer.readByte</h2><p>我们来看下readByte，其方法和writeByte完全对称。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span> readByte() &#123;</span><br><span class="line">    <span class="comment">// 1.检查合法性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">size</span> == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"size == 0"</span>);</span><br><span class="line">    <span class="comment">// 2.取出segment中数据</span></span><br><span class="line">    Segment segment = head;</span><br><span class="line">    <span class="keyword">int</span> pos = segment.pos;</span><br><span class="line">    <span class="keyword">int</span> limit = segment.limit;</span><br><span class="line">    <span class="keyword">byte</span>[] data = segment.data;</span><br><span class="line">    <span class="keyword">byte</span> b = data[pos++];</span><br><span class="line">    <span class="keyword">size</span> -= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 3.如果当前segment中数据被读取完毕</span></span><br><span class="line">    <span class="keyword">if</span> (pos == limit) &#123;</span><br><span class="line">      <span class="comment">// 3.1.从双向链表中pop出来</span></span><br><span class="line">      head = segment.<span class="keyword">pop</span>();</span><br><span class="line">      <span class="comment">// 3.2.回收这个segment，放入到segmentPool中</span></span><br><span class="line">      SegmentPool.recycle(segment);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 4.如果当前segment中数据未被读取完毕，只更新pos信息</span></span><br><span class="line">      segment.pos = pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h1><p>IO最重要的就是对流的处理，Okio中对应的数据结构是Source和Sink</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.Closeable接口中方法为close()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Source</span> <span class="keyword">extends</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.读取Buffer中byteCount长度的数据，返回值为本次读取的字节长度</span></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">read</span><span class="params">(Buffer sink, <span class="keyword">long</span> byteCount)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">  <span class="comment">// 2.超时控制</span></span><br><span class="line">  <span class="function">Timeout <span class="title">timeout</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 3.关闭source并且释放资源，允许调用多次</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个接口，后续都是使用其实现类作为输入流。</p>
<h2 id="Okio-Source"><a href="#Okio-Source" class="headerlink" title="Okio.Source"></a>Okio.Source</h2><p>我们看下Okio.Source，开发者一般都使用这个函数生成Source。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function">Source <span class="title">source</span><span class="params">(<span class="keyword">final</span> InputStream in, <span class="keyword">final</span> Timeout timeout)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.检查合法性</span></span><br><span class="line">    <span class="keyword">if</span> (in == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"in == null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout == null"</span>);</span><br><span class="line">    <span class="comment">// 2.新建了一个匿名类，实现Source接口</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Source() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">long</span> <span class="title">read</span><span class="params">(Buffer sink, <span class="keyword">long</span> byteCount)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 2.1.检查合法性</span></span><br><span class="line">        <span class="keyword">if</span> (byteCount &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"byteCount &lt; 0: "</span> + byteCount);</span><br><span class="line">        <span class="keyword">if</span> (byteCount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 2.2.检查是否超时</span></span><br><span class="line">          timeout.throwIfReached();</span><br><span class="line">          <span class="comment">// 2.3.寻找可供写入的segment，在之前详细解释过</span></span><br><span class="line">          Segment tail = sink.writableSegment(<span class="number">1</span>);</span><br><span class="line">          <span class="comment">// 3.3.当前segment剩余可以写入大小，和byteCount两者间选择较小的值，设置为maxToCopy</span></span><br><span class="line">          <span class="keyword">int</span> maxToCopy = (<span class="keyword">int</span>) Math.min(byteCount, Segment.SIZE - tail.limit);</span><br><span class="line">          <span class="comment">// 3.4.从InputStream中尽可能的提取maxToCopy长度，写入到segment中</span></span><br><span class="line">          <span class="keyword">int</span> bytesRead = in.read(tail.data, tail.limit, maxToCopy);</span><br><span class="line">          <span class="comment">// 3.5.读取异常</span></span><br><span class="line">          <span class="keyword">if</span> (bytesRead == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          <span class="comment">// 3.6.调整segment和buffer中的参数</span></span><br><span class="line">          tail.limit += bytesRead;</span><br><span class="line">          sink.size += bytesRead;</span><br><span class="line">          <span class="keyword">return</span> bytesRead;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AssertionError e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (isAndroidGetsocknameError(e)) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(e);</span><br><span class="line">          <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        in.close();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function">Timeout <span class="title">timeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timeout;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function">String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"source("</span> + in + <span class="string">")"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码逻辑非常清晰，流水型执行下去即可。<br>这里出现了一个新的对象timeout，用来管理超时，我们看看其内部结构。</p>
<h2 id="Timeout"><a href="#Timeout" class="headerlink" title="Timeout"></a>Timeout</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Timeout</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.判断deadlineNanoTime是否被定义。如果缺少该变量的话，deadlineNanoTime或者timeoutNanos为0时，无法判断是未设置还是设置为0</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> hasDeadline;</span><br><span class="line">  <span class="comment">// 2.截止时间，单位为纳秒</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> deadlineNanoTime;</span><br><span class="line">  <span class="comment">// 3.设定的超时时间间隔，单位为纳秒</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> timeoutNanos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Timeout主要用来设置超时时间，对Stream的读取超过指定时间后，认定为失败，开发者需要选择close或者重新操作这个Stream。</p>
<p>注：读取网络Socket流时，有时会陷入无限等待中，需要使用AsyncTimeout。AsyncTimeout会新开线程监听超时，当前线程无限等待也没有关系。</p>
<p>继续看下上面被调用的throwIfReached()<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">throwIfReached</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.判断当前线程是否被中断</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedIOException(<span class="string">"thread interrupted"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.判断当前是否超时</span></span><br><span class="line">    <span class="keyword">if</span> (hasDeadline &amp;&amp; deadlineNanoTime - System.nanoTime() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedIOException(<span class="string">"deadline reached"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Okio-buffer"><a href="#Okio-buffer" class="headerlink" title="Okio.buffer"></a>Okio.buffer</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.这里传入上面通过Okio.source生成的Source</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BufferedSource buffer(<span class="keyword">Source</span> <span class="keyword">source</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.生成BufferSource，真正处理输入流，你看命名中都写着real</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RealBufferedSource(<span class="keyword">source</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="RealBufferedSource"><a href="#RealBufferedSource" class="headerlink" title="RealBufferedSource"></a>RealBufferedSource</h1><p>终于找到开发者最后操作的Source类，先来看下它的成员吧。<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.实现BufferedSource接口</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealBufferedSource</span> <span class="keyword">implements</span> <span class="title">BufferedSource</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.初始化时自动生成</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Buffer buffer = <span class="keyword">new</span> Buffer();</span><br><span class="line">  <span class="comment">// 2.Okio.Buffer中传入的source对象</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Source source;</span><br><span class="line">  <span class="comment">// 3.判断source是否关闭</span></span><br><span class="line">  <span class="keyword">boolean</span> closed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="RealBufferedSource-read"><a href="#RealBufferedSource-read" class="headerlink" title="RealBufferedSource.read"></a>RealBufferedSource.read</h2><p>对于输入流来说，我们需要紧紧抓住read方法。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override <span class="keyword">public</span> <span class="keyword">int</span> <span class="built_in">read</span>(<span class="keyword">byte</span>[] sink, <span class="keyword">int</span> offset, <span class="keyword">int</span> byteCount) throws IOException &#123;</span><br><span class="line">    <span class="comment">// 1.检查合法性</span></span><br><span class="line">    checkOffsetAndCount(sink.length, offset, byteCount);</span><br><span class="line">    <span class="comment">// 2.当前buffer为空时</span></span><br><span class="line">    <span class="built_in">if</span> (<span class="built_in">buffer</span>.<span class="built_in">size</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 2.1.尽可能读取一个segment放入到buffer中</span></span><br><span class="line">      <span class="keyword">long</span> <span class="built_in">read</span> = source.<span class="built_in">read</span>(<span class="built_in">buffer</span>, Segment.SIZE);</span><br><span class="line">      <span class="comment">// 2.2.读取异常</span></span><br><span class="line">      <span class="built_in">if</span> (<span class="built_in">read</span> == <span class="number">-1</span>) <span class="built_in">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.选择buffer中数据和byteCount中较小值</span></span><br><span class="line">    <span class="keyword">int</span> toRead = (<span class="keyword">int</span>) Math.<span class="built_in">min</span>(byteCount, <span class="built_in">buffer</span>.<span class="built_in">size</span>);</span><br><span class="line">    <span class="comment">// 4.将buffer中数据输出到byte数组</span></span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">buffer</span>.<span class="built_in">read</span>(sink, offset, toRead);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>主要流程就是，现将source数据读取到buffer中，再将buffer提取到byte数组中。buffer.read()这个函数这里就不展开讨论了，其原理和buffer.readByte非常相近。</p>
<h1 id="Sink"><a href="#Sink" class="headerlink" title="Sink"></a>Sink</h1><p>同理，完全对应的，也可以按照Okio.sink-&gt; Okio.buffer(Sink)-&gt; RealBufferedSink-&gt; RealBufferedSink.write()流程走完一遍Okio中关于写的操作。</p>
<p>总结，Okio这个库本身并不复杂，将常用的流和字节数据进行良好的封装，加之源码中相近的注释，阅读起来非常流畅，想必使用起来的体验也会非常棒。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/14/20171214-shrinking-apks-growing-installs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="corresponding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corresponding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/14/20171214-shrinking-apks-growing-installs/" itemprop="url">缩小APK，增加下载量</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-14T17:10:12+08:00">
                2017-12-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/译文/" itemprop="url" rel="index">
                    <span itemprop="name">译文</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<ul>
<li>原文地址：<a href="https://medium.com/googleplaydev/shrinking-apks-growing-installs-5d3fcba23ce2" target="_blank" rel="noopener">Shrinking APKs, growing installs: How your app’s APK size impacts install conversion rates</a></li>
<li>原文作者：<a href="https://medium.com/@samueltolomei?source=post_header_lockup" target="_blank" rel="noopener">Sam Tolomei</a></li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li>
<li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO/shrinking-apks-growing-installs.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO/shrinking-apks-growing-installs.md</a></li>
<li>译者：<a href="https://github.com/tanglie1993" target="_blank" rel="noopener">tanglie1993</a></li>
<li>校对者：<a href="http://www.swants.cn" target="_blank" rel="noopener">swants</a>, <a href="https://github.com/corresponding" target="_blank" rel="noopener">corresponding</a></li>
</ul>
</blockquote>
<h1 id="缩小APK，增加下载量"><a href="#缩小APK，增加下载量" class="headerlink" title="缩小APK，增加下载量"></a>缩小APK，增加下载量</h1><h2 id="你的APK大小是如何影响下载转化率的"><a href="#你的APK大小是如何影响下载转化率的" class="headerlink" title="你的APK大小是如何影响下载转化率的"></a>你的APK大小是如何影响下载转化率的</h2><img src="/2017/12/14/20171214-shrinking-apks-growing-installs/0.png">
<p>自从 Android Marketplace （Google Play 的前身）在 2012 年 3 月上线以来，<strong>app 的平均大小增长了四倍</strong>。随着移动 app 的不断成熟，开发者们不断增加新的特性来服务和吸引用户，这使不少人从中受益。然而，随着 app 的特性越来越多——更多 SDK、更高分辨率的图片、更好的图形—— APK 也变得越来越大。在本文中，我讨论了 APK 大小的重要性，并且分析了 Google 在过去 2 年中所做的用户体验研究的结果。<br><img src="/2017/12/14/20171214-shrinking-apks-growing-installs/1.png"></p>
<p>下载的 APK 的平均大小随时间的变化（Google 内部数据）</p>
<p>发现 APK 在变大之后，我们分析了 APK 大小对下载转化率的影响。我们发现，<strong>更小的 APK 对应着更高的下载转化率</strong>，对于新兴市场中的用户而言尤其如此。在许多开发者把注意力投入到向新市场（特别是新兴市场）扩张中去的情况下，关注 app 的大小就显得很重要。</p>
<h3 id="APK-大小是否会影响下载转化率？"><a href="#APK-大小是否会影响下载转化率？" class="headerlink" title="APK 大小是否会影响下载转化率？"></a><strong>APK 大小是否会影响下载转化率？</strong></h3><p>为了研究 APK 大小对用户的选择是否有显著影响，我们分析了<strong>用户在浏览了 Play store 中的一个项目之后成功下载这个 app 的百分比</strong>。</p>
<img src="/2017/12/14/20171214-shrinking-apks-growing-installs/2.png">
<p>在 App store  的相应页面中，你可以通过点击“Read More”看到一个 app 的大小。</p>
<p>这看起来还是有些意义的！总的来说，我们发现在小于 100 MB 的情况下，APK 大小和下载转化率之间存在负相关。<strong>一个 APK 的大小每增长 6 MB，下载转化率就有 1% 的降低</strong>。在市场团队使用 A/B 测试来优化下载转化率的情况下，APK 大小会有重大影响。</p>
<p>这个下降中的一个重要部分不是因为用户选择了不下载，而是下载由于种种原因没有成功。我们发现，一个 10MB 的 app 的下载完成率将比 100MB 的 app 高<strong>大约 30%</strong>。</p>
<p>这可能是因为：</p>
<ol>
<li>用户考虑了需要下载的数据量（以及数据的<strong>价格</strong>）。</li>
<li>在他们的移动网络或 wifi 中的 <strong>下载所需时间</strong> （人们经常陷入“我现在就要这个 app！”的思维模式）。</li>
<li>下载过程中的 <strong>网络连接性问题</strong>。</li>
</ol>
<h3 id="人们对-APK-大小的偏好和下载转化率是否会因地域而异？"><a href="#人们对-APK-大小的偏好和下载转化率是否会因地域而异？" class="headerlink" title="人们对 APK 大小的偏好和下载转化率是否会因地域而异？"></a><strong>人们对 APK 大小的偏好和下载转化率是否会因地域而异？</strong></h3><p>这是一个好问题，答案是肯定的。在新兴市场中，有许多没能使用到稳定 wifi 的用户，他们需要支付流量的费用。</p>
<p><strong>超过 50% 的印度和印尼安卓智能手机用户完全没有 wifi</strong>。所以如果一个用户需要下载一个 app，他很可能要为 APK 的每一 MB 付费（Google 内部数据，2017年）。</p>
<img src="/2017/12/14/20171214-shrinking-apks-growing-installs/3.png">
<p>印度 wifi 普及率调查 (Google 内部安卓用户调查)</p>
<p>与之相似, 出于流量价格和存储空间的考虑，<strong>新兴市场中大约 70% 的用户会在下载前考虑 app 的大小</strong>。</p>
<img src="/2017/12/14/20171214-shrinking-apks-growing-installs/4.png">
<p>被调查的印尼用户中会在安装时考虑 app 大小的人所占百分比 (Google 内部安卓用户调查)</p>
<img src="/2017/12/14/20171214-shrinking-apks-growing-installs/5.png">
<p>安装时会考虑 app 大小的用户这样做的原因 (Google 内部安卓用户调查)</p>
<p>我们可以看到，这些市场偏好非常显著。比如，新兴市场（如中东、非洲和东南亚）用户下载的 APK 的平均大小，<strong>是发达市场（如美国和西欧）的四分之一</strong>。</p>
<img src="/2017/12/14/20171214-shrinking-apks-growing-installs/6.png">
<p>APK 大小中位数，根据下载量加权，按市场分类。绿色 = 更大的中位数 APK 大小，红色 = 更小的 中位数 APK 大小（Google 内部数据）。</p>
<p>研究下载转化率数据，就可以发现新兴市场（如印度和巴西）和发达市场（如日本、美国和德国）相比，在面对越来越大的 APK 时会有不同的反应。</p>
<img src="/2017/12/14/20171214-shrinking-apks-growing-installs/7.png">
<p>APK 每缩小 10MB 对应下载转化率的增加，按市场分类（Google 内部数据）。</p>
<p>从上图中，我们可以看到 APK 缩小 10MB，在印度和巴西造成的影响会比德国、美国和日本更大。从 APK 中移除 10MB 内容，在新兴市场中对应着 <strong>下载转化率 2.5% 的增长</strong>。</p>
<p>让我们把实际的数字填入下载转化率的增长中：如果你的 app 在印度每个月有 10000 下载量，转化率 20%，缩小 10MB 可以使得下载量每月增加 1140 左右。</p>
<p>最后，当把非游戏的 app 和游戏比较时，我们可以在下载转化率和 APK 大小之间看到类似的关系。但是，对于超过 500MB 的游戏而言，用户们对于 APK 大小的微小变化更不敏感。对于 500-3000MB 的游戏而言，APK 每缩小 200MB，下载转化率只增加 1%。</p>
<h3 id="那么，我是否应该缩小-APK？如果应该，该怎么做？"><a href="#那么，我是否应该缩小-APK？如果应该，该怎么做？" class="headerlink" title="那么，我是否应该缩小 APK？如果应该，该怎么做？"></a><strong>那么，我是否应该缩小 APK？如果应该，该怎么做？</strong></h3><p>根据以上数据很容易看出，对于全世界人民来说 APK 大小都是很重要的。</p>
<p>“这很重要，” 你说，“但是我具体可以如何缩小 APK 呢？” 我很高兴你这样问了！缩小 APK 有以下几个入门要点：</p>
<ul>
<li><p><a href="https://developer.android.com/topic/performance/reduce-apk-size.html" target="_blank" rel="noopener"><strong>缩小 APK</strong></a>安卓开发者网站上的入门教材，它包含了移除不使用的资源和压缩图片文件。</p>
</li>
<li><p><a href="https://developer.android.com/develop/quality-guidelines/building-for-billions.html" target="_blank" rel="noopener"><strong>Building for Billions 指南</strong></a>, 在安卓开发者网站上，它讨论了缩小 APK，以及其它针对新兴市场的措施。</p>
</li>
<li><a href="https://medium.com/googleplaydev/how-to-optimize-your-android-app-for-emerging-markets-7124c4180fc" target="_blank" rel="noopener"><strong>如何针对新兴市场优化你的应用</strong></a>, 我们团队的另一篇 medium 文章。针对新兴市场，通过三个 app 去分析优化带来的好处。</li>
</ul>
<p>至于其他的针对新兴市场的考虑，可以去 Google Play 的 <a href="https://developer.android.com/topic/billions/index.html" target="_blank" rel="noopener">Building for Billions</a> 网站上寻找指导。</p>
<p>我花很多篇幅讨论了在新兴市场中缩小 APK 的好处。还有一个另外的缩小 APK 的原因，<br>这就是 Android Instant App 要求更小的 APK。Instant App 允许安卓用户不经过安装直接使用，是另一种让你的用户发现你的 app 的方式。关于开始使用 <a href="https://developer.android.com/topic/instant-apps/index.html" target="_blank" rel="noopener">Android Instant App</a>，你可以在这里找到更多信息。你也可以学习更多 <a href="https://android-developers.googleblog.com/2017/08/android-instant-apps-best-practices-for.html" target="_blank" rel="noopener">管理下载内容大小的最佳实践</a>。</p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/06/20171206-android-binder-theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="corresponding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corresponding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/06/20171206-android-binder-theory/" itemprop="url">浅谈Binder通信原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-06T19:48:09+08:00">
                2017-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <img src="/2017/12/06/20171206-android-binder-theory/banner.jpg" title="怀念夏日">
<h1 id="主要成员"><a href="#主要成员" class="headerlink" title="主要成员"></a>主要成员</h1><p>我们先来梳理下Binder通信的几个重要的成员：<br>1.Binder驱动<br>2.应用<br>3.系统服务<br>4.Binder<br>其中应用和系统服务处于不同的进程，由靠Binder驱动进行信息交互。</p>
<p>在网购如此发达的现在，人人都清楚淘宝上的聊天流程。<br>在这个过程中，也有对应的部分：<br>1.淘宝<br>2.用户<br>3.店家<br>4.聊天窗口</p>
<p>注：真实的淘宝通信系统肯定有所不同，这里仅提取与Binder通信相近之处。<br>再注：本来想举微信聊天的例子，但是微信聊天中客户端和服务端的属性没那么明显，所以选择淘宝聊天流程。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">应用和系统服务处于不同进程              用户没在商家身边</span><br><span class="line">应用无法直接调用系统服务中函数          用户直接和商家口头对话</span><br><span class="line">应用需要通过<span class="keyword">Binder驱动去与系统服务通信 </span> 用户需要通过淘宝去和店家联系</span><br><span class="line"><span class="keyword">Binder驱动中管理各个Binder </span>             淘宝管理用户和商家的“聊天窗口”对象</span><br><span class="line">应用可以访问到指定地址                  用户可以访问到指定“聊天窗口”</span><br><span class="line">系统服务也可以访问到同一个地址          商家可以访问到同一个“聊天窗口”  </span><br><span class="line">应用和系统服务都监听这个地址中内容变化  用户和商家都关注这个“聊天窗口”，看到对方发信息过来，处理后回复</span><br></pre></td></tr></table></figure>
<h2 id="聊天窗口"><a href="#聊天窗口" class="headerlink" title="聊天窗口"></a>聊天窗口</h2><p>在用户和商家通信过程中，什么东西最重要呢？其实就是“聊天窗口”。<br>假设我们设计一个聊天系统，“聊天窗口”会有哪些重要的属性？<br>1.它是一个对象；<br>2.淘宝系统内部有一个地址k可以访问到它；<br>3.一端是用户，可以通过地址c访问到它；<br>4.另一端是商家，可以通过地址s访问到它。</p>
<p>同时也要需要解决很多问题，比如：<br>1.如何让用户联系到商家；<br>2.一个用户需要同事联系多个商家;<br>2.一个商家需要同时服务多个用户；<br>3.会不会有人把自己伪造成其他人等等。</p>
<h2 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h2><p>与“聊天窗口”类似，Binder也有对应的属性：<br>1.它是一个对象；<br>2.Binder驱动有一个地址k可以访问到它；<br>3.一端是应用，可以通过地址c访问到它；<br>4.另一端是系统服务，可以通过地址s访问到它。</p>
<p>同样也需要解决很多问题，比如：<br>1.如何让应用联系到系统服务；<br>2.一个应用需要同事联系多个系统服务;<br>2.一个系统服务需要同时服务多个应用；<br>3.会不会有应用把自己伪造成其他应用等等。</p>
<h1 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h1><p>让我们看看，用户如何联系到商家：</p>
<img src="/2017/12/06/20171206-android-binder-theory/binder_associate_taobao.png" title="淘宝聊天流程图">
<p>同样在Binder中，也有一套这样的流程：</p>
<img src="/2017/12/06/20171206-android-binder-theory/binder_associate.png" title="建立Binder流程图">
<p>这张图片清晰表述了整个流程<br>1.打开Binder驱动；<br>2.将系统服务中地址s和Binder驱动中地址k指向同一地址；<br>3.将应用地址c和Binder驱动中地址k指向同一地址。<br>整个过程结束后，应用中地址c和系统服务中地址s也指向同一地址。这样两个不同的进程就关联成功了。</p>
<h1 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h1><p>其中有一个重要的问题，应用如何找到Binder驱动中的地址k？<br>在每次Android重启后，Binder驱动中地址k都不相同，应该怎么办？</p>
<p>怎么解决这个问题呢？<br>首先想到的方法，每次都记录下这些服务，下次启动时从备份文件中读取。<br>这个方法看上去很干脆利落，但是有一个风险。<br>如果上次服务发生异常，备份文件中也记录错误的数据，那这个手机就完了，永远无法启动。</p>
<p>需要改变下策略，希望每次Android系统重启时，这些系统服务都是新生成的。<br>这些系统服务启动时没有历史包袱一身轻松，然后愉快的注册到服务管理中心中。<br>应用只需要向服务管理中心查询服务名，就可以获取到地址k。</p>
<p>在Binder通信，这个服务管理中心就是ServiceManager，它管理所有的服务。<br>主要完成这两项任务：<br>1.所有的系统服务启动时，需要把服务名字和服务记录到ServiceManager中；<br>2.所有的应用使用指定系统服务前，先根据服务名称去向ServiceManager索要服务。</p>
<p>注：上面步骤中，按照C/S架构中划分：<br>1.系统服务是客户端，ServiceManager是服务端；<br>2.应用是客户端，ServiceManager是服务端。</p>
<p>我们看下Binder通信流程图：<br><img src="/2017/12/06/20171206-android-binder-theory/binder_simple.png" title="Binder简略流程图"></p>
<p>再加入Binder驱动元素:<br><img src="/2017/12/06/20171206-android-binder-theory/binder_full.png" title="Binder完整流程图"></p>
<p>回到我们的例子，淘宝也有一个ServiceManager的角色，就是店铺黄页。<br>店铺黄页管理所有的店铺，也完成两项任务：<br>1.每个商家上线后都会去淘宝黄页注册，比如Nike店铺注册Nike；<br>2.用户去淘宝黄页询问Nike的商家，获取聊天窗口中店铺的地址。</p>
<p>这时细心的读者会发现一个问题，ServiceManager呢，这些系统服务和应用怎么找到它呢？<br>为了解决这个问题，Android系统不得不做例外处理：<br>1.在Android启动后，ServiceManager第一个初始化；<br>2.将自己编号设为0。<br>之后，无论是应用或者系统服务，都可以通过编码0访问到ServiceManager。</p>
<hr>
<p>后记：在上大学时去图书馆随便翻书看过到多米尼克，感慨这个世界群星璀璨，有各种天才。<br>他发明的多米尼克训练法，告知人们需要用串联、转化、联想等等法则去记忆。<br>在学习Android底层中，有太多的对象和函数，如果能将其中主要流程和真实生活产生对应，会加速学习过程，而且印象深刻。</p>
<img src="/2017/12/06/20171206-android-binder-theory/DominicOBrien.jpg" title="Dominic O" alt="Brien">
<p>多米尼克·奥布莱恩，1957年8月10出生于英国。1991年，他参加了由“世界大脑先生”托尼·布赞发起的第一届世界记忆锦标赛，凭其独创的“多米尼克记忆系统”，38秒记住一副扑克牌的顺序，30分钟记住2385个随机产生的数字，1个小时记住110种元素的原子序数、符号、类别和精确到4位小数的原子量，一时技惊四座，横扫所有对手，获得第一届世界记忆锦标赛的总冠军。此后十余年间，他先后获得8次世界记忆冠军，几乎打破所有记忆领域的世界纪录，成为举世公认的“世界首席记忆大师”。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/28/20171128-android-initiate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="corresponding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corresponding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/28/20171128-android-initiate/" itemprop="url">追溯Android的根源</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-28T19:33:32+08:00">
                2017-11-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <img src="/2017/11/28/20171128-android-initiate/android-initiate_head.jpg" title="创世纪">
<p>某日进去一小区被保安拦住，被问了三个哲学问题：<br>“你是谁？”<br>“你从哪里来？”<br>“你要到哪里去？”<br>于是我陷入了深深的沉思。</p>
<p>同样，学习Android也有三个终极问题：<br>什么是Android？<br>Android世界的起源？<br>Android中APP是怎么运行的？</p>
<p>对于第一个问题，大家都能很快的回答出来。简单来说，Android是一种基于Linux，主要用于移动设备的操作系统。<br>第三个问题这样回答：APP的屏幕显示、输入事件获取、视频、音频等各个功能，在Android底层都有其对应的系统服务。<br>当然其中涉及到ActivityManagerService，WindowManagerService等等，后续有空会展开分析。<br>今天，我们来好好地看下第二个问题，Android系统是如何启动的，探讨下Android系统的起源。</p>
<hr>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><h2 id="main"><a href="#main" class="headerlink" title="main()"></a>main()</h2><p>就像我们编写的第一行代码helloworld一样，main()是helloworld世界的入口。<br>在Android中，main()也是Android世界的第一个入口，这个入口的位置在system\core\init\init.cpp。</p>
<p>main()主要工作：<br>    1.参数校验<br>    2.挂载一些设备，设置权限（与传统Linux程序相同）<br>    3.初始化环境<br>    4.LoadBootScripts()加载待启动项<br>    5.处理待启动项</p>
<h2 id="LoadBootScripts"><a href="#LoadBootScripts" class="headerlink" title="LoadBootScripts()"></a>LoadBootScripts()</h2><p>作用就是，加载引导的脚本init.rc，所有开机需要启动的配置读写在这里面。<br>像Android这样完善而又庞大的系统，在开机时肯定要启动有无数的服务。<br>如果全部都写到函数中，想必会变成硬编码，不方便于配置，所以这里用脚本方式配置启动内容。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadBootScripts</span><span class="params">(ActionManager&amp; action_manager, ServiceList&amp; service_list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成解析器</span></span><br><span class="line">    Parser parser = CreateParser(action_manager, service_list);</span><br><span class="line">    <span class="comment">// 解析文件内容后，放入action_manager和service_list中</span></span><br><span class="line">    parser.ParseConfig(<span class="string">"/init.rc"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="init-rc"><a href="#init-rc" class="headerlink" title="init.rc"></a>init.rc</h2><p>该文件放在system\core\rootdir目录下<br>节选下其中重要的片段<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line">    class main</span><br><span class="line">    priority -20</span><br><span class="line">   <span class="built_in"> user </span>root</span><br><span class="line">   <span class="built_in"> group </span>root readproc</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    onrestart write /sys/android_power/request_state wake</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    onrestart restart wificond</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br></pre></td></tr></table></figure></p>
<p>这段代码表示：启动名为zygote的Service。zygote翻译过来是“受精卵”，可以孕育出新生命。<br>在Android中，zygote也是万物的起源。<br>这段代码清晰的指出了Zygote的代码入口：app_process。</p>
<h2 id="app-process"><a href="#app-process" class="headerlink" title="app_process"></a>app_process</h2><p>上面同样表示app_process是在目录/system/bin/中，不过因为这应该是软链接后的位置，<br>真实的位置在frameworks\base\cmds\app_process\App_main.cpp，而且入口也是main()。<br>这里截取其中的重要代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里有两个变量去控制新进程的诞生</span></span><br><span class="line">    <span class="keyword">bool</span> zygote = <span class="literal">false</span>;                <span class="comment">// 是否为zygote进程</span></span><br><span class="line">    <span class="keyword">bool</span> startSystemServer = <span class="literal">false</span>;     <span class="comment">// 是否启动系统服务，例如ActivityManagerService等</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; argc) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--zygote"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            zygote = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--start-system-server"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            startSystemServer = <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按照之前的入参--zygote --start-system-server分析，发现zygote和startSystemServer都被设置为true</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;   </span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args, zygote);  <span class="comment">// 终于接近zygote真实本体了！</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里看下runtime，是AppRuntime类。我们赶紧去寻找下它的start方法吧。<br>发现AppRuntime继承于AndroidRuntime，AndroidRuntime中提供start()方法</p>
<h2 id="AndroidRuntime"><a href="#AndroidRuntime" class="headerlink" title="AndroidRuntime"></a>AndroidRuntime</h2><p>位于frameworks\base\core\jni\AndroidRuntime.cpp中<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AndroidRuntime::start(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 开启virtual machine，这里env是JNIEnv*类型，指向整个Android的JNI世界</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    startVm(&amp;mJavaVM, &amp;env, zygote);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 给虚拟机注册JNI的函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    startReg(env);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 调用JNI static方法，启动zygote</span></span><br><span class="line"><span class="comment">    * 这里startClass是com.android.internal.os.ZygoteInit类</span></span><br><span class="line"><span class="comment">    * startMeth是startClass中的main()方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="startVm"><a href="#startVm" class="headerlink" title="startVm()"></a>startVm()</h3><p>这个函数有一超级长的check，最关键是最后一句JNI_CreateJavaVM(pJavaVM, pEnv, &amp;initArgs);<br>完成这个函数后，VM正式创建成功，后续可以开始通过JNI对native底层代码进行调用了。</p>
<h3 id="startReg"><a href="#startReg" class="headerlink" title="startReg()"></a>startReg()</h3><p>这个函数中，最重要的是register_jni_procs(gRegJNI, NELEM(gRegJNI), env)<br>其中gRegJNI表示待注册的JNI函数，截取一段给大家看看<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> RegJNIRec gRegJNI[] = &#123;</span><br><span class="line">    REG_JNI(register_android_os_Process),</span><br><span class="line">    REG_JNI(register_android_os_SystemProperties),</span><br><span class="line">    REG_JNI(register_android_os_Binder),</span><br><span class="line">    REG_JNI(register_android_os_Parcel),</span><br></pre></td></tr></table></figure></p>
<p>发现原来Parcel、Binder等等Android独有的特性都在此处被注册，后面就可以通过JNI方式直接调用。</p>
<h3 id="env-gt-CallStaticVoidMethod"><a href="#env-gt-CallStaticVoidMethod" class="headerlink" title="env-&gt;CallStaticVoidMethod"></a>env-&gt;CallStaticVoidMethod</h3><p>根据这个函数的入参，可以得知最后调用com.android.internal.os.ZygoteInit的main()函数。<br>从类名上可以推测出，这负责zygote的生成。</p>
<h2 id="zygoteInit-main"><a href="#zygoteInit-main" class="headerlink" title="zygoteInit.main()"></a>zygoteInit.main()</h2><p>对应的文件为frameworks\base\core\java\com\android\internal\os\ZygoteInit.java<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> argv[]) &#123;</span><br><span class="line">    <span class="comment">// 注册server socket，这里采用socket方式和其他进程通信</span></span><br><span class="line">    zygoteServer.registerServerSocket(socketName);</span><br><span class="line">    <span class="comment">// 加载classes,opengl,textsource等各种资源</span></span><br><span class="line">    preload(bootTimingsTraceLog);</span><br><span class="line">    <span class="comment">// 开启新进程，用以启动system server</span></span><br><span class="line">    <span class="built_in">if</span> (startSystemServer) &#123;</span><br><span class="line">        Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line">        r.<span class="built_in">run</span>();</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化zygote</span></span><br><span class="line">    caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">    caller.<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>说了这么多，大家一定被绕晕了吧，这里整理一张流程图，大家可以对着看。<br><img src="/2017/11/28/20171128-android-initiate/android_initiate.png" title="Android启动流程图"></p>
<p>这里走向两个分支，我们接下去也分开去介绍zygote和System server初始化。</p>
<h1 id="zygote"><a href="#zygote" class="headerlink" title="zygote"></a>zygote</h1><p>zygote，这是一个平凡而又伟大的进程，以后Android的所有进程都由他诞生。<br>我们继续来看下zygoteInit.main()中走向zygote分支的流程，后续调用zygoteServer.runSelectLoop()。</p>
<h2 id="zygoteServer-runSelectLoop"><a href="#zygoteServer-runSelectLoop" class="headerlink" title="zygoteServer.runSelectLoop()"></a>zygoteServer.runSelectLoop()</h2><p>对应的文件为frameworks\base\core\java\com\android\internal\os\zygoteServer.java<br>其主要功能是，不断接受请求并作出响应。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Runnable runSelectLoop(<span class="built_in">String</span> abiList) &#123;</span><br><span class="line">    <span class="comment">// 不断循环，接受并处理新请求</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 监听数据源</span></span><br><span class="line">        Os.poll(pollFds, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="comment">// 解析出数据源的命令</span></span><br><span class="line">            ZygoteConnection connection = peers.<span class="keyword">get</span>(i);</span><br><span class="line">            <span class="keyword">final</span> Runnable command = connection.processOneCommand(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> commond;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>zygote是采用poll的方式去监听数据源。<br>注：poll 是 Linux API 提供的复用方式。IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。<br>至此，zygote会处于runSelectLoop()的循环中，不断监听外部请求并作出响应，fork出进程。</p>
<h1 id="system-server"><a href="#system-server" class="headerlink" title="system server"></a>system server</h1><p>在android的启动过程中，我们也需要启动各种应用服务，我们来找下有他们是怎样诞生的。</p>
<h2 id="forkSystemServer"><a href="#forkSystemServer" class="headerlink" title="forkSystemServer()"></a>forkSystemServer()</h2><p>这个也在zygoteInit.main()中被调用到，上面已经有提及，这里就不重复列出了。<br>在这里发现了zygote的作用，zygote把自己的进程fork一份，用来启动各大系统服务。<br>zygote进程就像受精卵一样，慢慢分裂诞生出整个Android系统，并且在后续中，新进程的诞生也依赖与zygote的fork。<br>截取其中的重要代码<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Runnable forkSystemServer(）&#123;</span><br><span class="line">    pid = Zygote.forkSystemServer(</span><br><span class="line">                    parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                    parsedArgs.gids,</span><br><span class="line">                    parsedArgs.runtimeFlags,</span><br><span class="line">                    <span class="keyword">null</span>,</span><br><span class="line">                    parsedArgs.permittedCapabilities,</span><br><span class="line">                    parsedArgs.effectiveCapabilities);</span><br><span class="line">                    </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">handleSystemServerProcess</span><span class="params">(parsedArgs)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="handleSystemServerProcess"><a href="#handleSystemServerProcess" class="headerlink" title="handleSystemServerProcess()"></a>handleSystemServerProcess()</h2><p>handleSystemServerProcess()这个函数完成了fork后的剩余工作<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function">Runnable <span class="title">handleSystemServerProcess</span><span class="params">(ZygoteConnection.Arguments parsedArgs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加载system server dex的option</span></span><br><span class="line">    performSystemServerDexOpt(systemServerClasspath);</span><br><span class="line">    <span class="comment">// 启动system server </span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> ZygoteInit.<span class="title">zygoteInit</span><span class="params">(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ZygoteInit-zygoteInit"><a href="#ZygoteInit-zygoteInit" class="headerlink" title="ZygoteInit.zygoteInit()"></a>ZygoteInit.zygoteInit()</h2><p>从函数命名来看，这是各大应用服务的初始化地址。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="function">Runnable <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// native层的初始化system server</span></span><br><span class="line">    ZygoteInit.nativeZygoteInit();</span><br><span class="line">    <span class="comment">// 返回java层初始化system server的runnable，后续必然有run()的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> RuntimeInit.<span class="title">applicationInit</span><span class="params">(targetSdkVersion, argv, classLoader)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="RuntimeInit-applicationInit"><a href="#RuntimeInit-applicationInit" class="headerlink" title="RuntimeInit.applicationInit()"></a>RuntimeInit.applicationInit()</h2><p>越来越接近真相了，再坚持一会。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected static Runnable applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) &#123;</span><br><span class="line">    <span class="regexp">//</span> 未来app调用<span class="keyword">exit</span>()会直接退出，不会清理进程</span><br><span class="line">    nativeSetExitWithoutCleanup(true);</span><br><span class="line">    <span class="regexp">//</span> 寻找最终的类以及方法</span><br><span class="line">    return findStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="findStaticMain"><a href="#findStaticMain" class="headerlink" title="findStaticMain()"></a>findStaticMain()</h2><p>从函数命名可以看出，这回找到服务的main()函数并调用。<br>这里说明良好的说明有多重要，可以让其他开发者在阅读纯代码时就能get到函数的含义。<br>这里列下findStaticMain()的重要片段<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Runnable findStaticMain(String className, String[] argv, ClassLoader classLoader) &#123;</span><br><span class="line">    <span class="keyword">Class</span>&lt;?&gt; cl = <span class="keyword">Class</span>.forName(className, <span class="keyword">true</span>, classLoader);          <span class="comment">// 找到对应的类SystemServer</span></span><br><span class="line">    Method m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> <span class="keyword">Class</span>[] &#123; String[].<span class="keyword">class</span> &#125;);    <span class="comment">// 找到其中的main()函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MethodAndArgsCaller(m, argv);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="MethodAndArgsCaller"><a href="#MethodAndArgsCaller" class="headerlink" title="MethodAndArgsCaller"></a>MethodAndArgsCaller</h2><p>这是一个实现runnable的类，里面主要的run()就是去执行之前找到的method<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAndArgsCaller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ZygoteInit-main"><a href="#ZygoteInit-main" class="headerlink" title="ZygoteInit.main()"></a>ZygoteInit.main()</h2><p>我们继续回到ZygoteInit.main()<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> argv[]) &#123;</span><br><span class="line">    <span class="comment">// 回到最开始出发的地方，这里r</span></span><br><span class="line">    Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line">    <span class="comment">// 接下去果然是run，其中运行SystemServer.main()</span></span><br><span class="line">    <span class="built_in">if</span> (r != null) &#123;</span><br><span class="line">        r.<span class="built_in">run</span>();</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="SystemServer-main"><a href="#SystemServer-main" class="headerlink" title="SystemServer.main()"></a>SystemServer.main()</h2><p>这个函数里面就一句话，调用同一个类的run()<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">    <span class="keyword">new</span> SystemServer().<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="SystemServer-run"><a href="#SystemServer-run" class="headerlink" title="SystemServer().run()"></a>SystemServer().run()</h2><p>看来这个是SystemServer的启动地了，看下其中的关键代码<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">private</span> <span class="selector-tag">void</span> <span class="selector-tag">run</span>() &#123;</span><br><span class="line">    <span class="comment">// 准备主线程的Looper</span></span><br><span class="line">    <span class="selector-tag">Looper</span><span class="selector-class">.prepareMainLooper</span>();</span><br><span class="line">    <span class="comment">// 加载native的服务</span></span><br><span class="line">    <span class="selector-tag">System</span><span class="selector-class">.loadLibrary</span>(<span class="string">"android_servers"</span>);</span><br><span class="line">    <span class="comment">// 开启各项系统服务</span></span><br><span class="line">    <span class="selector-tag">startBootstrapServices</span>();</span><br><span class="line">    <span class="selector-tag">startCoreServices</span>();</span><br><span class="line">    <span class="selector-tag">startOtherServices</span>();</span><br><span class="line">    <span class="comment">// 开启Looper循环，不断监听事件</span></span><br><span class="line">    <span class="selector-tag">Looper</span><span class="selector-class">.loop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，system server全部启动成功，并且开启Looper循环，会不断监听外来的请求并响应。</p>
<p>这里也梳理下system server整个启动过程。<br><img src="/2017/11/28/20171128-android-initiate/android_systemserver.png" title="system server 启动流程图"></p>
<hr>
<p>我们已经清晰的梳理出Android的大致的启动流程。<br>可以结合上一篇文章《浅谈Android底层》一起看。上篇文章，在用户角度从表面慢慢推进到底层system server（包括ServiceManager、AMS、WMS等等）。再进一步，就是追溯这些zygote和system server的起源。</p>
<p>作为应用开发者，只需要完成两部：<br>1.配置AndroidManifest.xml的启动项<br>2.实现对应的Activity<br>就能完成最简单的应用。但是我始终会好奇其背后的神秘而又精密的机制。</p>
<p>我们身上始终留着追溯根源的血液。就像在遥远的古代，刀耕火种的人类在漫天星空下去追溯祖先的由来，构想了无数种文明的起源。此时，作为应用开发者，我们也在追溯Android系统的起源。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/22/20171122-touch-android-groundwork/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="corresponding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corresponding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/22/20171122-touch-android-groundwork/" itemprop="url">浅谈Android底层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-22T20:24:35+08:00">
                2017-11-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="学习的原因"><a href="#学习的原因" class="headerlink" title="学习的原因"></a>学习的原因</h1><blockquote>
<p>很多应用开发者对Android底层望而却步，主要有两个原因：<br>1.底层太难，我看不懂<br>2.学习底层知识对目前开发没有帮助</p>
</blockquote>
<h2 id="对于太难的这点"><a href="#对于太难的这点" class="headerlink" title="对于太难的这点"></a>对于太难的这点</h2><p>我觉得是因为一开始直接扑进源码里面，看到那些一长串一长串的函数，很容易看得晕头转向，恶心想吐。如果掌握合适的学习方法，会发现其实并没有这么困难。<br>我建议，在看源码前先理清Android底层的主干逻辑，再拆解出各个模块，各个击破。</p>
<h2 id="对于无帮助这点"><a href="#对于无帮助这点" class="headerlink" title="对于无帮助这点"></a>对于无帮助这点</h2><p>我觉得Android底层知识的即时回报非常小，但是长期回报是巨大的。<br>如果能熟悉Android底层的原理，当在开发中遇到一些奇奇怪怪的问题时，我们可以通过debug和查看log等方式，结合底层原理去发现蛛丝马迹，真正解决一部分烦人的小概率bug。而且熟悉android底层的设计架构，在未来做软件架构设计时，可以参考借鉴，甚至可以在此基础上设计出更棒的架构。<br>这话听上去觉得特别夸张，其实不然，有两点原因：<br>1.Android底层的架构也在不断调整和优化中，这说明目前的不是最优解；<br>2.Android更新迭代了这么多版本，需要兼容旧版本，有些地方不能完全放开去设计，需要在兼容和完全优化中做选择。</p>
<hr>
<p>作者在学习过程中，尝试按照自己的思路总结Android底层主干逻辑。肯定会有许多不足之处，希望大家多多指出。<br>由表到底，分成三层：</p>
<blockquote>
<p>1.应用程序背后：Android的各大系统服务<br>2.如何获取这些系统服务：ServiceManager<br>3.如何通信：Binder体系</p>
</blockquote>
<h1 id="应用程序背后：Android的各大系统服务"><a href="#应用程序背后：Android的各大系统服务" class="headerlink" title="应用程序背后：Android的各大系统服务"></a>应用程序背后：Android的各大系统服务</h1><p>这里首先要说明下，ActivityManagerService等各种应用服务，虽然说以Service结尾，但是这与Android四大组件Service并无关系。四大组件中的Service，主要提供需要在后台长期运行的服务（如复杂计算、下载等等）；这里的Service代表Client/Server架构中的Server。</p>
<p>Client/Server架构简称为C/S架构，也是客户端/服务器端架构。服务器端主要提供数据管理、数据共享、数据及系统维护和并发控制等，客户端程序主要完成用户的具体的业务。<br>在Android系统中，Client就是我们写的各种应用程序，Server实现页面跳转，屏幕展示等功能细节。Client向Server发出命令，Server去实现完整的功能。</p>
<blockquote>
<p>注：Client/Server架构是Server，我们说的Android系统服务是Service。虽然说都是表示“服务”，建议还是注意下拼写，方便更好区分。</p>
</blockquote>
<h2 id="我举一个简单的例子"><a href="#我举一个简单的例子" class="headerlink" title="我举一个简单的例子"></a>我举一个简单的例子</h2><blockquote>
<p>应用开发者常见的工作是，去实现一个Activity并且显示在手机屏幕上。<br>对于最简单的页面，开发者只要做三步：<br>1.AndroidManifest文件加入声明<br>2.Activity中设置setContentView<br>3.调用startActivity()去启动（发出指令，后续系统Service去实现）</p>
</blockquote>
<p>在背后辛勤工作的就是Android的各大系统服务，例如ActivityManagerService（后续简称AMS）主要管理Activity运行状态，WindowManagerService（后续简称WMS）主要负责控制手机屏幕显示内容。</p>
<h1 id="如何获取这些系统服务：ServiceManager"><a href="#如何获取这些系统服务：ServiceManager" class="headerlink" title="如何获取这些系统服务：ServiceManager"></a>如何获取这些系统服务：ServiceManager</h1><p>上一节简单的描述了下应用通过各大系统服务去完成Activity生成和屏幕显示。<br>这里就会有个问题，我们如何去获取这些服务。在应用开发中，如果我们需要使用第三方控件OkHttp，我们需要导入okhttp包，或者在gradle中写入对其的依赖，之后我们才可以调用OkHttp中的对象和方法。</p>
<p>在Android底层也是类似，其中有一个ServiceManager在统筹管理所有的服务。<br>还是采用上节说的C/S架构，应用程序是客户端，向ServiceManager服务端发起请求获取指定name的服务，要求服务端给与AMS的访问引用。<br>应用程序持有AMS的引用后，继续采用C/S架构。应用本身还是客户端，此时AMS充当服务端，处理服务端发起的各种Activitiy请求。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_01.png" title="Activity&AMS&WMS">
<p>这个时候就继续思考一步，AMS、WMS这些系统服务如何和ServiceManager建立联系的呢？<br>这是在Android手机开机时，AMS、WMS会向ServiceManager注册，将自己的name和实体传给ServiceManager，ServiceManager中会有专门的数据结构（红黑树）去记录这些数据。<br>注：这里还是采用C/S架构，不过AMS变成了客户端，ServiceManager变成服务端。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_02.png" title="AMS&ServerManager&APP">
<p>再再深入一步，我们需要通过ServiceManager获取其他服务，那我们怎么获取ServiceManager呢？<br>这里ServiceManager充当大管家的角色，是在开机时最先被创造的服务，并且被赋予0的代号。所有的服务都要先请示ServiceManager。<br>注：匿名服务除外，匿名服务不需要注册在ServiceManager。当前连接的服务直接传递匿名服务给应用。<br>后续启动的服务都可以根据0去找到ServiceManager，并且把自己注册进去。<br>注：这里还是采用C/S架构，不过AMS变成了客户端，ServiceManager变成服务端。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_03.png" title="AMS&system">
<p>至此我们把获取系统服务，从表到里分析了一遍。我们再换一个维度，以时间发展表述下。<br>注：学习的时候要时刻记住，所有的对象都不是直接持有，需要通过各种请求获取后才持有。<br>再注：这里的持有不一定是持有实体，可能是种引用。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_04.png" title="AMS&ServerManager&system">
<h1 id="如何通信：Binder体系"><a href="#如何通信：Binder体系" class="headerlink" title="如何通信：Binder体系"></a>如何通信：Binder体系</h1><p>上面我们了解了系统服务的作用和如何获取系统服务，还有一个更加基础的问题，应用如何和这些系统服务通信。</p>
<blockquote>
<p>在Android中，各个应用和各个服务处于不同的进程。就不能像进程内编程一样直接调用其他类的函数，需要进程间的通信（IPC：Inter-Process Communication）<br>这里Android采用Binder方式。</p>
</blockquote>
<p>这里思考下，Linux IPC常见的有pipe、socket、共享内存等等，为什么最后Android会选择Binder呢？<br>Android之间有大量的跨进程通信，对性能、安全性、易用性要求都很高，综合考虑后选择了Binder方式。</p>
<h2 id="继续问，Binder的性能优势？"><a href="#继续问，Binder的性能优势？" class="headerlink" title="继续问，Binder的性能优势？"></a>继续问，Binder的性能优势？</h2><p>socket主要用于网络通信，以TCP/IP作为基础，需要分包、重组等工作，所以效率递比较底下。<br>注：Android有采用Unix Domain Socket(UDS)，针对进程间通信优化。在Android中也有使用，这里暂不讨论。</p>
<p>pipe采用消息转发机制，需要两次拷贝。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_05.png" title="pipe">
<p>Binder在数据传输过程中，只需要一次拷贝。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_06.png" title="Binder">
<p>经过上述操作后，服务端地址s和客户端地址c指向同一块内存。<br>服务端想与客户端通信时，就将本地内容拷贝到地址s中，客户端在同时监听地址c中的内存变化，及时获取新信息。</p>
<h2 id="Binder的安全性优势？"><a href="#Binder的安全性优势？" class="headerlink" title="Binder的安全性优势？"></a>Binder的安全性优势？</h2><p>一般的Linux IPC在通信时，请求方会发送user id(uid)和process id(pid)，服务方后根据此去检查请求方的权限，判断后续是否给与服务。<br>看上去特别安全，但是根源上出现了问题，uid和pid是请求方添加的。这意味着，请求方A可以修改uid和pid，设置成B一样。服务端是没有办法识别出来，这样安全性就无法保障了。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_07.png" title="传统IPC">
<p>Binder优化了uid和pid机制，不再由请求方自己添加，而是由内核自动添加。</p>
<img src="/2017/11/22/20171122-touch-android-groundwork/1122_08.png" title="Binder安全性">
<h2 id="Binder的易用性优势？"><a href="#Binder的易用性优势？" class="headerlink" title="Binder的易用性优势？"></a>Binder的易用性优势？</h2><p>采用C/S架构，应用和服务分离，逻辑清晰。<br>应用持有一个服务的引用，向该引用发起各种请求，引用内部在通过Binder的细节传输给正式的服务，应用开发者不需要管通信的细节。反之，像Linux IPC的共享内存，虽然不需要拷贝，性能特别高。但是使用起来特别复杂，应用开发者需要控制管理服务的内存。</p>
<p>至此，简单的讲述下了《Android的各大系统服务》，《如何获取这些系统服务：ServiceManager》，《如何通信：Binder体系》。当然，本篇只是描述下系统服务的最表层，背后还有许许多多的代码细节和设计者巧妙构思，后续出相关的文章和大家展示。</p>
<blockquote>
<p>里面出现最多的字样就是C/S架构，大家在学习中牢记这个架构，Android底层所有的细节都围绕这个展开。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/20/20171120-defensive-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="corresponding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corresponding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/20/20171120-defensive-code/" itemprop="url">防御式编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-20T18:50:20+08:00">
                2017-11-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/coding/" itemprop="url" rel="index">
                    <span itemprop="name">coding</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在我自己的编码工作中，调bug的时间至少占总时间的50%。<br>有些时候修复一个的bug甚至会占用几天的时间，最后发现问题出在几天没加条件预防的语句，这太让人恼火了。<br><br>我总是在苦恼，为何我的程序有这么多闪退。<br>为什么就不能有一个安全的编程环境给我们，让我们这些菜鸟写的代码不闪退。</p>
<blockquote>
<p>代码世界中危机丛生，程序跑着跑着就要歇菜。</p>
</blockquote>
<p>随着发际线的慢慢后退，我开始认清一个令人感觉残酷的现实：<br>这是你的代码，你需要为其付所有责任，包括最基础的安全性检查。</p>
<blockquote>
<p>慢慢的我们需要变得保守，不能轻易相信所有的数据，需要在使用前对其检查。</p>
</blockquote>
<hr>
<h1 id="防御式编程"><a href="#防御式编程" class="headerlink" title="防御式编程"></a>防御式编程</h1><p>原则：就是对来源数据持怀疑、不信任的态度<br>对调用者含有敌意，他们可能会放入各种奇怪的未经检查的数据。<br>其中最常用的就是null的判断。</p>
<p>在面向对象的编程中，任何一个对象都初始为null（final和 static关键字声明的变量除外）<br>当然，在一般情况下，变量会在使用前被赋值。<br>当调用null对象的方法时，会抛出NullPointerException。<br>如果没有及时对Exception进行捕获，程序就会报错。</p>
<h2 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h2><p>这里有常用的两种处理方法，两者相互合作，相辅相成。</p>
<h3 id="变量的预先检查"><a href="#变量的预先检查" class="headerlink" title="变量的预先检查"></a>变量的预先检查</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span>(<span class="params">Model arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == arg) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// arg的合理性检查</span></span><br><span class="line">        arg.<span class="keyword">do</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果变量不符合要求，后续代码无法继续执行。<br>可以改成如下方式：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Model arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == arg) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arg不符合要求) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异常后处理"><a href="#异常后处理" class="headerlink" title="异常后处理"></a>异常后处理</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="keyword">func</span><span class="params">(Model arg)</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        arg.<span class="keyword">do</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="type">NullPointerException</span> e) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="type">Exception</span> e) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>合理的使用Exception，能帮助我们更好的代码分层。</p>
</blockquote>
<p>Exception它可以报错误上报给调用链的上层。<br>每个函数都有他的职责范围和处理错误的范围，底层函数不需要处理所有的Exception，他可以将自己无法处理的Exception交给上级。</p>
<h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p>有人会有疑问：每个函数进入处都进行合理性检查，会不会特别降低效率。</p>
<p>对于一般的应用代码而言，这里的开销微乎其微，不用特别在意。<br>现有编译器都会帮用户做性能上优化。<br>如果对于底层或SDK的代码来说，还是需要注意下。</p>
<h2 id="每次都检查，烦"><a href="#每次都检查，烦" class="headerlink" title="每次都检查，烦"></a>每次都检查，烦</h2><p>有人表示：我倒是不纠结与性能，但是在一个深度调用链，每个函数都要写一遍参数检查，又繁琐又影响阅读。<br>我之前也一直在纠结这个问题，觉得很难控制这个度。后来在看Android源码，终于有点想明白了，可以靠函数名传递一些有用信息。（源码真是博大精深，里面有各种精巧的函数设计）<br>这是在ActivityManagerService启动Activity过程中，调用各种startActivityXXX函数。<br>下面简单罗列下</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">startActivityAsUser</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">startActivityMayWait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">startActivityLocked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">startActivityCheckedLocked</span><span class="params">()</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里可以发现，函数中名有Checked和Locked。</p>
</blockquote>
<p>checked表示已经检查过了各种权限，Locked表示处于线程安全的情况下。<br>如果我们需要写几个深度调用函数时，某些可以使用checked字样，就不用重复的做参数检查。</p>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>对于某些赋值后内容不会改变的变量（读上去有点拗口），可以加上final关键字。<br>不用每次检查是否为null，直接去检查其构造函数，看看其中没有null检查。</p>
<h2 id="IDE的warning"><a href="#IDE的warning" class="headerlink" title="IDE的warning"></a>IDE的warning</h2><p>发展到如今，IDE已经上warning提醒已经做得非常完善。<br>有时候因为做得过于完善，所以写一上午的代码，IDE啪啪啪列出十几条warning，大家反正懒得去看。就像每个香烟上都写着“吸烟有害健康”，也没见烟民们戒烟不抽。</p>
<blockquote>
<p>warning还是有用的，大家要理解IDE作者的良苦用心。</p>
</blockquote>
<p>最好是写好小一段代码，就去看看新增的warning，能过滤到一些低级的错误。</p>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>有人会说，这些安全性检查和处理，包括一些理论上不应该出现的情况。<br>本来出现这些情况，可以在开发过程中及时的闪退，在上线前修复。</p>
<blockquote>
<p>别担心，语言开发者早就想到了这个问题，祭出了大杀器Assert断言。</p>
</blockquote>
<p>而且现在的编译器，在release环境下会去掉断言，真是贴心。</p>
<h2 id="工具检查"><a href="#工具检查" class="headerlink" title="工具检查"></a>工具检查</h2><p>有时候难免有疏落，这个时候就需要lint去检查下。<br>在C/C++程序中，可以使用PC-lint，并且打开Pointer-parameter-may-be-NULL这个开关（+fpn）。选项假设所有传递到函数中的指针都有可能是NULL。</p>
<h2 id="重大错误"><a href="#重大错误" class="headerlink" title="重大错误"></a>重大错误</h2><p>如果当程序运行时出现重大错误，核心功能出现问题，程序还是会闪退的。<br>不要企图靠以上各种方法去续1s命。<br>这个时候就需要平时好好做好单元测试，以及好好对待测试人员，希望他们发现尽可能多的bug。</p>
<hr>
<p>总结下，这篇文章核心就是</p>
<blockquote>
<p>“对象使用前，要检查下其合理性”。</p>
</blockquote>
<p>当然检查的力度，是一个仁者见仁智者见智的问题。<br>一千个人读者有一千个哈姆雷特，有代码洁癖者，也有收放自如的高手。<br>这里面没有谁的策略更优。</p>
<blockquote>
<p>对自己来说，写的顺手bug少，最关键。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="corresponding" />
            
              <p class="site-author-name" itemprop="name">corresponding</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/corresponding" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-globe"></i>GitHub</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">corresponding</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
